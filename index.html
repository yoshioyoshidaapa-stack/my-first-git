<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VR GLB„Ç∑„Éß„ÉÉ„Éó„Ç¶„Ç©„Éº„ÇØ„Çπ„É´„Éº</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; }
        #container { width: 100vw; height: 100vh; cursor: grab; }
        #container:active { cursor: grabbing; }
        #info { position: absolute; top: 10px; left: 10px; color: white; background: rgba(0, 0, 0, 0.7); padding: 15px; border-radius: 8px; font-size: 14px; max-width: 320px; z-index: 100; }
        #controls { margin-top: 10px; padding-top: 10px; border-top: 1px solid rgba(255, 255, 255, 0.3); }
        #fileInput { margin-top: 10px; padding: 8px; background: rgba(255, 255, 255, 0.9); border: none; border-radius: 4px; cursor: pointer; width: 100%; }
        #vrButton { margin-top: 10px; padding: 12px; background: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer; width: 100%; font-size: 16px; font-weight: bold; }
        #vrButton:hover { background: #45a049; }
        #vrButton:disabled { background: #cccccc; cursor: not-allowed; }
        button { cursor: pointer; }
        .btn { margin-top: 10px; padding: 10px; border: none; border-radius: 4px; width: 100%; font-size: 14px; font-weight: bold; }
        #resetButton { background: #ff9800; color: white; }
        #clearButton { background: #f44336; color: white; margin-top: 5px; }
        #scaleControls { margin-top: 10px; padding: 10px; background: rgba(255, 255, 255, 0.1); border-radius: 4px; }
        #scaleSlider { width: 100%; margin: 10px 0; }
        #scaleValue { color: #aaffaa; font-weight: bold; }
        . scaleButtons { display: flex; gap: 5px; margin-top: 5px; }
        .scaleButtons button { flex: 1; padding: 8px; background: #2196F3; color: white; border: none; border-radius: 4px; font-size: 12px; }
        #memoPanel { position: absolute; top: 10px; right: 10px; width: 300px; max-height: 80vh; overflow-y: auto; background: rgba(0, 0, 0, 0.8); color: white; padding: 15px; border-radius: 8px; display: none; z-index: 100; }
        #memoPanel h3 { margin-top: 0; border-bottom: 2px solid #4CAF50; padding-bottom: 10px; }
        . memo-item { background: rgba(255, 255, 255, 0.1); padding: 10px; margin: 5px 0; border-radius: 4px; border-left: 4px solid #ffeb3b; }
        . memo-item button { margin-top: 5px; padding: 4px 8px; font-size: 11px; background: #f44336; color: white; border: none; border-radius: 3px; }
        #memoModeIndicator { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(76, 175, 80, 0.9); color: white; padding: 20px 40px; border-radius: 8px; font-size: 20px; font-weight: bold; display: none; z-index: 1000; pointer-events: none; }
        #voiceButton { margin-top: 10px; padding: 12px; background: #9C27B0; color: white; border: none; border-radius: 4px; width: 100%; font-size: 16px; font-weight: bold; }
        #voiceButton. recording { background: #f44336; animation: pulse 1s infinite; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.7; } }
        #inputMethodDialog, #memoInputDialog { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0, 0, 0, 0.95); padding: 30px; border-radius: 12px; display: none; z-index: 2000; }
        #inputMethodDialog h3, #memoInputDialog h3 { color: white; margin: 0 0 20px 0; text-align: center; }
        . input-method-buttons { display: flex; gap: 15px; }
        .input-method-buttons button { padding: 20px 30px; font-size: 18px; font-weight: bold; border: none; border-radius: 8px; }
        #voiceInputBtn { background: #9C27B0; color: white; }
        #keyboardInputBtn { background: #2196F3; color: white; }
        #memoInputDialog { width: 400px; }
        #memoTextarea { width: 100%; padding: 10px; border: 1px solid #ccc; border-radius: 4px; resize: vertical; font-size: 14px; box-sizing: border-box; background: #222; color: white; min-height: 100px; }
        . dialog-buttons { display: flex; gap: 10px; margin-top: 15px; }
        #submitMemoBtn { flex: 1; background: #4CAF50; color: white; padding: 12px 20px; font-weight: bold; border: none; border-radius: 4px; }
        #cancelMemoBtn { flex: 1; background: #666; color: white; padding: 12px 20px; font-weight: bold; border: none; border-radius: 4px; }
        #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; background: rgba(0, 0, 0, 0.8); padding: 20px 40px; border-radius: 8px; font-size: 18px; display: none; z-index: 1000; }
        #status { margin-top: 10px; font-size: 12px; color: #aaffaa; }
    </style>
</head>
<body>
    <div id="container"></div>
    <div id="info">
        <strong>VR „Ç∑„Éß„ÉÉ„Éó„Ç¶„Ç©„Éº„ÇØ„Çπ„É´„Éº</strong><br>
        <small id="updateDate" style="color: #aaa;"></small>
        <div id="controls">
            <strong>PC:</strong> W/A/S/DÁßªÂãï, „Éû„Ç¶„ÇπË¶ñÁÇπ, Q/E„Ç∫„Éº„É†, M„É°„É¢„É¢„Éº„Éâ<br>
            <strong>VR:</strong> Â∑¶„Çπ„ÉÜ„Ç£„ÉÉ„ÇØÁßªÂãï, Âè≥„Çπ„ÉÜ„Ç£„ÉÉ„ÇØË¶ñÁÇπ, A/B‰∏ä‰∏ã, Âè≥„Éà„É™„Ç¨„Éº„É°„É¢ÈÖçÁΩÆ, X„Éú„Çø„É≥Èï∑Êäº„Åó„É°„É¢„É¢„Éº„ÉâÂàáÊõø
        </div>
        <input type="file" id="fileInput" accept=".glb,. gltf,.obj,. stl" />
        <button id="vrButton">VR„É¢„Éº„ÉâÈñãÂßã</button>
        <button id="resetButton" class="btn">„Ç´„É°„É©„É™„Çª„ÉÉ„Éà</button>
        <button id="clearButton" class="btn">„É¢„Éá„É´ÂâäÈô§</button>
        <div id="scaleControls">
            <strong>„É¢„Éá„É´„Çµ„Ç§„Ç∫</strong><br>
            <span id="scaleValue">1. 0x</span>
            <input type="range" id="scaleSlider" min="0.1" max="10" step="0.1" value="1.0">
            <div class="scaleButtons">
                <button id="scale05">0.5x</button>
                <button id="scale1">1.0x</button>
                <button id="scale2">2.0x</button>
                <button id="scale5">5.0x</button>
            </div>
        </div>
        <div id="status"></div>
    </div>
    <div id="loading">Ë™≠„ÅøËæº„Åø‰∏≠...</div>
    <div id="memoModeIndicator">„É°„É¢„É¢„Éº„Éâ ON</div>
    <div id="memoPanel">
        <h3>„É°„É¢„É™„Çπ„Éà</h3>
        <button id="voiceButton">üé§ Èü≥Â£∞ÂÖ•Âäõ</button>
        <div id="memoList"></div>
    </div>
    <div id="inputMethodDialog">
        <h3>„É°„É¢ÂÖ•ÂäõÊñπÊ≥ï</h3>
        <div class="input-method-buttons">
            <button id="voiceInputBtn">üé§ Èü≥Â£∞</button>
            <button id="keyboardInputBtn">‚å® „Ç≠„Éº„Éú„Éº„Éâ</button>
        </div>
    </div>
    <div id="memoInputDialog">
        <h3>„É°„É¢ÂÖ•Âäõ</h3>
        <textarea id="memoTextarea" placeholder="„É°„É¢„ÇíÂÖ•Âäõ... "></textarea>
        <div class="dialog-buttons">
            <button id="submitMemoBtn">‰ΩúÊàê</button>
            <button id="cancelMemoBtn">„Ç≠„É£„É≥„Çª„É´</button>
        </div>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128. 0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr. net/npm/three@0. 128.0/examples/js/loaders/OBJLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/STLLoader.js"></script>
    <script>
        let scene, camera, renderer, cameraRig;
        let moveForward=false, moveBackward=false, moveLeft=false, moveRight=false;
        let velocity=new THREE.Vector3(), direction=new THREE.Vector3();
        let prevTime=performance.now(), euler=new THREE.Euler(0,0,0,'YXZ');
        let isMouseDown=false, lastMouseX=0, lastMouseY=0, zoomLevel=75;
        const MIN_FOV=30, MAX_FOV=100, PLAYER_HEIGHT=1.6, MOVE_SPEED=80, VR_MOVE_SPEED=10, VR_ROTATION_SPEED=1. 5;
        let controllers=[], isVRMode=false, memoMode=false, memos=[], memoCounter=0;
        let recognition=null, isRecording=false, pendingMemoPosition=null;
        let vrMemoMode=false, xButtonPressTime=0, xButtonCooldown=false;
        let vrDebugText=null, vrDebugCanvas=null;
        let rightTriggerPressed=false, rightGripPressed=false;
        let activeVRMemo=null;
        const VERSION='v1.2.2', UPDATE_DATE='2025/12/02 Display Fixed';

        function init() {
            document.getElementById('updateDate').textContent=`${VERSION} (${UPDATE_DATE})`;
            
            // „Ç∑„Éº„É≥‰ΩúÊàê
            scene=new THREE.Scene();
            scene.background=new THREE.Color(0x87CEEB);
            scene.fog=new THREE.Fog(0x87CEEB,0,100);
            
            // „Ç´„É°„É©„É™„Ç∞
            cameraRig=new THREE.Group();
            scene.add(cameraRig);
            
            // „Ç´„É°„É©
            camera=new THREE.PerspectiveCamera(75,window.innerWidth/window.innerHeight,0.1,2000);
            camera.position. set(0, PLAYER_HEIGHT, 10);
            cameraRig.add(camera);
            
            // „É¨„É≥„ÉÄ„É©„Éº
            renderer=new THREE.WebGLRenderer({antialias:true, alpha:false});
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled=true;
            renderer.xr.enabled=true;
            document.getElementById('container').appendChild(renderer.domElement);
            
            // „É©„Ç§„ÉàÂº∑Âåñ
            const ambientLight=new THREE.AmbientLight(0xffffff, 1. 0);
            scene.add(ambientLight);
            
            const directionalLight=new THREE.DirectionalLight(0xffffff, 1.2);
            directionalLight.position.set(10, 15, 10);
            directionalLight.castShadow=true;
            directionalLight.shadow.mapSize.width=2048;
            directionalLight.shadow.mapSize.height=2048;
            scene.add(directionalLight);
            
            // „Éï„É≠„Ç¢
            const floorGeometry=new THREE.PlaneGeometry(100, 100);
            const floorMaterial=new THREE.MeshStandardMaterial({color:0x808080, roughness:0.8});
            const floor=new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x=-Math.PI/2;
            floor.receiveShadow=true;
            scene.add(floor);
            
            // „ÉÜ„Çπ„ÉàÁî®ÁêÉÔºàÈùíËâ≤Ôºâ
            const sphereGeometry=new THREE.SphereGeometry(0.5, 32, 32);
            const sphereMaterial=new THREE.MeshStandardMaterial({color:0x0000ff});
            const sphere=new THREE. Mesh(sphereGeometry, sphereMaterial);
            sphere. position.set(0, 0. 5, -5);
            sphere.castShadow=true;
            scene. add(sphere);
            
            // ÂèÇËÄÉÁî®„Ç≠„É•„Éº„ÉñÔºàËµ§Ëâ≤Ôºâ
            const cubeGeometry=new THREE.BoxGeometry(1, 1, 1);
            const cubeMaterial=new THREE.MeshStandardMaterial({color:0xff0000});
            const cube=new THREE.Mesh(cubeGeometry, cubeMaterial);
            cube.position.set(-3, 0.5, -5);
            cube.castShadow=true;
            scene. add(cube);
            
            // ÂèÇËÄÉÁî®„Ç≠„É•„Éº„ÉñÔºàÁ∑ëËâ≤Ôºâ
            const cube2=new THREE.Mesh(cubeGeometry, new THREE.MeshStandardMaterial({color:0x00ff00}));
            cube2.position.set(3, 0. 5, -5);
            cube2.castShadow=true;
            scene.add(cube2);
            
            setupVR();
            createVRDebugPanel();
            
            // „Ç§„Éô„É≥„Éà„É™„Çπ„Éä„Éº
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            const c=document.getElementById('container');
            c.addEventListener('mousedown', onMouseDown);
            c.addEventListener('mousemove', onMouseMove);
            c.addEventListener('mouseup', ()=>isMouseDown=false);
            c.addEventListener('mouseleave', ()=>isMouseDown=false);
            c.addEventListener('wheel', onMouseWheel);
            
            document.getElementById('fileInput').addEventListener('change', onFileSelect);
            document.getElementById('resetButton').addEventListener('click', resetCamera);
            document.getElementById('clearButton').addEventListener('click', clearModel);
            document.getElementById('scaleSlider').addEventListener('input', e=>setScale(parseFloat(e.target.value)));
            document.getElementById('scale05').addEventListener('click', ()=>setScale(0.5));
            document.getElementById('scale1').addEventListener('click', ()=>setScale(1. 0));
            document.getElementById('scale2').addEventListener('click', ()=>setScale(2.0));
            document.getElementById('scale5').addEventListener('click', ()=>setScale(5.0));
            document.getElementById('voiceButton').addEventListener('click', toggleVoiceInput);
            document.getElementById('voiceInputBtn').addEventListener('click', chooseVoiceInput);
            document.getElementById('keyboardInputBtn').addEventListener('click', chooseKeyboardInput);
            document.getElementById('submitMemoBtn').addEventListener('click', submitMemo);
            document.getElementById('cancelMemoBtn').addEventListener('click', cancelMemoInput);
            window.addEventListener('resize', onWindowResize);
            
            initSpeechRecognition();
            renderer.setAnimationLoop(animate);
            
            document.getElementById('status').textContent = '‚úì ÂàùÊúüÂåñÂÆå‰∫Ü';
        }

        function setupVR() {
            const vrButton=document.getElementById('vrButton');
            if('xr' in navigator) {
                navigator.xr.isSessionSupported('immersive-vr').then(sup=>{
                    if(sup) {
                        vrButton.onclick=async()=>{
                            if(! renderer.xr.isPresenting) {
                                try {
                                    const s=await navigator.xr.requestSession('immersive-vr',{optionalFeatures:['local-floor','bounded-floor']});
                                    await renderer.xr.setSession(s);
                                    isVRMode=true;
                                } catch(e) {
                                    console.error('VR„Ç®„É©„Éº:', e);
                                }
                            }
                        };
                    } else {
                        vrButton. disabled=true;
                        vrButton.textContent='VRÈùûÂØæÂøú';
                    }
                });
            }
            const c1=renderer.xr.getController(0);
            scene.add(c1);
            controllers.push(c1);
            const c2=renderer.xr. getController(1);
            scene.add(c2);
            controllers.push(c2);
            const geom=new THREE.CylinderGeometry(0. 01, 0.02, 0.1, 8);
            const mat1=new THREE.MeshStandardMaterial({color:0xff0000});
            const mat2=new THREE.MeshStandardMaterial({color:0x0000ff});
            const g1=renderer.xr.getControllerGrip(0);
            g1.add(new THREE.Mesh(geom, mat1));
            scene.add(g1);
            const g2=renderer.xr.getControllerGrip(1);
            g2.add(new THREE.Mesh(geom, mat2));
            scene.add(g2);
        }

        function createVRDebugPanel() {
            vrDebugCanvas=document.createElement('canvas');
            vrDebugCanvas.width=512;
            vrDebugCanvas. height=512;
            const tex=new THREE.CanvasTexture(vrDebugCanvas);
            const mat=new THREE.MeshBasicMaterial({map:tex, transparent:true, side:THREE.DoubleSide});
            vrDebugText=new THREE. Mesh(new THREE.PlaneGeometry(1, 1), mat);
            vrDebugText.position.set(-2, 2, -3);
            scene.add(vrDebugText);
            updateVRDebugPanel('VR Debug\nReady');
        }

        function updateVRDebugPanel(txt) {
            if(! vrDebugCanvas)return;
            const ctx=vrDebugCanvas.getContext('2d');
            ctx.fillStyle='rgba(0,0,0,0.9)';
            ctx.fillRect(0, 0, 512, 512);
            ctx.strokeStyle='#0f0';
            ctx.lineWidth=4;
            ctx.strokeRect(0, 0, 512, 512);
            ctx.fillStyle='#0f0';
            ctx.font='bold 24px monospace';
            ctx.textAlign='left';
            ctx.textBaseline='top';
            txt. split('\n').forEach((l, i)=>ctx.fillText(l, 15, 15+i*30));
            if(vrDebugText?. material?.map)vrDebugText.material.map.needsUpdate=true;
        }

        function onFileSelect(e) {
            const f=e.target.files[0];
            if(! f)return;
            const ext=f.name.toLowerCase().split('.').pop();
            document.getElementById('loading').style.display='block';
            const r=new FileReader();
            r.onload=ev=>{
                const buf=ev.target.result;
                if(ext==='glb'||ext==='gltf')loadGLTF(buf);
                else if(ext==='obj')loadOBJ(buf);
                else if(ext==='stl')loadSTL(buf);
                else document.getElementById('loading').style.display='none';
            };
            r.readAsArrayBuffer(f);
        }

        function loadGLTF(buf) {
            new THREE.GLTFLoader().parse(buf,'', gltf=>addModelToScene(gltf. scene,'GLTF'), ()=>document.getElementById('loading').style.display='none');
        }

        function loadOBJ(buf) {
            try {
                const obj=new THREE.OBJLoader().parse(new TextDecoder().decode(buf));
                addModelToScene(obj, 'OBJ');
            } catch {
                document.getElementById('loading'). style.display='none';
            }
        }

        function loadSTL(buf) {
            try {
                const geom=new THREE.STLLoader().parse(buf);
                const mesh=new THREE. Mesh(geom, new THREE.MeshStandardMaterial({color:0xaaa}));
                addModelToScene(mesh, 'STL');
            } catch {
                document. getElementById('loading').style.display='none';
            }
        }

        function addModelToScene(model, fmt) {
            const old=scene.getObjectByName('loadedModel');
            if(old)scene.remove(old);
            model.name='loadedModel';
            model. traverse(n=>{
                if(n.isMesh) {
                    n.castShadow=n.receiveShadow=true;
                    if(! n.material)n.material=new THREE.MeshStandardMaterial({color:0xaaa});
                }
            });
            const box=new THREE.Box3(). setFromObject(model);
            const center=box.getCenter(new THREE.Vector3());
            model.position.set(-center.x, -box.min.y, -center.z);
            scene.add(model);
            document.getElementById('loading').style.display='none';
        }

        function onKeyDown(e) {
            if(document.getElementById('memoInputDialog').style.display==='block')return;
            if(e.code==='KeyW'||e.code==='ArrowUp')moveForward=true;
            if(e.code==='KeyS'||e.code==='ArrowDown')moveBackward=true;
            if(e.code==='KeyA'||e.code==='ArrowLeft')moveLeft=true;
            if(e.code==='KeyD'||e.code==='ArrowRight')moveRight=true;
            if(e.code==='KeyQ')zoomIn();
            if(e.code==='KeyE')zoomOut();
            if(e.code==='KeyM')toggleMemoMode();
        }

        function onKeyUp(e) {
            if(e.code==='KeyW'||e.code==='ArrowUp')moveForward=false;
            if(e.code==='KeyS'||e.code==='ArrowDown')moveBackward=false;
            if(e.code==='KeyA'||e.code==='ArrowLeft')moveLeft=false;
            if(e.code==='KeyD'||e.code==='ArrowRight')moveRight=false;
        }

        function onMouseDown(e) {
            if(document.getElementById('inputMethodDialog').style.display==='block'||document.getElementById('memoInputDialog').style.display==='block')return;
            if(memoMode&&e.button===0){placeMemo(e);return;}
            isMouseDown=true;
            lastMouseX=e.clientX;
            lastMouseY=e. clientY;
        }

        function onMouseMove(e) {
            if(!isMouseDown)return;
            const dx=e.clientX-lastMouseX, dy=e.clientY-lastMouseY;
            lastMouseX=e.clientX;
            lastMouseY=e.clientY;
            euler.setFromQuaternion(camera.quaternion);
            euler.y-=dx*0.002;
            euler.x-=dy*0.002;
            euler.x=Math.max(-Math.PI/2, Math.min(Math. PI/2, euler.x));
            camera.quaternion.setFromEuler(euler);
        }

        function onMouseWheel(e) {
            e.preventDefault();
            if(e.deltaY<0)zoomIn(); else zoomOut();
        }

        function zoomIn() {
            zoomLevel=Math.max(MIN_FOV, zoomLevel-5);
            camera.fov=zoomLevel;
            camera.updateProjectionMatrix();
        }

        function zoomOut() {
            zoomLevel=Math.min(MAX_FOV, zoomLevel+5);
            camera.fov=zoomLevel;
            camera.updateProjectionMatrix();
        }

        function resetCamera() {
            camera.position.set(0, PLAYER_HEIGHT, 10);
            camera.rotation.set(0, 0, 0);
            zoomLevel=75;
            camera.fov=zoomLevel;
            camera.updateProjectionMatrix();
            velocity.set(0, 0, 0);
        }

        function clearModel() {
            const m=scene.getObjectByName('loadedModel');
            if(m)scene.remove(m);
        }

        function setScale(s) {
            const m=scene.getObjectByName('loadedModel');
            if(! m)return;
            m. scale.set(s, s, s);
            document.getElementById('scaleSlider').value=s;
            document.getElementById('scaleValue'). textContent=`${s. toFixed(1)}x`;
        }

        function toggleMemoMode() {
            memoMode=!memoMode;
            const ind=document.getElementById('memoModeIndicator');
            const panel=document.getElementById('memoPanel');
            if(memoMode) {
                ind.style.display='block';
                panel.style.display='block';
                setTimeout(()=>ind.style.display='none', 2000);
            } else {
                ind.style.display='none';
                panel.style.display='none';
            }
        }

        function placeMemo(e) {
            const ray=new THREE. Raycaster();
            const mouse=new THREE.Vector2((e.clientX/window.innerWidth)*2-1, -(e.clientY/window. innerHeight)*2+1);
            ray.setFromCamera(mouse, camera);
            const hits=ray.intersectObjects(scene.children, true);
            let pos;
            if(hits.length>0) {
                const hit=hits[0];
                const offset=new THREE.Vector3();
                if(hit.face) {
                    offset.copy(hit.face.normal);
                    offset.transformDirection(hit.object.matrixWorld);
                } else {
                    offset.subVectors(camera.position, hit.point). normalize();
                }
                pos=hit.point.clone().add(offset. multiplyScalar(0.1));
            } else {
                const dir=new THREE.Vector3();
                camera.getWorldDirection(dir);
                pos=camera.position.clone().add(dir.multiplyScalar(3));
            }
            pendingMemoPosition=pos;
            document. getElementById('inputMethodDialog').style.display='block';
        }

        function chooseVoiceInput() {
            document.getElementById('inputMethodDialog').style.display='none';
            if(pendingMemoPosition&&recognition)startVoiceInputForMemo(pendingMemoPosition);
        }

        function chooseKeyboardInput() {
            document. getElementById('inputMethodDialog').style. display='none';
            if(pendingMemoPosition) {
                document.getElementById('memoTextarea').value='';
                document.getElementById('memoInputDialog').style.display='block';
            }
        }

        function submitMemo() {
            const txt=document.getElementById('memoTextarea').value. trim();
            document.getElementById('memoInputDialog'). style.display='none';
            if(txt&&pendingMemoPosition) {
                createMemo(pendingMemoPosition, txt);
                toggleMemoMode();
            }
            pendingMemoPosition=null;
        }

        function cancelMemoInput() {
            document.getElementById('memoInputDialog').style.display='none';
            pendingMemoPosition=null;
        }

        function createMemo(pos, txt) {
            const id=memoCounter++;
            const canvas=document.createElement('canvas');
            const ctx=canvas.getContext('2d');
            canvas.width=512;
            ctx.font='bold 32px Arial';
            const lines=[];
            txt. split('\n').forEach(para=>{
                const words=para.split(' ');
                let line='';
                words.forEach(word=>{
                    const test=line+word+' ';
                    if(ctx.measureText(test).width>472&&line! =='') {
                        lines.push(line. trim());
                        line=word+' ';
                    } else {
                        line=test;
                    }
                });
                lines.push(line.trim());
            });
            canvas.height=(lines.length*40)+40;
            ctx.fillStyle='#ffd93d';
            ctx.fillRect(0, 0, canvas. width, canvas.height);
            ctx.fillStyle='#000';
            ctx.font='bold 32px Arial';
            ctx.textAlign='center';
            ctx. textBaseline='top';
            let y=20;
            lines.forEach(line=>{
                ctx.fillText(line, 256, y);
                y+=40;
            });
            const tex=new THREE. CanvasTexture(canvas);
            const sprite=new THREE.Sprite(new THREE.SpriteMaterial({map:tex}));
            sprite. position.copy(pos);
            sprite.scale.set(1, canvas.height/canvas.width, 1);
            sprite.name=`memo_${id}`;
            scene. add(sprite);
            
            memos. push({id, text:txt, position:pos. clone(), sprite});
            updateMemoList();
        }

        function deleteMemo(id) {
            const idx=memos.findIndex(m=>m.id===id);
            if(idx!==-1) {
                scene.remove(memos[idx]. sprite);
                memos.splice(idx, 1);
                updateMemoList();
            }
        }

        function updateMemoList() {
            const list=document.getElementById('memoList');
            list.innerHTML='';
            memos.forEach(m=>{
                const item=document.createElement('div');
                item.className='memo-item';
                item.innerHTML=`<div><strong>#${m.id+1}</strong>: ${m.text. replace(/\n/g,'<br>')}</div><button onclick="deleteMemo(${m. id})">ÂâäÈô§</button>`;
                list.appendChild(item);
            });
        }

        function initSpeechRecognition() {
            if('webkitSpeechRecognition' in window||'SpeechRecognition' in window) {
                const SR=window.SpeechRecognition||window.webkitSpeechRecognition;
                recognition=new SR();
                recognition. lang='ja-JP';
                recognition.continuous=false;
                recognition.interimResults=false;
            } else {
                document.getElementById('voiceButton').disabled=true;
                document.getElementById('voiceButton'). textContent='üé§ ÈùûÂØæÂøú';
            }
        }

        let currentMemoPosition=null;

        function startVoiceInputForMemo(pos) {
            if(! recognition||isRecording)return;
            currentMemoPosition=pos;
            isRecording=true;
            document.getElementById('voiceButton').classList.add('recording');
            document.getElementById('voiceButton').textContent='üé§ Èå≤Èü≥‰∏≠...';
            recognition. onresult=ev=>{
                const transcript=ev.results[0][0].transcript;
                createMemo(currentMemoPosition, transcript);
                isRecording=false;
                document.getElementById('voiceButton'). classList.remove('recording');
                document.getElementById('voiceButton'). textContent='üé§ Èü≥Â£∞ÂÖ•Âäõ';
            };
            recognition.onerror=()=>{
                isRecording=false;
                document.getElementById('voiceButton').classList.remove('recording');
                document.getElementById('voiceButton').textContent='üé§ Èü≥Â£∞ÂÖ•Âäõ';
            };
            recognition.start();
        }

        function toggleVoiceInput() {
            if(! recognition)return;
            if(isRecording) {
                recognition.stop();
                isRecording=false;
                document.getElementById('voiceButton').classList.remove('recording');
                document.getElementById('voiceButton').textContent='üé§ Èü≥Â£∞ÂÖ•Âäõ';
                return;
            }
            const dir=new THREE.Vector3();
            camera.getWorldDirection(dir);
            const pos=camera. position.clone().add(dir. multiplyScalar(3));
            startVoiceInputForMemo(pos);
        }

        window.deleteMemo=deleteMemo;

        function onWindowResize() {
            camera.aspect=window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function handleVRControllers(delta) {
            const session=renderer.xr.getSession();
            if(! session||!session.inputSources||session.inputSources.length===0) return;
            
            let debugInfo=['VR Debug',''];
            if(vrMemoMode) debugInfo.push('MEMO MODE: ON');
            if(activeVRMemo) debugInfo.push('TRACKING MEMO');
            debugInfo.push(`FOV: ${zoomLevel. toFixed(1)}`);

            for(let i=0; i<session.inputSources. length; i++) {
                const inputSource=session.inputSources[i];
                const gamepad=inputSource.gamepad;
                if(! gamepad) continue;

                const pressedButtons=[];
                for(let btnIdx=0; btnIdx<gamepad.buttons.length; btnIdx++) {
                    if(gamepad.buttons[btnIdx].pressed) pressedButtons.push(btnIdx);
                }
                debugInfo.push(`${inputSource.handedness}: ${pressedButtons.join(',')}`);

                if(inputSource.handedness==='left') {
                    let moveX=0, moveZ=0;
                    if(Math.abs(gamepad.axes[0])>0.05)moveX=gamepad.axes[0];
                    if(Math.abs(gamepad.axes[1])>0.05)moveZ=-gamepad.axes[1];
                    
                    if(Math.abs(moveX)>0.05||Math.abs(moveZ)>0.05) {
                        const cameraWorldQuaternion=new THREE. Quaternion();
                        camera.getWorldQuaternion(cameraWorldQuaternion);
                        const forward=new THREE.Vector3(0, 0, -1);
                        forward.applyQuaternion(cameraWorldQuaternion);
                        forward.y=0;
                        forward.normalize();
                        const right=new THREE.Vector3(1, 0, 0);
                        right.applyQuaternion(cameraWorldQuaternion);
                        right.y=0;
                        right.normalize();
                        const moveVector=new THREE.Vector3();
                        moveVector.add(forward.multiplyScalar(moveZ*VR_MOVE_SPEED*delta));
                        moveVector.add(right.multiplyScalar(moveX*VR_MOVE_SPEED*delta));
                        cameraRig.position.x+=moveVector.x;
                        cameraRig.position.z+=moveVector.z;
                    }

                    const btn4Pressed=gamepad.buttons[4]&&gamepad.buttons[4].pressed;
                    if(btn4Pressed) {
                        if(! xButtonCooldown) {
                            if(xButtonPressTime===0) {
                                xButtonPressTime=performance.now();
                            } else {
                                const pressDuration=performance.now()-xButtonPressTime;
                                if(pressDuration>500) {
                                    vrMemoMode=!vrMemoMode;
                                    xButtonCooldown=true;
                                    xButtonPressTime=0;
                                }
                            }
                        }
                    } else {
                        xButtonPressTime=0;
                        xButtonCooldown=false;
                    }

                    for(let btnIdx=0; btnIdx<gamepad.buttons.length; btnIdx++) {
                        if(gamepad.buttons[btnIdx].pressed&&btnIdx!==4) {
                            if(btnIdx===0) cameraRig.position.y+=VR_MOVE_SPEED*delta;
                            else if(btnIdx===1) {
                                cameraRig. position.y-=VR_MOVE_SPEED*delta;
                                if(cameraRig.position. y<0)cameraRig.position.y=0;
                            }
                        }
                    }
                }

                if(inputSource.handedness==='right') {
                    const axes=gamepad.axes;
                    if(axes. length>=4) {
                        const rotX=axes[2]||0;
                        const rotY=axes[3]||0;
                        if(Math.abs(rotX)>0.1) cameraRig.rotation.y-=rotX*VR_ROTATION_SPEED*delta;
                        if(Math.abs(rotY)>0.1) {
                            camera.rotation.x-=rotY*VR_ROTATION_SPEED*delta;
                            camera.rotation.x=Math.max(-Math.PI/3, Math.min(Math.PI/3, camera.rotation.x));
                        }
                    }

                    const triggerBtn=gamepad.buttons[0];
                    const isTriggerPressed=triggerBtn&&triggerBtn.pressed;
                    
                    if(isTriggerPressed&&!rightTriggerPressed) {
                        if(vrMemoMode) createAndTrackVRMemo();
                        else zoomOut();
                        rightTriggerPressed=true;
                    } else if(! isTriggerPressed&&rightTriggerPressed) {
                        if(activeVRMemo) {
                            activeVRMemo=null;
                            vrMemoMode=false;
                        }
                        rightTriggerPressed=false;
                    }

                    const gripBtn=gamepad.buttons[1];
                    const isGripPressed=gripBtn&&gripBtn. pressed;
                    
                    if(isGripPressed&&! rightGripPressed) {
                        zoomIn();
                        rightGripPressed=true;
                    } else if(!isGripPressed&&rightGripPressed) {
                        rightGripPressed=false;
                    }
                }
            }
            updateVRDebugPanel(debugInfo. join('\n'));
        }

        function createAndTrackVRMemo() {
            try {
                const session=renderer. xr.getSession();
                if(!session||!session.inputSources) return;
                
                let rightController=null;
                for(let i=0; i<session.inputSources.length; i++) {
                    if(session.inputSources[i].handedness==='right') {
                        rightController=controllers[i];
                        break;
                    }
                }
                
                if(!rightController) return;
                
                const worldPosition=new THREE.Vector3();
                rightController.getWorldPosition(worldPosition);
                
                const worldDirection=new THREE.Vector3(0, 0, -1);
                const worldQuaternion=new THREE. Quaternion();
                rightController.getWorldQuaternion(worldQuaternion);
                worldDirection.applyQuaternion(worldQuaternion);
                
                const memoPosition=worldPosition.clone().add(worldDirection.multiplyScalar(0.3));
                
                const timestamp=new Date().toLocaleTimeString('ja-JP');
                const memoText=`VR„É°„É¢ ${timestamp}`;
                
                const id=memoCounter++;
                const canvas=document.createElement('canvas');
                const ctx=canvas.getContext('2d');
                canvas.width=512;
                ctx.font='bold 32px Arial';
                
                const lines=[];
                memoText.split('\n').forEach(para=>{
                    const words=para.split(' ');
                    let line='';
                    words.forEach(word=>{
                        const test=line+word+' ';
                        if(ctx.measureText(test).width>472&&line! =='') {
                            lines. push(line. trim());
                            line=word+' ';
                        } else {
                            line=test;
                        }
                    });
                    lines.push(line.trim());
                });
                
                canvas.height=(lines.length*40)+40;
                ctx.fillStyle='#ffd93d';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle='#000';
                ctx.font='bold 32px Arial';
                ctx.textAlign='center';
                ctx. textBaseline='top';
                let y=20;
                lines.forEach(line=>{
                    ctx.fillText(line, 256, y);
                    y+=40;
                });
                
                const tex=new THREE.CanvasTexture(canvas);
                const sprite=new THREE.Sprite(new THREE.SpriteMaterial({map:tex}));
                sprite. position.copy(memoPosition);
                sprite.scale.set(1, canvas.height/canvas.width, 1);
                sprite.name=`memo_${id}`;
                scene.add(sprite);
                
                activeVRMemo={
                    id,
                    text:memoText,
                    sprite,
                    controller:controllers[1]
                };
                
                memos.push({id, text:memoText, position:memoPosition. clone(), sprite});
                updateMemoList();
            } catch(error) {
                console.error('VR„É°„É¢„Ç®„É©„Éº:', error);
            }
        }

        function animate() {
            const time=performance.now();
            const delta=(time-prevTime)/1000;
            
            if(renderer.xr.isPresenting) {
                if(activeVRMemo&&activeVRMemo.controller) {
                    try {
                        const worldPosition=new THREE.Vector3();
                        activeVRMemo.controller.getWorldPosition(worldPosition);
                        
                        const worldDirection=new THREE.Vector3(0, 0, -1);
                        const worldQuaternion=new THREE. Quaternion();
                        activeVRMemo.controller.getWorldQuaternion(worldQuaternion);
                        worldDirection.applyQuaternion(worldQuaternion);
                        
                        const memoPosition=worldPosition.clone().add(worldDirection.multiplyScalar(0.3));
                        activeVRMemo.sprite.position.copy(memoPosition);
                    } catch(e) {}
                }
                
                handleVRControllers(delta);
            } else {
                velocity. x-=velocity.x*10*delta;
                velocity.z-=velocity.z*10*delta;
                direction.z=Number(moveBackward)-Number(moveForward);
                direction.x=Number(moveLeft)-Number(moveRight);
                direction.normalize();
                if(moveForward||moveBackward)velocity.z-=direction.z*MOVE_SPEED*delta;
                if(moveLeft||moveRight)velocity.x-=direction. x*MOVE_SPEED*delta;
                const forward=new THREE.Vector3(0, 0, -1);
                forward.applyQuaternion(camera.quaternion);
                forward.y=0;
                forward.normalize();
                const right=new THREE.Vector3(1, 0, 0);
                right.applyQuaternion(camera.quaternion);
                right.y=0;
                right.normalize();
                camera.position.add(forward.multiplyScalar(velocity.z*delta));
                camera.position.add(right.multiplyScalar(velocity.x*delta));
                if(camera.position.y<PLAYER_HEIGHT) camera.position.y=PLAYER_HEIGHT;
            }
            prevTime=time;
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>
