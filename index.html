<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>VR GLB„Ç∑„Éß„ÉÉ„Éó„Ç¶„Ç©„Éº„ÇØ„Çπ„É´„ÉºÔºàAÁâà - ÊúÄÂ∞è‰øÆÊ≠£ÁâàÔºâ</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; }
        #container { width: 100vw; height: 100vh; cursor: grab; }
        #container:active { cursor: grabbing; }
        #info { position: absolute; top: 10px; left: 10px; color: white; background: rgba(0,0,0,0.7); padding: 15px; border-radius: 8px; font-size: 14px; max-width: 320px; z-index: 100; }
        #controls { margin-top: 10px; padding-top: 10px; border-top: 1px solid rgba(255,255,255,0.3); }
        #fileInput { margin-top: 10px; padding: 8px; background: rgba(255,255,255,0.9); border: none; border-radius: 4px; cursor: pointer; width: 100%; }
        #vrButton { margin-top: 10px; padding: 12px; background: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer; width: 100%; font-size: 16px; font-weight: bold; }
        #vrButton:hover { background: #45a049; }
        #vrButton:disabled { background: #cccccc; cursor: not-allowed; }
        button { cursor: pointer; }
        .btn { margin-top: 10px; padding: 10px; border: none; border-radius: 4px; width: 100%; font-size: 14px; font-weight: bold; }
        #resetButton { background: #ff9800; color: white; }
        #clearButton { background: #f44336; color: white; margin-top: 5px; }
        #scaleControls { margin-top: 10px; padding: 10px; background: rgba(255,255,255,0.1); border-radius: 4px; }
        #scaleSlider { width: 100%; margin: 10px 0; }
        #scaleValue { color: #aaffaa; font-weight: bold; }
        .scaleButtons { display: flex; gap: 5px; margin-top: 5px; }
        .scaleButtons button { flex: 1; padding: 8px; background: #2196F3; color: white; border: none; border-radius: 4px; font-size: 12px; }
        #memoPanel { position: absolute; top: 10px; right: 10px; width: 300px; max-height: 80vh; overflow-y: auto; background: rgba(0, 0, 0, 0.8); color: white; padding: 15px; border-radius: 8px; display: none; z-index: 100; }
        #memoPanel h3 { margin-top: 0; border-bottom: 2px solid #4CAF50; padding-bottom: 10px; }
        .memo-item { background: rgba(255,255,255,0.1); padding: 10px; margin: 5px 0; border-radius: 4px; border-left: 4px solid #ffeb3b; }
        .memo-item button { margin-top: 5px; padding: 4px 8px; font-size: 11px; background: #f44336; color: white; border: none; border-radius: 3px; }
        #memoModeIndicator { position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%); background: rgba(76,175,80,0.9); color: white; padding: 20px 40px; border-radius: 8px; font-size: 20px; font-weight: bold; display: none; z-index: 1000; pointer-events: none; }
        #voiceButton { margin-top: 10px; padding: 12px; background: #9C27B0; color: white; border: none; border-radius: 4px; width: 100%; font-size: 16px; font-weight: bold; }
        #voiceButton.recording { background: #f44336; animation: pulse 1s infinite; }
        @keyframes pulse { 0%,100% { opacity:1 } 50%{ opacity:0.7 } }
        #inputMethodDialog, #memoInputDialog { position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%); background: rgba(0,0,0,0.95); padding: 30px; border-radius: 12px; display: none; z-index: 2000; }
        #inputMethodDialog h3, #memoInputDialog h3 { color: white; margin: 0 0 20px 0; text-align: center; }
        .input-method-buttons { display:flex; gap:15px; }
        .input-method-buttons button { padding:20px 30px; font-size:18px; font-weight:bold; border:none; border-radius:8px; }
        #voiceInputBtn { background:#9C27B0; color:white; }
        #keyboardInputBtn { background:#2196F3; color:white; }
        #memoInputDialog { width:400px; }
        #memoTextarea { width:100%; padding:10px; border:1px solid #ccc; border-radius:4px; resize:vertical; font-size:14px; box-sizing:border-box; background:#222; color:white; min-height:100px; }
        .dialog-buttons { display:flex; gap:10px; margin-top:15px; }
        #submitMemoBtn { flex:1; background:#4CAF50; color:white; padding:12px 20px; font-weight:bold; border:none; border-radius:4px; }
        #cancelMemoBtn { flex:1; background:#666; color:white; padding:12px 20px; font-weight:bold; border:none; border-radius:4px; }
        #loading { position:absolute; top:50%; left:50%; transform: translate(-50%,-50%); color:white; background: rgba(0,0,0,0.8); padding:20px 40px; border-radius:8px; font-size:18px; display:none; z-index:1000; }
        #status { margin-top:10px; font-size:12px; color:#aaffaa; }
    </style>
</head>
<body>
    <div id="container"></div>

    <div id="info">
        <strong>VR „Ç∑„Éß„ÉÉ„Éó„Ç¶„Ç©„Éº„ÇØ„Çπ„É´„Éº</strong><br>
        <small id="updateDate" style="color:#aaa"></small>
        <div id="controls">
            <strong>PC:</strong> W/A/S/DÁßªÂãï, „Éû„Ç¶„ÇπË¶ñÁÇπ, Q/E„Ç∫„Éº„É†, M„É°„É¢„É¢„Éº„Éâ<br>
            <strong>VR:</strong> Â∑¶„Çπ„ÉÜ„Ç£„ÉÉ„ÇØÁßªÂãï, Âè≥„Çπ„ÉÜ„Ç£„ÉÉ„ÇØË¶ñÁÇπ, A/B‰∏ä‰∏ã, Âè≥„Éà„É™„Ç¨„Éº„Ç∫„Éº„É†/„É°„É¢, X„Éú„Çø„É≥Èï∑Êäº„Åó„É°„É¢„É¢„Éº„ÉâÂàáÊõø
        </div>
        <input type="file" id="fileInput" accept=".glb,.gltf,.obj,.stl,.fbx" />
        <button id="vrButton">VR„É¢„Éº„ÉâÈñãÂßã</button>
        <button id="resetButton" class="btn">„Ç´„É°„É©„É™„Çª„ÉÉ„Éà</button>
        <button id="clearButton" class="btn">„É¢„Éá„É´ÂâäÈô§</button>

        <div id="scaleControls">
            <strong>„É¢„Éá„É´„Çµ„Ç§„Ç∫</strong><br>
            <span id="scaleValue">1.0x</span>
            <input id="scaleSlider" type="range" min="0.1" max="10" step="0.1" value="1.0" />
            <div class="scaleButtons">
                <button id="scale05">0.5x</button>
                <button id="scale1">1.0x</button>
                <button id="scale2">2.0x</button>
                <button id="scale5">5.0x</button>
            </div>
        </div>

        <div id="status"></div>
    </div>

    <div id="loading">Ë™≠„ÅøËæº„Åø‰∏≠...</div>
    <div id="memoModeIndicator">„É°„É¢„É¢„Éº„Éâ ON</div>

    <div id="memoPanel">
        <h3>„É°„É¢„É™„Çπ„Éà</h3>
        <button id="voiceButton">üé§ Èü≥Â£∞ÂÖ•Âäõ</button>
        <div id="memoList"></div>
    </div>

    <div id="inputMethodDialog">
        <h3>„É°„É¢ÂÖ•ÂäõÊñπÊ≥ï</h3>
        <div class="input-method-buttons">
            <button id="voiceInputBtn">üé§ Èü≥Â£∞</button>
            <button id="keyboardInputBtn">‚å® „Ç≠„Éº„Éú„Éº„Éâ</button>
        </div>
    </div>

    <div id="memoInputDialog">
        <h3>„É°„É¢ÂÖ•Âäõ</h3>
        <textarea id="memoTextarea" placeholder="„É°„É¢„ÇíÂÖ•Âäõ..."></textarea>
        <div class="dialog-buttons">
            <button id="submitMemoBtn">‰ΩúÊàê</button>
            <button id="cancelMemoBtn">„Ç≠„É£„É≥„Çª„É´</button>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/fflate@0.7.4/umd/index.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/OBJLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/STLLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/FBXLoader.js"></script>

    <script>
    let scene, camera, renderer, cameraRig;
    let moveForward=false, moveBackward=false, moveLeft=false, moveRight=false;
    let velocity=new THREE.Vector3(), direction=new THREE.Vector3();
    let prevTime=performance.now(), euler=new THREE.Euler(0,0,0,'YXZ');
    let isMouseDown=false, lastMouseX=0, lastMouseY=0, zoomLevel=75;
    const MIN_FOV=30, MAX_FOV=100, PLAYER_HEIGHT=1.6, MOVE_SPEED=80, VR_MOVE_SPEED=10, VR_ROTATION_SPEED=1.5;
    let controllers=[], isVRMode=false, memoMode=false, memos=[], memoCounter=0;
    let recognition=null, isRecording=false, pendingMemoPosition=null;
    let vrMemoMode=true;
    let vrDebugText=null, vrDebugCanvas=null;
    let xButtonCooldown=false, xButtonPressTime=0;
    let rightTriggerPressed=false, rightGripPressed=false;
    let vrZoomLevel=0;
    let rightTriggerPressTime=0;
    let editingMemo = null;
    let hoveredMemo = null;
    let btn1WasPressed = false;
    let pendingDeleteMemo = null;
        
        

        
let vrPendingMemoPosition = null;  // ‚Üê „Åì„ÅÆË°å„ÇíËøΩÂä†
        let romajiBuffer = '';
        const ROMAJI_TABLE = {
  a:'„ÅÇ', i:'„ÅÑ', u:'„ÅÜ', e:'„Åà', o:'„Åä',
  ka:'„Åã', ki:'„Åç', ku:'„Åè', ke:'„Åë', ko:'„Åì',
  sa:'„Åï', si:'„Åó', shi:'„Åó', su:'„Åô', se:'„Åõ', so:'„Åù',
  ta:'„Åü', ti:'„Å°', chi:'„Å°', tu:'„Å§', tsu:'„Å§', te:'„Å¶', to:'„Å®',
  na:'„Å™', ni:'„Å´', nu:'„Å¨', ne:'„Å≠', no:'„ÅÆ',
  ha:'„ÅØ', hi:'„Å≤', hu:'„Åµ', fu:'„Åµ', he:'„Å∏', ho:'„Åª',
  ma:'„Åæ', mi:'„Åø', mu:'„ÇÄ', me:'„ÇÅ', mo:'„ÇÇ',
  ya:'„ÇÑ', yu:'„ÇÜ', yo:'„Çà',
  ra:'„Çâ', ri:'„Çä', ru:'„Çã', re:'„Çå', ro:'„Çç',
  wa:'„Çè', wo:'„Çí',

  ga:'„Åå', gi:'„Åé', gu:'„Åê', ge:'„Åí', go:'„Åî',
  za:'„Åñ', zi:'„Åò', ji:'„Åò', zu:'„Åö', ze:'„Åú', zo:'„Åû',
  da:'„Å†', di:'„Å¢', du:'„Å•', de:'„Åß', do:'„Å©',
  ba:'„Å∞', bi:'„Å≥', bu:'„Å∂', be:'„Åπ', bo:'„Åº',
  pa:'„Å±', pi:'„Å¥', pu:'„Å∑', pe:'„Å∫', po:'„ÅΩ',

  kya:'„Åç„ÇÉ', kyu:'„Åç„ÇÖ', kyo:'„Åç„Çá',
  sha:'„Åó„ÇÉ', shu:'„Åó„ÇÖ', sho:'„Åó„Çá',
  cha:'„Å°„ÇÉ', chu:'„Å°„ÇÖ', cho:'„Å°„Çá',
  nya:'„Å´„ÇÉ', nyu:'„Å´„ÇÖ', nyo:'„Å´„Çá',
  hya:'„Å≤„ÇÉ', hyu:'„Å≤„ÇÖ', hyo:'„Å≤„Çá',
  mya:'„Åø„ÇÉ', myu:'„Åø„ÇÖ', myo:'„Åø„Çá',
  rya:'„Çä„ÇÉ', ryu:'„Çä„ÇÖ', ryo:'„Çä„Çá',
  gya:'„Åé„ÇÉ', gyu:'„Åé„ÇÖ', gyo:'„Åé„Çá',
  bya:'„Å≥„ÇÉ', byu:'„Å≥„ÇÖ', byo:'„Å≥„Çá',
  pya:'„Å¥„ÇÉ', pyu:'„Å¥„ÇÖ', pyo:'„Å¥„Çá',

  la:'„ÅÅ', li:'„ÅÉ', lu:'„ÅÖ', le:'„Åá', lo:'„Åâ',
  xa:'„ÅÅ', xi:'„ÅÉ', xu:'„ÅÖ', xe:'„Åá', xo:'„Åâ',
  lya:'„ÇÉ', lyu:'„ÇÖ', lyo:'„Çá',
  xya:'„ÇÉ', xyu:'„ÇÖ', xyo:'„Çá',

  n:'„Çì',
  '-':'„Éº'
};


let vrKeyboardInput = '';
let vrKeyboardMode = false;
        let vrKeyboardPanel = null;
    let audioContext = null;
    let audioAnalyser = null;
    let audioDataArray = null;
    const VERSION='AÁâà v1.0.1', UPDATE_DATE='2026/01/15_16';

    function loadFBX(buf) {
        try {
            const loader = new THREE.FBXLoader();
            loader.parse(buf, '', fbx => {
                console.log('FBX loaded successfully', fbx);
                addModelToScene(fbx, 'FBX');
            }, err => {
                console.error('FBX parse error', err);
                document.getElementById('loading').style.display='none';
                document.getElementById('status').textContent='FBXË™≠„ÅøËæº„Åø„Ç®„É©„Éº';
            });
        } catch (err) {
            console.error('FBX load error', err);
            document.getElementById('loading').style.display='none';
            document.getElementById('status').textContent='FBXË™≠„ÅøËæº„Åø„Ç®„É©„Éº: ' + err.message;
        }
    }

    function init() {
        document.getElementById('updateDate').textContent=`${VERSION} (${UPDATE_DATE})`;
        scene=new THREE.Scene();
        scene.background=new THREE.Color(0x87CEEB);
        scene.fog=new THREE.Fog(0x87CEEB,0,50);
        cameraRig=new THREE.Group();
        scene.add(cameraRig);
        camera=new THREE.PerspectiveCamera(75,window.innerWidth/window.innerHeight,0.1,1000);
        camera.position.set(0,PLAYER_HEIGHT,5);
        cameraRig.add(camera);
        renderer=new THREE.WebGLRenderer({antialias:true});
        renderer.setSize(window.innerWidth,window.innerHeight);
        renderer.shadowMap.enabled=true;
        renderer.xr.enabled=true;
        document.getElementById('container').appendChild(renderer.domElement);

        setupVR();
        createVRDebugPanel();

        scene.add(new THREE.AmbientLight(0xffffff,0.6));
        const light=new THREE.DirectionalLight(0xffffff,0.8);
        light.position.set(5,10,5);
        light.castShadow=true;
        scene.add(light);
        const floor=new THREE.Mesh(new THREE.PlaneGeometry(50,50),new THREE.MeshStandardMaterial({color:0x808080}));
        floor.rotation.x=-Math.PI/2;
        floor.receiveShadow=true;
        scene.add(floor);

        const sphere=new THREE.Mesh(new THREE.SphereGeometry(0.5,32,32),new THREE.MeshStandardMaterial({color:0xff0000}));
        sphere.position.set(0,0.5,-3);
        sphere.castShadow=true;
        scene.add(sphere);

        document.addEventListener('keydown',onKeyDown);
        document.addEventListener('keyup',onKeyUp);
        const c=document.getElementById('container');
        c.addEventListener('mousedown',onMouseDown);
        c.addEventListener('mousemove',onMouseMove);
        c.addEventListener('mouseup',()=>isMouseDown=false);
        c.addEventListener('mouseleave',()=>isMouseDown=false);
        c.addEventListener('wheel',onMouseWheel);

        document.getElementById('fileInput').addEventListener('change',onFileSelect);
        document.getElementById('resetButton').addEventListener('click',resetCamera);
        document.getElementById('clearButton').addEventListener('click',clearModel);
        document.getElementById('scaleSlider').addEventListener('input',e=>setScale(parseFloat(e.target.value)));
        document.getElementById('scale05').addEventListener('click',()=>setScale(0.5));
        document.getElementById('scale1').addEventListener('click',()=>setScale(1.0));
        document.getElementById('scale2').addEventListener('click',()=>setScale(2.0));
        document.getElementById('scale5').addEventListener('click',()=>setScale(5.0));
        document.getElementById('voiceButton').addEventListener('click',toggleVoiceInput);
        document.getElementById('voiceInputBtn').addEventListener('click',chooseVoiceInput);
        document.getElementById('keyboardInputBtn').addEventListener('click',chooseKeyboardInput);
        document.getElementById('submitMemoBtn').addEventListener('click',submitMemo);
        document.getElementById('cancelMemoBtn').addEventListener('click',cancelMemoInput);
        window.addEventListener('resize',onWindowResize);
        initSpeechRecognition();
        renderer.setAnimationLoop(animate);
    }

    function setupVR() {
        const vrButton=document.getElementById('vrButton');
        let controllerGrips = [];
        
        if('xr' in navigator) {
            navigator.xr.isSessionSupported('immersive-vr').then(sup=>{
                if(sup) {
                    vrButton.onclick=async()=>{
                        if(!renderer.xr.isPresenting) {
                            try {
                                controllers.forEach(c => {
                                    c.children.forEach(child => c.remove(child));
                                    cameraRig.remove(c);
                                });
                                controllerGrips.forEach(g => {
                                    g.children.forEach(child => g.remove(child));
                                    cameraRig.remove(g);
                                });
                                controllers = [];
                                controllerGrips = [];
                                
                                const s=await navigator.xr.requestSession('immersive-vr',{optionalFeatures:['local-floor','bounded-floor']});
                                await renderer.xr.setSession(s);
                                isVRMode=true;
                                
                                const c1=renderer.xr.getController(0);
                                cameraRig.add(c1);
                                controllers.push(c1);
                                const c2=renderer.xr.getController(1);
                                cameraRig.add(c2);
                                controllers.push(c2);

                                const geom=new THREE.BoxGeometry(0.05,0.05,0.15);
                                const mat1=new THREE.MeshStandardMaterial({color:0xff5555,emissive:0xff2222,emissiveIntensity:0.3});
                                const mat2=new THREE.MeshStandardMaterial({color:0x5555ff,emissive:0x2222ff,emissiveIntensity:0.3});
                                const g1=renderer.xr.getControllerGrip(0);
                                const mesh1=new THREE.Mesh(geom,mat1);
                                mesh1.position.z=-0.075;
                                g1.add(mesh1);
                                cameraRig.add(g1);
                                controllerGrips.push(g1);
                                
                                const g2=renderer.xr.getControllerGrip(1);
                                const mesh2=new THREE.Mesh(geom,mat2);
                                mesh2.position.z=-0.075;
                                g2.add(mesh2);
                                cameraRig.add(g2);
                                controllerGrips.push(g2);

                                const lineGeom=new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,0),new THREE.Vector3(0,0,-2)]);
                                const lineMat1=new THREE.LineBasicMaterial({color:0xff0000,linewidth:2});
                                const lineMat2=new THREE.LineBasicMaterial({color:0x0000ff,linewidth:2});
                                c1.add(new THREE.Line(lineGeom,lineMat1));
                                c2.add(new THREE.Line(lineGeom,lineMat2));
                                
                                s.addEventListener('end', () => {
                                    isVRMode = false;
                                });
                            } catch(e) {
                                console.error('XR start failed', e);
                            }
                        }
                    };
                } else {
                    vrButton.disabled=true;
                    vrButton.textContent='VRÈùûÂØæÂøú';
                }
            }).catch(err=>{
                console.warn('isSessionSupported error', err);
                vrButton.disabled=true;
                vrButton.textContent='VRÈùûÂØæÂøú';
            });
        } else {
            vrButton.disabled=true;
            vrButton.textContent='VRÈùûÂØæÂøú';
        }

        const c1=renderer.xr.getController(0);
        cameraRig.add(c1);
        controllers.push(c1);
        const c2=renderer.xr.getController(1);
        cameraRig.add(c2);
        controllers.push(c2);

        const geom=new THREE.BoxGeometry(0.05,0.05,0.15);
        const mat1=new THREE.MeshStandardMaterial({color:0xff5555,emissive:0xff2222,emissiveIntensity:0.3});
        const mat2=new THREE.MeshStandardMaterial({color:0x5555ff,emissive:0x2222ff,emissiveIntensity:0.3});
        const g1=renderer.xr.getControllerGrip(0);
        const mesh1=new THREE.Mesh(geom,mat1);
        mesh1.position.z=-0.075;
        g1.add(mesh1);
        cameraRig.add(g1);
        controllerGrips.push(g1);
        
        const g2=renderer.xr.getControllerGrip(1);
        const mesh2=new THREE.Mesh(geom,mat2);
        mesh2.position.z=-0.075;
        g2.add(mesh2);
        cameraRig.add(g2);
        controllerGrips.push(g2);

        const lineGeom=new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,0),new THREE.Vector3(0,0,-2)]);
        const lineMat1=new THREE.LineBasicMaterial({color:0xff0000,linewidth:2});
        const lineMat2=new THREE.LineBasicMaterial({color:0x0000ff,linewidth:2});
        c1.add(new THREE.Line(lineGeom,lineMat1));
        c2.add(new THREE.Line(lineGeom,lineMat2));
    }

    function createVRDebugPanel() {
        vrDebugCanvas=document.createElement('canvas');
        vrDebugCanvas.width=512;
        vrDebugCanvas.height=512;
        const tex=new THREE.CanvasTexture(vrDebugCanvas);
        tex.minFilter = THREE.LinearFilter;
        const mat=new THREE.MeshBasicMaterial({map:tex,transparent:true,side:THREE.DoubleSide,depthTest:false});
        vrDebugText=new THREE.Mesh(new THREE.PlaneGeometry(1,1),mat);
        vrDebugText.position.set(-1,2,-2);
        vrDebugText.renderOrder = 9999;
        scene.add(vrDebugText);
        updateVRDebugPanel('VR Debug\nReady');
    }

    function updateVRDebugPanel(txt) {
        if(!vrDebugCanvas)return;
        const ctx=vrDebugCanvas.getContext('2d');
        ctx.clearRect(0,0,vrDebugCanvas.width,vrDebugCanvas.height);
        ctx.fillStyle='rgba(0,0,0,0.9)';
        ctx.fillRect(0,0,512,512);
        ctx.strokeStyle='#0f0';
        ctx.lineWidth=4;
        ctx.strokeRect(0,0,512,512);
        ctx.fillStyle='#0f0';
        ctx.font='bold 20px monospace';
        ctx.textAlign='left';
        ctx.textBaseline='top';
        txt.split('\n').forEach((l,i)=>ctx.fillText(l,15,15+i*28));
        if(vrDebugText?.material?.map) vrDebugText.material.map.needsUpdate=true;
    }

    function onFileSelect(e) {
        const f=e.target.files[0];
        if(!f)return;
        const ext=f.name.toLowerCase().split('.').pop();
        document.getElementById('loading').style.display='block';
        const r=new FileReader();
        r.onload=ev=>{
            const buf=ev.target.result;
            if(ext==='glb'||ext==='gltf')loadGLTF(buf);
            else if(ext==='obj')loadOBJ(buf);
            else if(ext==='stl')loadSTL(buf);
            else if(ext==='fbx')loadFBX(buf);
            else document.getElementById('loading').style.display='none';
        };
        r.readAsArrayBuffer(f);
    }

    function loadGLTF(buf) {
        new THREE.GLTFLoader().parse(buf,'',gltf=>addModelToScene(gltf.scene,'GLTF'),()=>document.getElementById('loading').style.display='none');
    }

    function loadOBJ(buf) {
        try {
            const obj=new THREE.OBJLoader().parse(new TextDecoder().decode(buf));
            addModelToScene(obj,'OBJ');
        } catch (err) {
            console.error('OBJ load error', err);
            document.getElementById('loading').style.display='none';
        }
    }

    function loadSTL(buf) {
        try {
            const geom=new THREE.STLLoader().parse(buf);
            const mesh=new THREE.Mesh(geom,new THREE.MeshStandardMaterial({color:0xaaa}));
            addModelToScene(mesh,'STL');
        } catch (err) {
            console.error('STL load error', err);
            document.getElementById('loading').style.display='none';
        }
    }

    function addModelToScene(model,fmt) {
        const old=scene.getObjectByName('loadedModel');
        if(old) scene.remove(old);
        model.name='loadedModel';
        model.traverse(n=>{
            if(n.isMesh) {
                n.castShadow=n.receiveShadow=true;
                if(!n.material)n.material=new THREE.MeshStandardMaterial({color:0xaaa});
            }
        });
        const box=new THREE.Box3().setFromObject(model);
        const center=box.getCenter(new THREE.Vector3());
        model.position.set(-center.x,-box.min.y,-center.z);
        scene.add(model);
        document.getElementById('loading').style.display='none';
        document.getElementById('status').textContent=`${fmt} Ë™≠„ÅøËæº„ÅøÂÆå‰∫Ü`;
    }

    function onKeyDown(e) {
        if(document.getElementById('memoInputDialog').style.display==='block')return;
        if(e.code==='KeyW'||e.code==='ArrowUp')moveForward=true;
        if(e.code==='KeyS'||e.code==='ArrowDown')moveBackward=true;
        if(e.code==='KeyA'||e.code==='ArrowLeft')moveLeft=true;
        if(e.code==='KeyD'||e.code==='ArrowRight')moveRight=true;
        if(e.code==='KeyQ')zoomIn();
        if(e.code==='KeyE')zoomOut();
        if(e.code==='KeyM')toggleMemoMode();
    }

    function onKeyUp(e) {
        if(e.code==='KeyW'||e.code==='ArrowUp')moveForward=false;
        if(e.code==='KeyS'||e.code==='ArrowDown')moveBackward=false;
        if(e.code==='KeyA'||e.code==='ArrowLeft')moveLeft=false;
        if(e.code==='KeyD'||e.code==='ArrowRight')moveRight=false;
    }

    function onMouseDown(e) {
        if(document.getElementById('inputMethodDialog').style.display==='block'||document.getElementById('memoInputDialog').style.display==='block')return;
        if(memoMode&&e.button===0){placeMemo(e);return;}
        isMouseDown=true;
        lastMouseX=e.clientX;
        lastMouseY=e.clientY;
    }

    function onMouseMove(e) {
        if(!isMouseDown)return;
        const dx=e.clientX-lastMouseX,dy=e.clientY-lastMouseY;
        lastMouseX=e.clientX;
        lastMouseY=e.clientY;
        euler.setFromQuaternion(camera.quaternion);
        euler.y-=dx*0.002;
        euler.x-=dy*0.002;
        euler.x=Math.max(-Math.PI/2,Math.min(Math.PI/2,euler.x));
        camera.quaternion.setFromEuler(euler);
    }

    function onMouseWheel(e) {
        e.preventDefault();
        if(e.deltaY<0)zoomIn();else zoomOut();
    }

    function zoomIn() {
        zoomLevel=Math.max(MIN_FOV,zoomLevel-5);
        camera.fov=zoomLevel;
        camera.updateProjectionMatrix();
    }

    function zoomOut() {
        zoomLevel=Math.min(MAX_FOV,zoomLevel+5);
        camera.fov=zoomLevel;
        camera.updateProjectionMatrix();
    }

    function resetCamera() {
        camera.position.set(0,PLAYER_HEIGHT,5);
        camera.rotation.set(0,0,0);
        zoomLevel=75;
        camera.fov=zoomLevel;
        camera.updateProjectionMatrix();
        velocity.set(0,0,0);
    }

    function clearModel() {
        const m=scene.getObjectByName('loadedModel');
        if(m)scene.remove(m);
    }

    function setScale(s) {
        const m=scene.getObjectByName('loadedModel');
        if(!m)return;
        m.scale.set(s,s,s);
        document.getElementById('scaleSlider').value=s;
        document.getElementById('scaleValue').textContent=`${s.toFixed(1)}x`;
    }

    function toggleMemoMode() {
        memoMode=!memoMode;
        const ind=document.getElementById('memoModeIndicator');
        const panel=document.getElementById('memoPanel');
        if(memoMode) {
            ind.style.display='block';
            panel.style.display='block';
            setTimeout(()=>ind.style.display='none',2000);
        } else {
            ind.style.display='none';
            panel.style.display='none';
        }
    }

    function placeMemo(e) {
        const ray=new THREE.Raycaster();
        const mouse=new THREE.Vector2((e.clientX/window.innerWidth)*2-1,-(e.clientY/window.innerHeight)*2+1);
        ray.setFromCamera(mouse,camera);
        const hits=ray.intersectObjects(scene.children,true);
        let pos;
        if(hits.length>0) {
            const hit=hits[0];
            const offset=new THREE.Vector3();
            if(hit.face) {
                offset.copy(hit.face.normal);
                offset.transformDirection(hit.object.matrixWorld);
            } else {
                offset.subVectors(camera.position,hit.point).normalize();
            }
            pos=hit.point.clone().add(offset.multiplyScalar(0.1));
        } else {
            
            const dir = new THREE.Vector3();
camera.getWorldDirection(dir);

            pos=camera.position.clone().add(dir.multiplyScalar(3));
        }
        pendingMemoPosition=pos;
document.getElementById('inputMethodDialog').style.display='block';
}
function chooseVoiceInput() {
    document.getElementById('inputMethodDialog').style.display='none';
    if(pendingMemoPosition&&recognition)startVoiceInputForMemo(pendingMemoPosition);
}

function chooseKeyboardInput() {
    document.getElementById('inputMethodDialog').style.display='none';
    if(pendingMemoPosition) {
        document.getElementById('memoTextarea').value='';
        document.getElementById('memoInputDialog').style.display='block';
    }
}

function submitMemo() {
    const txt=document.getElementById('memoTextarea').value.trim();
    document.getElementById('memoInputDialog').style.display='none';
    if(txt&&pendingMemoPosition) {
        createMemo(pendingMemoPosition,txt);
        toggleMemoMode();
    }
    pendingMemoPosition=null;
}

function cancelMemoInput() {
    document.getElementById('memoInputDialog').style.display='none';
    pendingMemoPosition=null;
}

function createMemo(pos, txt) {
    const id = memoCounter++;
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    canvas.width = 512;
    ctx.font = 'bold 32px Arial';
    const lines = [];
    txt.split('\n').forEach(para=>{
        const words = para.split(' ');
        let line = '';
        words.forEach(word=>{
            const test = line + word + ' ';
            if(ctx.measureText(test).width > 472 && line !== '') {
                lines.push(line.trim());
                line = word + ' ';
            } else {
                line = test;
            }
        });
        lines.push(line.trim());
    });
    canvas.height = (lines.length * 40) + 40;
    ctx.fillStyle = '#ffd93d';
    ctx.fillRect(0,0,canvas.width,canvas.height);
    ctx.fillStyle = '#000';
    ctx.font = 'bold 32px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    let y = 20;
    lines.forEach(line=>{
        ctx.fillText(line,256,y);
        y += 40;
    });

    const tex = new THREE.CanvasTexture(canvas);
    tex.minFilter = THREE.LinearFilter;

    const aspect = canvas.height / canvas.width;
    const baseWidth = 0.6;
    const baseHeight = baseWidth * aspect;
    const geom = new THREE.PlaneGeometry(baseWidth, baseHeight);
    const mat = new THREE.MeshBasicMaterial({
        map: tex,
        transparent: true,
        side: THREE.DoubleSide,
        depthTest: false,
        depthWrite: false
    });
    const mesh = new THREE.Mesh(geom, mat);
    mesh.position.copy(pos);
    // „Éà„É™„Ç¨„Éº„ÇíÊäº„Åó„ÅüÁû¨Èñì„ÅÆ„Ç´„É°„É©‰ΩçÁΩÆ„ÅÆÊñπ„ÇíÂêë„Åã„Åõ„Çã
const lookTarget = new THREE.Vector3();
camera.getWorldPosition(lookTarget);
mesh.lookAt(lookTarget);


   
    
    mesh.renderOrder = 9999;
    mesh.name = `memo_${id}`;

    mesh.userData = mesh.userData || {};
    mesh.userData.text = txt;
    mesh.userData.aspect = aspect;
    mesh.userData.isMemo = true;

    scene.add(mesh);

    memos.push({id, text: txt, position: pos.clone(), sprite: mesh});
    updateMemoList();

// ‰ΩúÊàêÊôÇ„ÅÆ„Ç´„É°„É©Âêë„Åç„Åß„É°„É¢„ÇíÊ≠£Èù¢„Å´„Åô„Çã
// ‰ΩúÊàêÊôÇ„ÅÆ„Ç´„É°„É©ÊñπÂêë„ÇíÂêë„Åã„Åõ„ÇãÔºà„Åì„ÅÆ1Âõû„Å†„ÅëÔºâ
// ÁΩÆ„ÅÑ„ÅüÁû¨Èñì„ÅÆ„Ç´„É°„É©Âêë„Åç„ÅßÊ≠£ÂÉè„Å´„Åô„ÇãÔºà‰ª•Âæå„ÅØÂõ∫ÂÆöÔºâ







    
}

function deleteMemo(id) {
    const idx=memos.findIndex(m=>m.id===id);
    if(idx!==-1) {
        const s = memos[idx].sprite;
        if(s) scene.remove(s);
        memos.splice(idx,1);
        updateMemoList();
    }
}

function updateMemoList() {
    const list=document.getElementById('memoList');
    list.innerHTML='';
   
}

function createMemoSprite(pos, txt) {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    canvas.width = 512;
    ctx.font = 'bold 32px Arial';
    const lines = [];
    txt.split('\n').forEach(para => {
        const words = para.split(' ');
        let line = '';
        words.forEach(word => {
            const test = line + word + ' ';
            if(ctx.measureText(test).width > 472 && line !== '') {
                lines.push(line.trim());
                line = word + ' ';
            } else {
                line = test;
            }
        });
        lines.push(line.trim());
    });
    canvas.height = (lines.length * 40) + 40;
    ctx.fillStyle = '#ffd93d';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = '#000';
    ctx.font = 'bold 32px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    let y = 20;
    lines.forEach(line => {
        ctx.fillText(line, 256, y);
        y += 40;
    });
    const tex = new THREE.CanvasTexture(canvas);
    tex.minFilter = THREE.LinearFilter;

    const aspect = canvas.height / canvas.width;
    const baseWidth = 0.6;
    const baseHeight = baseWidth * aspect;
    const geom = new THREE.PlaneGeometry(baseWidth, baseHeight);
    const mat = new THREE.MeshBasicMaterial({
        map: tex,
        transparent: true,
        side: THREE.DoubleSide,
        depthTest: false,
        depthWrite: false
    });
    const mesh = new THREE.Mesh(geom, mat);
    mesh.position.copy(pos);
    
    
    mesh.renderOrder = 9999;
    mesh.userData = mesh.userData || {};
    mesh.userData.aspect = aspect;
    scene.add(mesh);
    return mesh;
}

function initSpeechRecognition() {
    if('webkitSpeechRecognition' in window||'SpeechRecognition' in window) {
        const SR=window.SpeechRecognition||window.webkitSpeechRecognition;
        recognition=new SR();
        recognition.lang='ja-JP';
        recognition.continuous=false;
        recognition.interimResults=false;
    } else {
        document.getElementById('voiceButton').disabled=true;
        document.getElementById('voiceButton').textContent='üé§ ÈùûÂØæÂøú';
    }
}

let currentMemoPosition=null;

function startVoiceInputForMemo(pos) {
    if(!recognition||isRecording)return;
    currentMemoPosition=pos;
    isRecording=true;
    document.getElementById('voiceButton').classList.add('recording');
    document.getElementById('voiceButton').textContent='üé§ Èå≤Èü≥‰∏≠...';
    recognition.onresult=ev=>{
        isRecording = false;
        const transcript=ev.results[0][0].transcript;
        createMemo(currentMemoPosition,transcript);
        document.getElementById('voiceButton').classList.remove('recording');
        document.getElementById('voiceButton').textContent='üé§ Èü≥Â£∞ÂÖ•Âäõ';
    };
    recognition.onerror=(err)=>{
        console.error('recognition error', err);
        isRecording=false;
        document.getElementById('voiceButton').classList.remove('recording');
        document.getElementById('voiceButton').textContent='üé§ Èü≥Â£∞ÂÖ•Âäõ';
    };
    try {
        isRecording = true;
        document.getElementById('status').textContent = 'Èü≥Â£∞Ë™çË≠òÈñãÂßã...';
        recognition.start();
    } catch (e) {
        console.warn('recognition start error', e);
        isRecording = false;
        document.getElementById('voiceButton').classList.remove('recording');
        document.getElementById('voiceButton').textContent='üé§ Èü≥Â£∞ÂÖ•Âäõ';
    }
}

function toggleVoiceInput() {
    if(!recognition)return;
    if(isRecording) {
        try{ recognition.stop(); }catch(e){}
        isRecording=false;
        document.getElementById('voiceButton').classList.remove('recording');
        document.getElementById('voiceButton').textContent='üé§ Èü≥Â£∞ÂÖ•Âäõ';
        return;
    }
    const dir=new THREE.Vector3();
    const dir = new THREE.Vector3();
camera.getWorldDirection(dir);
    const pos=camera.position.clone().add(dir.multiplyScalar(3));
    startVoiceInputForMemo(pos);
}

window.deleteMemo=deleteMemo;

function onWindowResize() {
    camera.aspect=window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth,window.innerHeight);
}

function handleVRControllers(delta) {
    const session=renderer.xr.getSession();
    if(!session) {
        updateVRDebugPanel('No VR session\nFOV: '+zoomLevel.toFixed(1));
        return;
    }
    if(!session.inputSources||session.inputSources.length===0) {
        updateVRDebugPanel('No input sources\nFOV: '+zoomLevel.toFixed(1));
        return;
    }
    let debugInfo=['VR Debug',''];
    debugInfo.push('=== MEMO MODE: ALWAYS ON ===');
    debugInfo.push(`FOV: ${zoomLevel.toFixed(1)} (${MIN_FOV}-${MAX_FOV})`);
    debugInfo.push('');

    for(let i=0;i<session.inputSources.length;i++) {
        const inputSource=session.inputSources[i];
        const gamepad=inputSource.gamepad;
        if(!gamepad) {
            debugInfo.push(`${inputSource.handedness}: No gamepad`);
            continue;
        }

        const axesStr=gamepad.axes.map((v,idx)=>`${idx}:${v.toFixed(2)}`).join(' ');
        debugInfo.push(`${inputSource.handedness}:`);
        debugInfo.push(`  axes: ${axesStr}`);
        const pressedButtons=[];
        for(let btnIdx=0;btnIdx<gamepad.buttons.length;btnIdx++) {
            if(gamepad.buttons[btnIdx].pressed) pressedButtons.push(btnIdx);
        }
        debugInfo.push(`  btns: ${pressedButtons.length>0?pressedButtons.join(','):'none'}`);

        if(inputSource.handedness==='left') {
            let moveX=0,moveZ=0;
            if(Math.abs(gamepad.axes[0])>0.05)moveX=gamepad.axes[0];
            if(Math.abs(gamepad.axes[1])>0.05)moveZ=-gamepad.axes[1];
            if(Math.abs(gamepad.axes[2])>0.05)moveX=gamepad.axes[2];
            if(Math.abs(gamepad.axes[3])>0.05)moveZ=-gamepad.axes[3];
            debugInfo.push(`  moveX:${moveX.toFixed(3)} moveZ:${moveZ.toFixed(3)}`);
            if(Math.abs(moveX)>0.05||Math.abs(moveZ)>0.05) {
                const cameraWorldQuaternion=new THREE.Quaternion();
                camera.getWorldQuaternion(cameraWorldQuaternion);
                const forward=new THREE.Vector3(0,0,-1);
                forward.applyQuaternion(cameraWorldQuaternion);
                forward.y=0;
                forward.normalize();
                const right=new THREE.Vector3(1,0,0);
                right.applyQuaternion(cameraWorldQuaternion);
                right.y=0;
                right.normalize();
                const moveVector=new THREE.Vector3();
                moveVector.add(forward.multiplyScalar(moveZ*VR_MOVE_SPEED*delta));
                moveVector.add(right.multiplyScalar(moveX*VR_MOVE_SPEED*delta));
                cameraRig.position.x+=moveVector.x;
                cameraRig.position.z+=moveVector.z;
                debugInfo.push(`  *** MOVING! ***`);
            }

            const btn4Pressed=gamepad.buttons[4]&&gamepad.buttons[4].pressed;
            if(btn4Pressed) {
                if(!xButtonCooldown) {
                    if(xButtonPressTime===0) {
                        xButtonPressTime=performance.now();
                        debugInfo.push(`  Btn4 START press`);
                    } else {
                        const pressDuration=performance.now()-xButtonPressTime;
                        debugInfo.push(`  Btn4 holding... ${(pressDuration/1000).toFixed(1)}s`);
                        if(pressDuration>500) {
                            vrMemoMode=!vrMemoMode;
                            debugInfo.push(`  *** MEMO MODE: ${vrMemoMode?'ON':'OFF'} ***`);
                            xButtonCooldown=true;
                            xButtonPressTime=0;
                        }
                    }
                } else {
                    debugInfo.push(`  Btn4 (cooldown)`);
                }
            } else {
                xButtonPressTime=0;
                xButtonCooldown=false;
            }

            for(let btnIdx=0;btnIdx<gamepad.buttons.length;btnIdx++) {
                if(gamepad.buttons[btnIdx].pressed&&btnIdx!==4) {
                    if(btnIdx===0) {
                        cameraRig.position.y+=VR_MOVE_SPEED*delta;
                        debugInfo.push(`  UP!`);
                    } else if(btnIdx===1) {
                        cameraRig.position.y-=VR_MOVE_SPEED*delta;
                        if(cameraRig.position.y<0)cameraRig.position.y=0;
                        debugInfo.push(`  DOWN!`);
                    }
                }
            }
        }

        if(inputSource.handedness==='right') {
            const axes=gamepad.axes;
            if(axes.length>=4) {
                const rotX=axes[2]||0;
                const rotY=axes[3]||0;
                if(Math.abs(rotX)>0.1) {
                    cameraRig.rotation.y-=rotX*VR_ROTATION_SPEED*delta;
                    debugInfo.push(`  Rotating Y: ${rotX.toFixed(2)}`);
                }
                if(Math.abs(rotY)>0.1) {
                    camera.rotation.x-=rotY*VR_ROTATION_SPEED*delta;
                    camera.rotation.x=Math.max(-Math.PI/3,Math.min(Math.PI/3,camera.rotation.x));
                    debugInfo.push(`  Rotating X: ${rotY.toFixed(2)}`);
                }
            }

            try {
                const raycaster = new THREE.Raycaster();
                const controllerWorldPos = new THREE.Vector3();
                const controllerWorldQuat = new THREE.Quaternion();
                controllers[1].getWorldPosition(controllerWorldPos);
                controllers[1].getWorldQuaternion(controllerWorldQuat);
                const direction = new THREE.Vector3(0, 0, -1).applyQuaternion(controllerWorldQuat);
                raycaster.set(controllerWorldPos, direction);
                raycaster.near = 0.01;
                raycaster.far = 20;
                const memoObjs = memos.map(m => m.sprite).filter(Boolean);
                const hits = raycaster.intersectObjects(memoObjs, false);
                
                if(hoveredMemo && hoveredMemo.hoverFrame) {
                    scene.remove(hoveredMemo.hoverFrame);
                    delete hoveredMemo.hoverFrame;
                    hoveredMemo = null;
                }
                
                if(hits.length > 0) {
                    const hitObj = hits[0].object;
                    const memo = memos.find(m => m.sprite === hitObj);
                    if(memo && memo !== editingMemo) {
                        hoveredMemo = memo;
                        const hoverFrame = new THREE.Mesh(
                            new THREE.PlaneGeometry(memo.sprite.geometry.parameters.width * 1.1, memo.sprite.geometry.parameters.height * 1.1),
                            new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.3, side: THREE.DoubleSide })
                        );
                        hoverFrame.position.copy(memo.sprite.position);
                        hoverFrame.rotation.copy(memo.sprite.rotation);
                        hoverFrame.position.z -= 0.005;
                        hoverFrame.name = 'hoverFrame';
                        scene.add(hoverFrame);
                        memo.hoverFrame = hoverFrame;
                        debugInfo.push(`  >>> HOVERING MEMO #${memo.id} <<<`);
                    }
                }
            } catch(e) {
                console.error('Hover detection error', e);
            }

            const btn1=gamepad.buttons[1];
            const isBtn1Pressed=btn1&&btn1.pressed;
            if(isBtn1Pressed&&!btn1WasPressed) {
                const confirmPanel = scene.getObjectByName('deleteConfirmPanel');
                if(hoveredMemo && !confirmPanel) {
                    debugInfo.push(`  >>> BTN1: DELETING MEMO #${hoveredMemo.id} <<<`);
                    showVRDeleteConfirm(hoveredMemo);
                }
            }
            btn1WasPressed=isBtn1Pressed;

            const triggerBtn=gamepad.buttons[0];
            const isTriggerPressed=triggerBtn&&triggerBtn.pressed;

            if(isTriggerPressed&&!rightTriggerPressed) {
    rightTriggerPressed=true;
    debugInfo.push(`  Trigger DOWN!`);
    
   if(vrKeyboardMode) {

    const activeControllers = [controllers[1], controllers[0]];

    for(const ctrl of activeControllers) {

        const raycaster = new THREE.Raycaster();
        const controllerWorldPos = new THREE.Vector3();
        const controllerWorldQuat = new THREE.Quaternion();

        ctrl.getWorldPosition(controllerWorldPos);
        ctrl.getWorldQuaternion(controllerWorldQuat);

        const direction = new THREE.Vector3(0, 0, -1).applyQuaternion(controllerWorldQuat);
        raycaster.set(controllerWorldPos, direction);

        if(vrKeyboardPanel) {
            const hits = raycaster.intersectObject(vrKeyboardPanel.children[0], true);
            if(hits.length > 0) {
                const uv = hits[0].uv;
                const x = uv.x * 1024;
                const y = (1 - uv.y) * 512;

                const keys = [
                    ['q','w','e','r','t','y','u','i','o','p'],
                    ['a','s','d','f','g','h','j','k','l'],
                    ['z','x','c','v','b','n','m'],
                    ['-','„ÄÇ','„ÄÅ','ÂâäÈô§','„Çπ„Éö„Éº„Çπ','ÂÆå‰∫Ü']
                ];

                if(y > 170) {
                    const relY = y - 170;
                    const rowIdx = Math.floor(relY / 60);
                    if(rowIdx >= 0 && rowIdx < keys.length) {
                        const row = keys[rowIdx];
                        const rowWidth = row.length * 90 - 10;
                        const startX = (1024 - rowWidth) / 2;
                        const relX = x - startX;
                        const colIdx = Math.floor(relX / 90);
                        if(colIdx >= 0 && colIdx < row.length) {
                            handleVRKeyboardInput(row[colIdx]);
                        }
                    }
                }

                return; // ‚Üê 1ÂõûÂÖ•Âäõ„Åó„Åü„ÇâÁµÇ‰∫Ü
            }
        }
    }
}

        } catch(e) {
            console.error('Keyboard input error', e);
        }
    } else if(hoveredMemo) {
        // „É°„É¢Á∑®ÈõÜÔºàÊó¢Â≠ò„ÅÆ„É°„É¢Ôºâ
        debugInfo.push(`  >>> EDITING MEMO #${hoveredMemo.id} <<<`);
        // Êó¢Â≠ò„É°„É¢„ÅÆÁ∑®ÈõÜ„ÅØ„Ç≠„Éº„Éú„Éº„Éâ„Åß
        vrKeyboardInput = hoveredMemo.text;
        editingMemo = hoveredMemo;
        createVRKeyboard();
    } else {
    // Êñ∞Ë¶è„É°„É¢‰ΩúÊàê
    debugInfo.push(`  >>> CREATING NEW MEMO <<<`);
    const rightController = controllers[1];
    const controllerWorldPos = new THREE.Vector3();
    rightController.getWorldPosition(controllerWorldPos);
    const direction = new THREE.Vector3(0, 0, -1);
    const controllerWorldQuat = new THREE.Quaternion();
    rightController.getWorldQuaternion(controllerWorldQuat);
    direction.applyQuaternion(controllerWorldQuat);
    vrPendingMemoPosition = controllerWorldPos.clone().add(direction.multiplyScalar(2));
    createVRKeyboard();
}
            } else if(!isTriggerPressed&&rightTriggerPressed) {
    rightTriggerPressed=false;
    debugInfo.push(`  Trigger UP!`);
}
        }
        debugInfo.push('');
    }

    debugInfo.push(`CamRig: ${cameraRig.position.x.toFixed(1)}, ${cameraRig.position.y.toFixed(1)}, ${cameraRig.position.z.toFixed(1)}`);
    updateVRDebugPanel(debugInfo.join('\n'));
}
function createVRKeyboard() {
    const keyboardGroup = new THREE.Group();
    keyboardGroup.name = 'vrKeyboard';
    
    const bgCanvas = document.createElement('canvas');
    bgCanvas.width = 1024;
    bgCanvas.height = 512;
    const ctx = bgCanvas.getContext('2d');
    
    // ËÉåÊôØ
    ctx.fillStyle = 'rgba(0,0,0,0.95)';
    ctx.fillRect(0, 0, 1024, 512);
    ctx.strokeStyle = '#00ff00';
    ctx.lineWidth = 4;
    ctx.strokeRect(0, 0, 1024, 512);
    
    // „Çø„Ç§„Éà„É´
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 32px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('„É°„É¢ÂÖ•Âäõ', 512, 50);
    
    // ÂÖ•ÂäõÊ¨Ñ
    ctx.fillStyle = '#333';
    ctx.fillRect(50, 80, 924, 60);
    ctx.strokeStyle = '#00ff00';
    ctx.lineWidth = 2;
    ctx.strokeRect(50, 80, 924, 60);
    
    // ÂÖ•Âäõ„ÉÜ„Ç≠„Çπ„ÉàË°®Á§∫
    ctx.fillStyle = '#fff';
    ctx.font = '28px Arial';
    ctx.textAlign = 'left';
    ctx.fillText(vrKeyboardInput || '„Åì„Åì„Å´ÂÖ•Âäõ...', 70, 120);
    
    // „Ç≠„Éº„Éú„Éº„Éâ„Ç≠„Éº
    const keys = [
    ['q','w','e','r','t','y','u','i','o','p'],
    ['a','s','d','f','g','h','j','k','l'],
    ['z','x','c','v','b','n','m'],
    ['-','„ÄÇ','„ÄÅ','ÂâäÈô§','„Çπ„Éö„Éº„Çπ','ÂÆå‰∫Ü']
];
    
    const keyWidth = 80;
    const keyHeight = 50;
    const startY = 170;
    const gap = 10;
    
    keys.forEach((row, rowIdx) => {
        const rowWidth = row.length * (keyWidth + gap) - gap;
        const startX = (1024 - rowWidth) / 2;
        
        row.forEach((key, colIdx) => {
            const x = startX + colIdx * (keyWidth + gap);
            const y = startY + rowIdx * (keyHeight + gap);
            const w = key === '„Çπ„Éö„Éº„Çπ' ? keyWidth * 2 : keyWidth;
            
            // „Ç≠„ÉºËÉåÊôØ
            ctx.fillStyle = key === 'ÂÆå‰∫Ü' ? '#4CAF50' : key === 'ÂâäÈô§' ? '#f44336' : '#555';
            ctx.fillRect(x, y, w, keyHeight);
            ctx.strokeStyle = '#888';
            ctx.lineWidth = 2;
            ctx.strokeRect(x, y, w, keyHeight);
            
            // „Ç≠„Éº„ÉÜ„Ç≠„Çπ„Éà
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 24px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(key, x + w/2, y + keyHeight/2);
        });
    });
    
    const bgTex = new THREE.CanvasTexture(bgCanvas);
    const bgMesh = new THREE.Mesh(
        new THREE.PlaneGeometry(2.5, 1.25),
        new THREE.MeshBasicMaterial({ map: bgTex, transparent: true, side: THREE.DoubleSide })
    );
    keyboardGroup.add(bgMesh);
    
    const cameraWorldPos = new THREE.Vector3();
    camera.getWorldPosition(cameraWorldPos);
    const cameraWorldDir = new THREE.Vector3();
    camera.getWorldDirection(cameraWorldDir);
    keyboardGroup.position.copy(cameraWorldPos).add(cameraWorldDir.multiplyScalar(2));
    keyboardGroup.lookAt(cameraWorldPos);
    keyboardGroup.renderOrder = 10000;
    
    scene.add(keyboardGroup);
    vrKeyboardPanel = keyboardGroup;
    vrKeyboardMode = true;
}

function updateVRKeyboard() {
    if(!vrKeyboardPanel) return;
    
    const bgMesh = vrKeyboardPanel.children[0];
    const bgCanvas = bgMesh.material.map.image;
    const ctx = bgCanvas.getContext('2d');
    
    // ÂÖ•ÂäõÊ¨Ñ„ÅÆ„ÅøÂÜçÊèèÁîª
    ctx.fillStyle = '#333';
    ctx.fillRect(50, 80, 924, 60);
    ctx.strokeStyle = '#00ff00';
    ctx.lineWidth = 2;
    ctx.strokeRect(50, 80, 924, 60);
    
    ctx.fillStyle = '#fff';
    ctx.font = '28px Arial';
    ctx.textAlign = 'left';
   const displayText = vrKeyboardInput + romajiBuffer;

    ctx.fillText(displayText.substring(Math.max(0, displayText.length - 30)), 70, 120);
    
    bgMesh.material.map.needsUpdate = true;
}

function closeVRKeyboard() {
    if(vrKeyboardPanel) {
        scene.remove(vrKeyboardPanel);
        vrKeyboardPanel = null;
    }
    vrKeyboardMode = false;
    vrKeyboardInput = '';
    romajiBuffer = '';   // ‚Üê „Åì„Çå„Å†„ÅëË∂≥„Åô„Å®ÂÆåÁíß
}
function processRomaji(char) {
  romajiBuffer += char;

  if (romajiBuffer.length >= 2) {
    const last2 = romajiBuffer.slice(-2);
    if (last2[0] === last2[1] && /[bcdfghjklmnpqrstvwxyz]/.test(last2[0])) {
      vrKeyboardInput += '„Å£';
      romajiBuffer = romajiBuffer.slice(-1);
    }
  }

  for (let len = 3; len > 0; len--) {
    const part = romajiBuffer.slice(-len);
    if (ROMAJI_TABLE[part]) {
      vrKeyboardInput += ROMAJI_TABLE[part];
      romajiBuffer = '';
      break;
    }
  }
}

function handleVRKeyboardInput(key) {

  if(key === 'ÂâäÈô§'){
    if(romajiBuffer.length){
      romajiBuffer = romajiBuffer.slice(0, -1);
    } else {
      vrKeyboardInput = vrKeyboardInput.slice(0, -1);
    }
    return updateVRKeyboard();
  }

  if(key === '„Çπ„Éö„Éº„Çπ'){
    vrKeyboardInput += ' ';
    return updateVRKeyboard();
  }

  if(key === 'ÂÆå‰∫Ü'){
    if(vrKeyboardInput.trim() && vrPendingMemoPosition){
      const pos = vrPendingMemoPosition.clone();
      createMemo(pos, vrKeyboardInput);
    }
    romajiBuffer = '';
    vrPendingMemoPosition = null;
    closeVRKeyboard();
    return;
  }

  processRomaji(key.toLowerCase());
  updateVRKeyboard();
}

function startEditMemo(memo) {
    if(isRecording) {
        try {
            recognition.stop();
        } catch(e) {
            console.warn('Failed to stop previous recognition', e);
        }
        isRecording = false;
    }
    if(!recognition) {
        document.getElementById('status').textContent = 'Èü≥Â£∞Ë™çË≠ò„ÅåÂà©Áî®„Åß„Åç„Åæ„Åõ„Çì';
        return;
    }
    
    if(editingMemo && editingMemo.editFrame) {
        scene.remove(editingMemo.editFrame);
        delete editingMemo.editFrame;
    }
    
    editingMemo = memo;
    const frame = new THREE.Mesh(
        new THREE.PlaneGeometry(memo.sprite.geometry.parameters.width * 1.15, memo.sprite.geometry.parameters.height * 1.15),
        new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.4, side: THREE.DoubleSide })
    );
    frame.position.copy(memo.sprite.position);
    frame.rotation.copy(memo.sprite.rotation);
    frame.position.z -= 0.01;
    frame.name = 'editFrame';
    scene.add(frame);
    memo.editFrame = frame;

    const recordingCanvas = document.createElement('canvas');
    recordingCanvas.width = 512;
    recordingCanvas.height = 256;
    
    const recordingTex = new THREE.CanvasTexture(recordingCanvas);
    const recordingMark = new THREE.Mesh(
        new THREE.PlaneGeometry(1.0, 0.5),
        new THREE.MeshBasicMaterial({ map: recordingTex, transparent: true, side: THREE.DoubleSide })
    );
    recordingMark.position.copy(memo.sprite.position);
    recordingMark.rotation.copy(memo.sprite.rotation);
    recordingMark.position.y += 0.5;
    recordingMark.name = 'recordingMark';
    recordingMark.renderOrder = 10000;
    scene.add(recordingMark);
    memo.recordingMark = recordingMark;
    
    navigator.mediaDevices.getUserMedia({ audio: true })
        .then(stream => {
            if(!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            
            const source = audioContext.createMediaStreamSource(stream);
            audioAnalyser = audioContext.createAnalyser();
            audioAnalyser.fftSize = 256;
            source.connect(audioAnalyser);
            
            const bufferLength = audioAnalyser.frequencyBinCount;
            audioDataArray = new Uint8Array(bufferLength);
            
            let animationId;
            function animateEqualizer() {
                if(!audioAnalyser || !editingMemo) {
                    cancelAnimationFrame(animationId);
                    stream.getTracks().forEach(track => track.stop());
                    return;
                }
                
                audioAnalyser.getByteFrequencyData(audioDataArray);
                
                const ctx = recordingCanvas.getContext('2d');
                
                ctx.fillStyle = 'rgba(0,0,0,0.8)';
                ctx.fillRect(0, 0, 512, 256);
                
                ctx.fillStyle = 'rgba(255,0,0,0.9)';
                ctx.beginPath();
                ctx.arc(100, 128, 60, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 60px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('üé§', 100, 128);
                
                const barCount = 8;
                const barWidth = 30;
                const barGap = 10;
                const startX = 220;
                
                audioAnalyser.getByteTimeDomainData(audioDataArray);

                let sum = 0;
                for(let i = 0; i < bufferLength; i++) {
                    const value = audioDataArray[i] - 128;
                    sum += value * value;
                }
                const rms = Math.sqrt(sum / bufferLength);
                const normalizedVolume = rms / 128;

                for(let i = 0; i < barCount; i++) {
                    const randomFactor = 0.7 + Math.random() * 0.3;
                    const height = normalizedVolume * 180 * randomFactor + 20;
                    
                    const x = startX + i * (barWidth + barGap);
                    const y = 128 - height / 2;
                    
                    const gradient = ctx.createLinearGradient(x, y, x, y + height);
                    gradient.addColorStop(0, '#00ff00');
                    gradient.addColorStop(0.5, '#ffff00');
                    gradient.addColorStop(1, '#ff0000');
                    
                    ctx.fillStyle = gradient;
                    ctx.fillRect(x, y, barWidth, height);
                }
                
                recordingTex.needsUpdate = true;
                animationId = requestAnimationFrame(animateEqualizer);
            }
            animateEqualizer();
            
            memo.audioStream = stream;
            memo.animationId = animationId;
        })
        .catch(err => {
            console.error('Microphone access error:', err);
        });

    recognition.onresult = ev => {
        isRecording = false;
        const transcript = ev.results[0][0].transcript;
        
        if(editingMemo.audioStream) {
            editingMemo.audioStream.getTracks().forEach(track => track.stop());
            delete editingMemo.audioStream;
        }
        if(editingMemo.animationId) {
            cancelAnimationFrame(editingMemo.animationId);
            delete editingMemo.animationId;
        }
        
        if(editingMemo.recordingMark) {
            scene.remove(editingMemo.recordingMark);
            delete editingMemo.recordingMark;
        }
        
        if(editingMemo.editFrame) {
            scene.remove(editingMemo.editFrame);
            delete editingMemo.editFrame;
        }
        if (editingMemo.sprite) scene.remove(editingMemo.sprite);
        const newMesh = createMemoSprite(editingMemo.position, transcript);
        editingMemo.sprite = newMesh;
        editingMemo.text = transcript;
        updateMemoList();
        editingMemo = null;
        document.getElementById('status').textContent = '„É°„É¢„ÇíÊõ¥Êñ∞„Åó„Åæ„Åó„Åü';
    };

    recognition.onerror = (e) => {
        console.error('Voice recognition error during edit', e);
        isRecording = false;
        
        if(editingMemo && editingMemo.audioStream) {
            editingMemo.audioStream.getTracks().forEach(track => track.stop());
            delete editingMemo.audioStream;
        }
        if(editingMemo && editingMemo.animationId) {
            cancelAnimationFrame(editingMemo.animationId);
            delete editingMemo.animationId;
        }
        
        if(editingMemo && editingMemo.recordingMark) {
            scene.remove(editingMemo.recordingMark);
            delete editingMemo.recordingMark;
        }
        
        if(editingMemo && editingMemo.editFrame) {
            scene.remove(editingMemo.editFrame);
            delete editingMemo.editFrame;
        }
        editingMemo = null;
        document.getElementById('status').textContent = 'Èü≥Â£∞Ë™çË≠ò„Ç®„É©„Éº';
    };

    recognition.onend = () => {
        console.log('Recognition ended, isRecording:', isRecording);
        
        if(!editingMemo) return;
        
        isRecording = false;
        
        console.log('Recognition ended - cleaning up');
        
        if(editingMemo && editingMemo.audioStream) {
            editingMemo.audioStream.getTracks().forEach(track => track.stop());
            delete editingMemo.audioStream;
        }
        if(editingMemo && editingMemo.animationId) {
            cancelAnimationFrame(editingMemo.animationId);
            delete editingMemo.animationId;
        }
        
        if(editingMemo && editingMemo.recordingMark) {
            scene.remove(editingMemo.recordingMark);
            delete editingMemo.recordingMark;
        }
        
        if(editingMemo && editingMemo.editFrame) {
            scene.remove(editingMemo.editFrame);
            delete editingMemo.editFrame;
        }
        
        editingMemo = null;
        document.getElementById('status').textContent = 'Èü≥Â£∞ÂÖ•Âäõ„Åå„Ç≠„É£„É≥„Çª„É´„Åï„Çå„Åæ„Åó„Åü';
    };

    try {
        isRecording = true;
        document.getElementById('status').textContent = 'Èü≥Â£∞Ë™çË≠òÈñãÂßã...';
        console.log('Recognition started for memo', memo.id);
        recognition.start();
    } catch (e) {
        console.error('recognition.start error', e);
        
        if(memo.audioStream) {
            memo.audioStream.getTracks().forEach(track => track.stop());
        }
        
        if(memo.recordingMark) {
            scene.remove(memo.recordingMark);
            delete memo.recordingMark;
        }
    }
}

function showVRDeleteConfirm(memo) {
    pendingDeleteMemo = memo;
    const confirmPanel = new THREE.Group();
    confirmPanel.name = 'deleteConfirmPanel';
    
    const bgCanvas = document.createElement('canvas');
    bgCanvas.width = 512;
    bgCanvas.height = 256;
    const ctx = bgCanvas.getContext('2d');
    ctx.fillStyle = 'rgba(0,0,0,0.95)';
    ctx.fillRect(0, 0, 512, 256);
    ctx.strokeStyle = '#ff0000';
    ctx.lineWidth = 4;
    ctx.strokeRect(0, 0, 512, 256);
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 32px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('„Åì„ÅÆ„É°„É¢„ÇíÂâäÈô§„Åó„Åæ„Åô„Åã?', 256, 60);
ctx.font = 'bold 24px Arial';
ctx.fillStyle = '#ff0000';
ctx.fillText('A„Éú„Çø„É≥: ÂâäÈô§', 256, 130);
ctx.fillStyle = '#00ff00';
ctx.fillText('B„Éú„Çø„É≥: „Ç≠„É£„É≥„Çª„É´', 256, 170);
    const bgTex = new THREE.CanvasTexture(bgCanvas);
    const bgMesh = new THREE.Mesh(
        new THREE.PlaneGeometry(1.5, 0.75),
        new THREE.MeshBasicMaterial({ map: bgTex, transparent: true, side: THREE.DoubleSide })
    );
    confirmPanel.add(bgMesh);
    
    const cameraWorldPos = new THREE.Vector3();
    camera.getWorldPosition(cameraWorldPos);
    const cameraWorldDir = new THREE.Vector3();
    camera.getWorldDirection(cameraWorldDir);
    confirmPanel.position.copy(cameraWorldPos).add(cameraWorldDir.multiplyScalar(2));
    confirmPanel.lookAt(cameraWorldPos);
    confirmPanel.renderOrder = 10000;
    
    scene.add(confirmPanel);
}

function handleDeleteConfirmInput(session) {
    const panel = scene.getObjectByName('deleteConfirmPanel');
    if(!panel || !pendingDeleteMemo) return;
    
    for(let i = 0; i < session.inputSources.length; i++) {
        const inputSource = session.inputSources[i];
        const gamepad = inputSource.gamepad;
        if(!gamepad) continue;
        
        if(inputSource.handedness === 'right') {
            const aButton = gamepad.buttons[4];
            if(aButton && aButton.pressed) {
                if(pendingDeleteMemo.hoverFrame) {
                    scene.remove(pendingDeleteMemo.hoverFrame);
                    delete pendingDeleteMemo.hoverFrame;
                }
                
                deleteMemo(pendingDeleteMemo.id);
                scene.remove(panel);
                pendingDeleteMemo = null;
                hoveredMemo = null;
                document.getElementById('status').textContent = '„É°„É¢„ÇíÂâäÈô§„Åó„Åæ„Åó„Åü';
                return;
            }
        }
        
        if(inputSource.handedness === 'right') {
            const bButton = gamepad.buttons[5];
            if(bButton && bButton.pressed) {
                scene.remove(panel);
                pendingDeleteMemo = null;
                document.getElementById('status').textContent = 'ÂâäÈô§„Çí„Ç≠„É£„É≥„Çª„É´„Åó„Åæ„Åó„Åü';
                return;
            }
        }
    }
}

function animate() {
    const time=performance.now();
    const delta=(time-prevTime)/1000;
    if(renderer.xr.isPresenting) {
        const session = renderer.xr.getSession();
        if(session) {
            handleDeleteConfirmInput(session);
        }
        handleVRControllers(delta);
    } else {
        velocity.x-=velocity.x*10*delta;
        velocity.z-=velocity.z*10*delta;
        direction.z=Number(moveBackward)-Number(moveForward);
        direction.x=Number(moveLeft)-Number(moveRight);
        direction.normalize();
        if(moveForward||moveBackward)velocity.z-=direction.z*MOVE_SPEED*delta;
        if(moveLeft||moveRight)velocity.x-=direction.x*MOVE_SPEED*delta;
        const forward=new THREE.Vector3(0,0,-1);
        forward.applyQuaternion(camera.quaternion);
        forward.y=0;
        forward.normalize();
        const right=new THREE.Vector3(1,0,0);
        right.applyQuaternion(camera.quaternion);
        right.y=0;
        right.normalize();
        camera.position.add(forward.multiplyScalar(velocity.z*delta));
        camera.position.add(right.multiplyScalar(velocity.x*delta));
        if(camera.position.y<PLAYER_HEIGHT) camera.position.y=PLAYER_HEIGHT;
    }
   


    prevTime=time;
    renderer.render(scene,camera);
}

init();
</script>
</body>
</html>
