<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Model Viewer and VR Walkthrough</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #f0f0f0; font-family: sans-serif; }
        #container { width: 100vw; height: 100vh; }
        #status, #updateDate { 
            position: absolute; top: 10px; left: 10px; padding: 5px 10px; background: rgba(0, 0, 0, 0.7); color: white; border-radius: 5px; font-size: 14px; z-index: 100;
        }
        #updateDate { top: 40px; }
        #info { 
            position: absolute; bottom: 10px; right: 10px; padding: 10px; background: rgba(255, 255, 255, 0.9); border-radius: 5px; z-index: 100; max-width: 300px;
        }
        #info button, #info input { margin: 5px 0; padding: 8px; border: 1px solid #ccc; border-radius: 4px; cursor: pointer; display: block; width: 100%; box-sizing: border-box; }
        #info input[type="file"] { border: none; padding: 0; }
        #scaleControls button { width: 45px; display: inline-block; margin: 2px; }
        #scaleValue { display: block; margin-top: 5px; font-weight: bold; }

        /* VR Mode Indicator */
        #memoModeIndicator {
            position: absolute; top: 10px; right: 10px; padding: 8px 15px; background-color: #f44336; color: white; border-radius: 5px; font-weight: bold; display: none; z-index: 100;
        }

        /* Memo Panel */
        #memoPanel {
            position: absolute; top: 10px; right: 10px; width: 250px; background: rgba(255, 255, 255, 0.9); padding: 10px; border-radius: 5px; z-index: 90; max-height: 80vh; overflow-y: auto; display: none;
        }
        .memo-item {
            border: 1px solid #ccc; padding: 8px; margin-bottom: 5px; border-radius: 4px; font-size: 12px;
        }
        .priority-high { border-left: 5px solid #f44336; }
        .priority-normal { border-left: 5px solid #ffeb3b; }
        .priority-low { border-left: 5px solid #4CAF50; }
        .memo-item button { padding: 4px 8px; font-size: 10px; margin-top: 5px; cursor: pointer; }

        /* Dialogs */
        .dialog-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.5); z-index: 1000; display: none;
            display: flex; justify-content: center; align-items: center;
        }
        .dialog-content {
            background: white; padding: 20px; border-radius: 8px; max-width: 400px; width: 90%; text-align: center;
        }
        .dialog-content textarea { width: 100%; height: 100px; margin-bottom: 10px; padding: 5px; box-sizing: border-box; }
        .dialog-content button { margin: 5px; padding: 10px; width: 45%; }
        
        /* Loading */
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); padding: 20px; background: rgba(0, 0, 0, 0.8); color: white; border-radius: 10px; z-index: 1000; display: none;
        }
        
        /* Voice Button Recording */
        #voiceButton.recording {
            background-color: #f44336;
            color: white;
            animation: pulse 1s infinite;
        }
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(244, 67, 54, 0.4); }
            70% { box-shadow: 0 0 0 10px rgba(244, 67, 54, 0); }
            100% { box-shadow: 0 0 0 0 rgba(244, 67, 54, 0); }
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/OBJLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/FBXLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/STLLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/ColladaLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/PLYLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/webxr/VRButton.js"></script>
</head>
<body>
    <div id="container"></div>

    <div id="status"></div>
    <div id="updateDate"></div>
    <div id="loading" style="display:none;">ãƒ¢ãƒ‡ãƒ«ã‚’èª­ã¿è¾¼ã¿ä¸­...</div>
    <div id="memoModeIndicator">ãƒ¡ãƒ¢ãƒ¢ãƒ¼ãƒ‰ ON</div>

    <div id="info">
        <h3>æ“ä½œãƒ‘ãƒãƒ«</h3>
        <input type="file" id="fileInput" accept=".glb,.gltf,.obj,.fbx,.stl,.dae,.ply">
        <button id="vrButton">VRãƒ¢ãƒ¼ãƒ‰é–‹å§‹</button>
        <button id="memoButton" onclick="toggleMemoMode()">ãƒ¡ãƒ¢ãƒ¢ãƒ¼ãƒ‰ (M)</button>
        
        <h4>ã‚«ãƒ¡ãƒ©/ãƒ¢ãƒ‡ãƒ«æ“ä½œ</h4>
        <button id="resetButton">ã‚«ãƒ¡ãƒ©ãƒªã‚»ãƒƒãƒˆ</button>
        <button id="clearButton">ãƒ¢ãƒ‡ãƒ«/ãƒ¡ãƒ¢å‰Šé™¤</button>

        <div style="margin-top: 10px;">
            <label for="scaleSlider">ãƒ¢ãƒ‡ãƒ«å€ç‡</label>
            <span id="scaleValue">å€ç‡: 1.0x</span>
            <input type="range" id="scaleSlider" min="0.1" max="10" step="0.1" value="1.0">
            <div id="scaleControls">
                <button id="scale05">0.5x</button>
                <button id="scale1">1.0x</button>
                <button id="scale2">2.0x</button>
                <button id="scale5">5.0x</button>
            </div>
        </div>
    </div>

    <div id="memoPanel">
        <h4>ãƒ¡ãƒ¢ä¸€è¦§</h4>
        <div id="memoList">ãƒ¡ãƒ¢ãŒã‚ã‚Šã¾ã›ã‚“ã€‚</div>
    </div>

    <div id="inputMethodDialog" class="dialog-overlay">
        <div class="dialog-content">
            <h4>ãƒ¡ãƒ¢å…¥åŠ›æ–¹æ³•ã‚’é¸æŠ</h4>
            <button id="voiceInputBtn">éŸ³å£°å…¥åŠ›</button>
            <button id="keyboardInputBtn">ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰å…¥åŠ›</button>
        </div>
    </div>

    <div id="memoInputDialog" class="dialog-overlay">
        <div class="dialog-content">
            <h4>ãƒ¡ãƒ¢å†…å®¹å…¥åŠ›</h4>
            <textarea id="memoTextarea" placeholder="ãƒ¡ãƒ¢ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„"></textarea>
            <button id="submitMemoBtn">ç™»éŒ²</button>
            <button id="cancelMemoBtn">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
        </div>
    </div>

    <script>
        // ã“ã“ã«æä¾›ã•ã‚ŒãŸJavaScriptã‚³ãƒ¼ãƒ‰å…¨ä½“ã‚’è²¼ã‚Šä»˜ã‘ã¾ã™
        // ... (ã“ã“ã«å‰å›ã®å›ç­”ã§æä¾›ã•ã‚ŒãŸJavaScriptã‚³ãƒ¼ãƒ‰å…¨æ–‡ã‚’è²¼ã‚Šä»˜ã‘ã‚‹) ...
        
        let scene, camera, renderer;
        let moveForward = false, moveBackward = false;
        let moveLeft = false, moveRight = false;
        let canJump = false;
        let velocity = new THREE.Vector3();
        let direction = new THREE.Vector3();
        let prevTime = performance.now();
        let euler = new THREE.Euler(0, 0, 0, 'YXZ');
        let isMouseDown = false;
        let lastMouseX = 0;
        let lastMouseY = 0;
        let zoomLevel = 75;
        const MIN_FOV = 30;
        const MAX_FOV = 100;
        let modelScale = 1.0;

        const PLAYER_HEIGHT = 1.6;
        const MOVE_SPEED = 80.0;
        const VR_MOVE_SPEED = 5.0;
        const JUMP_VELOCITY = 8.0;
        const GRAVITY = 20.0;

        const statusEl = document.getElementById('status');
        let controllers = [];
        let isVRMode = false;
        const INITIAL_CAMERA_POS = { x: 0, y: PLAYER_HEIGHT, z: 5 };
        const INITIAL_ZOOM = 75;
        let memoMode = false;
        let memos = [];
        let memoCounter = 0;
        let recognition = null;
        let isRecording = false;
        let pendingMemoPosition = null;
        let vrMemoMode = false;
        let xButtonPressTime = 0;
        let sphereMesh; // çƒä½“ã®ãƒ¡ãƒƒã‚·ãƒ¥ã‚’ä¿æŒã™ã‚‹ãŸã‚ã®å¤‰æ•°

        // HTMLã®æ›´æ–°æ—¥æ™‚ï¼ˆæ‰‹å‹•ã§æ›´æ–°ã—ã¦ãã ã•ã„ï¼‰
        const HTML_UPDATE_DATE = '2025/11/05 14:26'; // æ›´æ–°ã—ã¾ã—ãŸ

        function updateStatus(msg) {
            statusEl.textContent = msg;
            console.log(msg);
        }

        function init() {
            updateStatus('åˆæœŸåŒ–ä¸­...');

            // HTMLã®æ›´æ–°æ—¥æ™‚ã‚’è¡¨ç¤º
            document.getElementById('updateDate').textContent = `æ›´æ–°: ${HTML_UPDATE_DATE}`;

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 0, 50);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, PLAYER_HEIGHT, 5);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.xr.enabled = true;
            document.getElementById('container').appendChild(renderer.domElement);

            const vrButton = document.getElementById('vrButton');
            if ('xr' in navigator) {
                navigator.xr.isSessionSupported('immersive-vr').then((supported) => {
                    if (supported) {
                        vrButton.onclick = async () => {
                            if (!renderer.xr.isPresenting) {
                                try {
                                    const session = await navigator.xr.requestSession('immersive-vr', {
                                        optionalFeatures: ['local-floor', 'bounded-floor']
                                    });
                                    await renderer.xr.setSession(session);
                                    isVRMode = true;
                                    document.getElementById('info').style.display = 'none'; // VRé–‹å§‹æ™‚UIéè¡¨ç¤º
                                    document.getElementById('memoPanel').style.display = 'block'; // ãƒ¡ãƒ¢ãƒ‘ãƒãƒ«è¡¨ç¤º
                                    updateStatus('VRãƒ¢ãƒ¼ãƒ‰èµ·å‹•æˆåŠŸ');
                                } catch (error) {
                                    console.error('VRã‚»ãƒƒã‚·ãƒ§ãƒ³é–‹å§‹ã‚¨ãƒ©ãƒ¼:', error);
                                    updateStatus('VRãƒ¢ãƒ¼ãƒ‰èµ·å‹•ã‚¨ãƒ©ãƒ¼: ' + error.message);
                                }
                            }
                        };
                        updateStatus('VRå¯¾å¿œãƒ‡ãƒã‚¤ã‚¹ã‚’æ¤œå‡º');
                    } else {
                        vrButton.disabled = true;
                        vrButton.textContent = 'VRéå¯¾å¿œ';
                        updateStatus('VRéå¯¾å¿œãƒ–ãƒ©ã‚¦ã‚¶');
                    }
                });
            } else {
                vrButton.disabled = true;
                vrButton.textContent = 'VRéå¯¾å¿œ';
            }

            const controller1 = renderer.xr.getController(0);
            controller1.addEventListener('connected', (event) => {
                updateStatus('å·¦ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼æ¥ç¶š: ' + event.data.handedness);
                console.log('Controller 0 connected:', event.data);
            });
            controller1.addEventListener('disconnected', () => {
                updateStatus('å·¦ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼åˆ‡æ–­');
            });
            scene.add(controller1);
            controllers.push(controller1);

            const controller2 = renderer.xr.getController(1);
            controller2.addEventListener('connected', (event) => {
                updateStatus('å³ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼æ¥ç¶š: ' + event.data.handedness);
                console.log('Controller 1 connected:', event.data);
            });
            controller2.addEventListener('disconnected', () => {
                updateStatus('å³ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼åˆ‡æ–­');
            });
            scene.add(controller2);
            controllers.push(controller2);

            // ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã®è¦–è¦šçš„è¡¨ç¾ã‚’è¿½åŠ 
            const controllerModelFactory = new THREE.Group();
            const geometry = new THREE.CylinderGeometry(0.01, 0.02, 0.1, 8);
            const material = new THREE.MeshStandardMaterial({ color: 0xff0000 });
            
            const controller1Grip = renderer.xr.getControllerGrip(0);
            const mesh1 = new THREE.Mesh(geometry, material);
            controller1Grip.add(mesh1);
            scene.add(controller1Grip);

            const controller2Grip = renderer.xr.getControllerGrip(1);
            const mesh2 = new THREE.Mesh(geometry, material.clone());
            mesh2.material.color.set(0x0000ff);
            controller2Grip.add(mesh2);
            scene.add(controller2Grip);
            
            // VRã‚»ãƒƒã‚·ãƒ§ãƒ³çµ‚äº†æ™‚ã®å‡¦ç†ã‚’è¿½åŠ 
            renderer.xr.addEventListener('sessionend', () => {
                isVRMode = false;
                document.getElementById('info').style.display = 'block';
                document.getElementById('memoPanel').style.display = 'none';
                updateStatus('VRãƒ¢ãƒ¼ãƒ‰çµ‚äº†');
            });

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            const floorGeometry = new THREE.PlaneGeometry(50, 50);
            const floorMaterial = new THREE.MeshStandardMaterial({ color: 0x808080 });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);

            // ç›´å¾„1mã®çƒ (ãƒ‡ãƒãƒƒã‚°å¯¾è±¡)
            const sphereGeometry = new THREE.SphereGeometry(0.5, 32, 32);
            const sphereMaterial = new THREE.MeshStandardMaterial({ color: 0x4ecdc4 });
            sphereMesh = new THREE.Mesh(sphereGeometry, sphereMaterial); // å¤‰æ•°ã«ä¿æŒ
            sphereMesh.position.set(0, 0.5, -3);
            sphereMesh.castShadow = true;
            sphereMesh.receiveShadow = true;
            scene.add(sphereMesh);

            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            
            const container = document.getElementById('container');
            container.addEventListener('mousedown', onMouseDown);
            container.addEventListener('mousemove', onMouseMove);
            container.addEventListener('mouseup', onMouseUp);
            container.addEventListener('mouseleave', onMouseUp);
            container.addEventListener('wheel', onMouseWheel);
            
            document.getElementById('fileInput').addEventListener('change', onFileSelect);
            document.getElementById('resetButton').addEventListener('click', resetCamera);
            document.getElementById('clearButton').addEventListener('click', clearModel);
            document.getElementById('scaleSlider').addEventListener('input', onScaleChange);
            document.getElementById('scale05').addEventListener('click', () => setScale(0.5));
            document.getElementById('scale1').addEventListener('click', () => setScale(1.0));
            document.getElementById('scale2').addEventListener('click', () => setScale(2.0));
            document.getElementById('scale5').addEventListener('click', () => setScale(5.0));
            document.getElementById('voiceButton').addEventListener('click', toggleVoiceInput);
            document.getElementById('voiceInputBtn').addEventListener('click', chooseVoiceInput);
            document.getElementById('keyboardInputBtn').addEventListener('click', chooseKeyboardInput);
            document.getElementById('submitMemoBtn').addEventListener('click', submitMemo);
            document.getElementById('cancelMemoBtn').addEventListener('click', cancelMemoInput);
            
            window.addEventListener('resize', onWindowResize);

            initSpeechRecognition();

            updateStatus('æº–å‚™å®Œäº† - GLBãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„');
            renderer.setAnimationLoop(animate);
        }

        function onFileSelect(event) {
            const file = event.target.files[0];
            if (!file) return;

            const fileName = file.name.toLowerCase();
            const fileExtension = fileName.split('.').pop();

            updateStatus(`ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿ä¸­: ${file.name}`);
            document.getElementById('loading').style.display = 'block';

            const reader = new FileReader();
            reader.onload = e => {
                const arrayBuffer = e.target.result;
                
                switch(fileExtension) {
                    case 'glb':
                    case 'gltf':
                        loadGLTF(arrayBuffer);
                        break;
                    case 'obj':
                        loadOBJ(arrayBuffer);
                        break;
                    case 'fbx':
                        loadFBX(arrayBuffer);
                        break;
                    case 'stl':
                        loadSTL(arrayBuffer);
                        break;
                    case 'dae':
                        loadCollada(arrayBuffer);
                        break;
                    case 'ply':
                        loadPLY(arrayBuffer);
                        break;
                    default:
                        updateStatus('å¯¾å¿œã—ã¦ã„ãªã„ãƒ•ã‚¡ã‚¤ãƒ«å½¢å¼ã§ã™');
                        document.getElementById('loading').style.display = 'none';
                }
            };
            reader.readAsArrayBuffer(file);
        }

        function loadGLTF(arrayBuffer) {
            const loader = new THREE.GLTFLoader();
            
            loader.parse(arrayBuffer, '', gltf => {
                addModelToScene(gltf.scene, 'GLTF');
            }, error => {
                console.error('GLTFèª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:', error);
                updateStatus('GLTFèª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼');
                document.getElementById('loading').style.display = 'none';
            });
        }

        function loadOBJ(arrayBuffer) {
            const loader = new THREE.OBJLoader();
            const text = new TextDecoder('utf-8').decode(arrayBuffer);
            
            try {
                const object = loader.parse(text);
                addModelToScene(object, 'OBJ');
            } catch (error) {
                updateStatus('OBJèª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼');
                document.getElementById('loading').style.display = 'none';
            }
        }

        function loadFBX(arrayBuffer) {
            const manager = new THREE.LoadingManager();
            const loader = new THREE.FBXLoader(manager);
            
            try {
                const object = loader.parse(arrayBuffer);
                addModelToScene(object, 'FBX');
            } catch (error) {
                updateStatus('FBXèª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼');
                document.getElementById('loading').style.display = 'none';
            }
        }

        function loadSTL(arrayBuffer) {
            const loader = new THREE.STLLoader();
            
            try {
                const geometry = loader.parse(arrayBuffer);
                const material = new THREE.MeshStandardMaterial({ color: 0xaaaaaa });
                const mesh = new THREE.Mesh(geometry, material);
                addModelToScene(mesh, 'STL');
            } catch (error) {
                updateStatus('STLèª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼');
                document.getElementById('loading').style.display = 'none';
            }
        }

        function loadCollada(arrayBuffer) {
            const loader = new THREE.ColladaLoader();
            const text = new TextDecoder('utf-8').decode(arrayBuffer);
            
            try {
                const collada = loader.parse(text);
                addModelToScene(collada.scene, 'DAE');
            } catch (error) {
                updateStatus('Colladaèª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼');
                document.getElementById('loading').style.display = 'none';
            }
        }

        function loadPLY(arrayBuffer) {
            const loader = new THREE.PLYLoader();
            
            try {
                const geometry = loader.parse(arrayBuffer);
                geometry.computeVertexNormals();
                const material = new THREE.MeshStandardMaterial({ color: 0xaaaaaa });
                const mesh = new THREE.Mesh(geometry, material);
                addModelToScene(mesh, 'PLY');
            } catch (error) {
                updateStatus('PLYèª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼');
                document.getElementById('loading').style.display = 'none';
            }
        }

        function addModelToScene(model, format) {
            const oldModel = scene.getObjectByName('loadedModel');
            if (oldModel) scene.remove(oldModel);

            model.name = 'loadedModel';
            
            model.traverse(node => {
                if (node.isMesh) {
                    node.castShadow = true;
                    node.receiveShadow = true;
                    if (!node.material) {
                        node.material = new THREE.MeshStandardMaterial({ color: 0xaaaaaa });
                    }
                }
            });

            const box = new THREE.Box3().setFromObject(model);
            const center = box.getCenter(new THREE.Vector3());
            const size = box.getSize(new THREE.Vector3());

            model.position.x = -center.x;
            model.position.z = -center.z;
            model.position.y = -box.min.y;

            scene.add(model);
            
            updateStatus(`${format}ãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿å®Œäº†! ã‚µã‚¤ã‚º: ${size.x.toFixed(1)}x${size.y.toFixed(1)}x${size.z.toFixed(1)}`);
            document.getElementById('loading').style.display = 'none';

            camera.position.set(0, PLAYER_HEIGHT, size.z * 0.5 + 3);
        }

        function onKeyDown(event) {
            if (document.getElementById('memoInputDialog').style.display === 'block') return;
            
            switch (event.code) {
                case 'ArrowUp':
                case 'KeyW':
                    moveForward = true;
                    break;
                case 'ArrowDown':
                case 'KeyS':
                    moveBackward = true;
                    break;
                case 'ArrowLeft':
                case 'KeyA':
                    moveLeft = true;
                    break;
                case 'ArrowRight':
                case 'KeyD':
                    moveRight = true;
                    break;
                case 'Space':
                    if (canJump) velocity.y += JUMP_VELOCITY;
                    canJump = false;
                    break;
                case 'KeyQ':
                    zoomIn();
                    break;
                case 'KeyE':
                    zoomOut();
                    break;
                case 'KeyM':
                    toggleMemoMode();
                    break;
            }
        }

        function onKeyUp(event) {
            if (document.getElementById('memoInputDialog').style.display === 'block') return;
            
            switch (event.code) {
                case 'ArrowUp':
                case 'KeyW':
                    moveForward = false;
                    break;
                case 'ArrowDown':
                case 'KeyS':
                    moveBackward = false;
                    break;
                case 'ArrowLeft':
                case 'KeyA':
                    moveLeft = false;
                    break;
                case 'ArrowRight':
                case 'KeyD':
                    moveRight = false;
                    break;
            }
        }

        function onMouseDown(event) {
            if (document.getElementById('inputMethodDialog').style.display === 'block' || 
                document.getElementById('memoInputDialog').style.display === 'block') {
                return;
            }

            if (memoMode && event.button === 0) {
                placeMemo(event);
                return;
            }
            isMouseDown = true;
            lastMouseX = event.clientX;
            lastMouseY = event.clientY;
        }

        function onMouseUp() {
            isMouseDown = false;
        }

        function onMouseMove(event) {
            if (!isMouseDown) return;

            const deltaX = event.clientX - lastMouseX;
            const deltaY = event.clientY - lastMouseY;

            lastMouseX = event.clientX;
            lastMouseY = event.clientY;

            euler.setFromQuaternion(camera.quaternion);
            euler.y -= deltaX * 0.002;
            euler.x -= deltaY * 0.002;
            // ä¸Šä¸‹æ–¹å‘ã®å›è»¢ã‚’åˆ¶é™
            euler.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, euler.x));

            camera.quaternion.setFromEuler(euler);
        }

        function onMouseWheel(event) {
            event.preventDefault();
            if (event.deltaY > 0) {
                zoomOut();
            } else {
                zoomIn();
            }
        }

        function zoomIn() {
            zoomLevel = Math.max(MIN_FOV, zoomLevel - 5);
            camera.fov = zoomLevel;
            camera.updateProjectionMatrix();
        }

        function zoomOut() {
            zoomLevel = Math.min(MAX_FOV, zoomLevel + 5);
            camera.fov = zoomLevel;
            camera.updateProjectionMatrix();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function resetCamera() {
            camera.position.set(INITIAL_CAMERA_POS.x, INITIAL_CAMERA_POS.y, INITIAL_CAMERA_POS.z);
            camera.rotation.set(0, 0, 0);
            camera.fov = INITIAL_ZOOM;
            camera.updateProjectionMatrix();
            zoomLevel = INITIAL_ZOOM;
            updateStatus('ã‚«ãƒ¡ãƒ©ä½ç½®ã‚’ãƒªã‚»ãƒƒãƒˆã—ã¾ã—ãŸ');
        }

        function clearModel() {
            const model = scene.getObjectByName('loadedModel');
            if (model) {
                scene.remove(model);
                updateStatus('3Dãƒ¢ãƒ‡ãƒ«ã‚’å‰Šé™¤ã—ã¾ã—ãŸ');
            } else {
                updateStatus('å‰Šé™¤ã™ã‚‹ãƒ¢ãƒ‡ãƒ«ãŒã‚ã‚Šã¾ã›ã‚“');
            }
            memos.forEach(memo => scene.remove(memo.mesh));
            memos = [];
            document.getElementById('memoList').innerHTML = '';
        }

        function onScaleChange(event) {
            setScale(parseFloat(event.target.value));
        }

        function setScale(scale) {
            modelScale = scale;
            document.getElementById('scaleValue').textContent = `å€ç‡: ${modelScale.toFixed(1)}x`;
            document.getElementById('scaleSlider').value = modelScale;

            const model = scene.getObjectByName('loadedModel');
            if (model) {
                model.scale.set(modelScale, modelScale, modelScale);
            }
        }

        function animate(time) {
            const delta = (time - prevTime) / 1000;
            prevTime = time;

            if (isVRMode) {
                handleVRMovement(delta);
                handleVRInputs();
            }
            
            // VRãƒ¢ãƒ¼ãƒ‰ã‹ã©ã†ã‹ã«é–¢ã‚ã‚‰ãšPC/ãƒ–ãƒ©ã‚¦ã‚¶æ“ä½œã‚’å‡¦ç†
            handlePCMovement(delta);
            
            renderer.render(scene, camera);
        }

        function handlePCMovement(delta) {
            // ----------------------------------------------------
            // ğŸ› ï¸ ä¿®æ­£ç‚¹ 2: ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼å…¥åŠ›ã‚’PCãƒ¢ãƒ¼ãƒ‰ã®ãƒ•ãƒ©ã‚°ã«åæ˜ 
            // ----------------------------------------------------
            
            // ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã®çŠ¶æ…‹ã¯ onKeyDown/onKeyUp ã§è¨­å®šã•ã‚ŒãŸçŠ¶æ…‹ã‚’ä¿æŒã€‚
            // ã“ã“ã§ã¯ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã®çŠ¶æ…‹ã‚’èª­ã¿å–ã‚Šã€ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã¨çµ„ã¿åˆã‚ã›ã‚‹ã€‚
            
            let controllerMoveForward = false;
            let controllerMoveBackward = false;
            let controllerMoveLeft = false;
            let controllerMoveRight = false;

            const speed = MOVE_SPEED;

            // Gamepad APIã‹ã‚‰ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã®çŠ¶æ…‹ã‚’å–å¾—
            for (const controller of controllers) {
                if (controller && controller.userData.gamepad) {
                    const gamepad = controller.userData.gamepad;
                    
                    // Meta Questã§ä¸€èˆ¬çš„ãªå·¦ã‚¹ãƒ†ã‚£ãƒƒã‚¯ã®è»¸ [0] (X) ã¨ [1] (Y) ã‚’ä½¿ç”¨
                    const axisX = gamepad.axes[0] || gamepad.axes[2];
                    const axisY = gamepad.axes[1] || gamepad.axes[3];
                    
                    const threshold = 0.15; // ã‚¹ãƒ†ã‚£ãƒƒã‚¯ã®éŠã³ã‚’ç„¡è¦–ã™ã‚‹é–¾å€¤

                    if (Math.abs(axisY) > threshold) {
                        if (axisY < 0) controllerMoveForward = true; 
                        if (axisY > 0) controllerMoveBackward = true; 
                    }
                    if (Math.abs(axisX) > threshold) {
                        if (axisX < 0) controllerMoveLeft = true; 
                        if (axisX > 0) controllerMoveRight = true; 
                    }
                    
                    // ã‚ºãƒ¼ãƒ ã‚¤ãƒ³/ã‚¢ã‚¦ãƒˆ (å³ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã®ãƒˆãƒªã‚¬ãƒ¼/ã‚°ãƒªãƒƒãƒ—)
                    if (controller === controllers[1]) {
                        // å³ãƒˆãƒªã‚¬ãƒ¼ (buttons[1]) ã§ã‚ºãƒ¼ãƒ ã‚¤ãƒ³ã‚’æƒ³å®š
                        if (gamepad.buttons[1] && gamepad.buttons[1].pressed) {
                            zoomIn();
                        }
                        // å³ã‚°ãƒªãƒƒãƒ— (buttons[2]ã¾ãŸã¯buttons[3]ã‚’è©¦ã™) ã§ã‚ºãƒ¼ãƒ ã‚¢ã‚¦ãƒˆã‚’æƒ³å®š
                        if (gamepad.buttons[2] && gamepad.buttons[2].pressed) {
                            zoomOut();
                        }
                    }
                }
            }
            
            // ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã¨ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã®å…¥åŠ›ã‚’ORã§çµåˆ
            const finalMoveForward = moveForward || controllerMoveForward;
            const finalMoveBackward = moveBackward || controllerMoveBackward;
            const finalMoveLeft = moveLeft || controllerMoveLeft;
            const finalMoveRight = moveRight || controllerMoveRight;


            // ----------------------------------------------------
            // æ—¢å­˜ã®PCç§»å‹•ãƒ­ã‚¸ãƒƒã‚¯
            // ----------------------------------------------------
            
            // PC/ãƒ–ãƒ©ã‚¦ã‚¶ãƒ¢ãƒ¼ãƒ‰æ™‚ã®é‡åŠ›ã¨åºŠåˆ¤å®š
            velocity.y -= GRAVITY * delta;
            
            // ç§»å‹• (çµåˆã•ã‚ŒãŸ moveXxx ãƒ•ãƒ©ã‚°ã‚’ä½¿ç”¨)
            direction.z = Number(finalMoveForward) - Number(finalMoveBackward);
            direction.x = Number(finalMoveRight) - Number(finalMoveLeft);
            direction.normalize(); 

            if (finalMoveForward || finalMoveBackward) velocity.z -= direction.z * speed * delta;
            if (finalMoveLeft || finalMoveRight) velocity.x -= direction.x * speed * delta;

            // æ‘©æ“¦ã¨æ¸›é€Ÿ
            velocity.x *= (1 - 0.1 * delta * 5);
            velocity.z *= (1 - 0.1 * delta * 5);
            
            // ã‚«ãƒ¡ãƒ©ã®ç¾åœ¨ã®æ–¹å‘ã‚’è€ƒæ…®ã—ã¦ç§»å‹•ãƒ™ã‚¯ãƒˆãƒ«ã‚’å›è»¢
            const cameraDirection = new THREE.Vector3();
            camera.getWorldDirection(cameraDirection);
            cameraDirection.y = 0; // æ°´å¹³æ–¹å‘ã®ã¿
            cameraDirection.normalize();

            const rightVector = new THREE.Vector3().crossVectors(cameraDirection, new THREE.Vector3(0, 1, 0)).normalize();

            // ç§»å‹•é€Ÿåº¦ã‚’ã‚«ãƒ¡ãƒ©ã®å‘ãã«åˆã‚ã›ã¦é©ç”¨
            if (finalMoveForward || finalMoveBackward) {
                camera.position.addScaledVector(cameraDirection, velocity.z * delta);
            }
            if (finalMoveLeft || finalMoveRight) {
                camera.position.addScaledVector(rightVector, velocity.x * delta);
            }

            camera.position.y += velocity.y * delta;

            if (camera.position.y < PLAYER_HEIGHT) {
                velocity.y = 0;
                camera.position.y = PLAYER_HEIGHT;
                canJump = true;
            }

            // é€Ÿåº¦ã‚’æ¸›è¡°ã•ã›ã‚‹
            velocity.x -= velocity.x * 10.0 * delta;
            velocity.z -= velocity.z * 10.0 * delta;
            
            // âš ï¸ é‡è¦ãªãƒ‡ãƒãƒƒã‚°: Aãƒœã‚¿ãƒ³ã®åå¿œã‚’ãƒ–ãƒ©ã‚¦ã‚¶ãƒ¢ãƒ¼ãƒ‰ã§ã‚‚ãƒã‚§ãƒƒã‚¯
            if (controllers[1] && controllers[1].userData.gamepad) {
                const gamepad2 = controllers[1].userData.gamepad;
                // Aãƒœã‚¿ãƒ³ã¯é€šå¸¸ gamepad.buttons[4]
                const aButtonPressed = gamepad2.buttons[4] && gamepad2.buttons[4].pressed;
                
                if (aButtonPressed) {
                    if (sphereMesh && sphereMesh.material.color.getHex() !== 0xff0000) {
                        sphereMesh.material.color.set(0xff0000);
                    }
                } else {
                    if (sphereMesh && sphereMesh.material.color.getHex() !== 0x4ecdc4) {
                        sphereMesh.material.color.set(0x4ecdc4);
                    }
                }
            }
        }

        function handleVRMovement(delta) {
            // VRãƒ¢ãƒ¼ãƒ‰å°‚ç”¨ã®ãƒ­ã‚¸ãƒƒã‚¯
            
            let controllerToUse;
            
            if (controllers[0] && controllers[0].userData.gamepad) {
                controllerToUse = controllers[0];
            } else if (controllers[1] && controllers[1].userData.gamepad) {
                controllerToUse = controllers[1]; 
            }

            if (controllerToUse) {
                const gamepad = controllerToUse.userData.gamepad;
                
                // Questã®å·¦ã‚¹ãƒ†ã‚£ãƒƒã‚¯ã®è»¸ [0] (X) ã¨ [1] (Y) ã‚’ä½¿ç”¨
                const axisX = gamepad.axes[0] || gamepad.axes[2];
                const axisY = gamepad.axes[1] || gamepad.axes[3]; 
                
                const speed = VR_MOVE_SPEED;
                const moveVector = new THREE.Vector3();
                const threshold = 0.15;

                if (Math.abs(axisY) > threshold) {
                    moveVector.z = -axisY * speed * delta;
                }
                
                if (Math.abs(axisX) > threshold) {
                    moveVector.x = axisX * speed * delta;
                }

                if (moveVector.length() > 0) {
                    
                    // è¦–ç·šæ–¹å‘ã‚’å–å¾—ï¼ˆæ°´å¹³æ–¹å‘ã®ã¿ï¼‰
                    const rotationMatrix = new THREE.Matrix4();
                    rotationMatrix.extractRotation(controllerToUse.matrixWorld);
                    
                    const worldForward = new THREE.Vector3(0, 0, -1).applyMatrix4(rotationMatrix);
                    worldForward.y = 0; 
                    worldForward.normalize();
                    
                    const worldRight = new THREE.Vector3(1, 0, 0).applyMatrix4(rotationMatrix);
                    worldRight.y = 0; 
                    worldRight.normalize();

                    // å‰å¾Œç§»å‹•
                    camera.position.addScaledVector(worldForward, moveVector.z * 10); 
                    // å·¦å³ç§»å‹•
                    camera.position.addScaledVector(worldRight, moveVector.x * 10);
                }

                // ä¸Šæ˜‡/ä¸‹é™ (å³ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã®A/Bãƒœã‚¿ãƒ³)
                if (controllers[1] && controllers[1].userData.gamepad) {
                    const gamepad2 = controllers[1].userData.gamepad;
                    
                    // ä¸Šæ˜‡ (Aãƒœã‚¿ãƒ³: buttons[4])
                    if (gamepad2.buttons[4] && gamepad2.buttons[4].pressed) {
                        camera.position.y += speed * delta;
                    } 
                    
                    // ä¸‹é™ (Bãƒœã‚¿ãƒ³: buttons[5])
                    if (gamepad2.buttons[5] && gamepad2.buttons[5].pressed) {
                        camera.position.y -= speed * delta;
                    } 
                }

                if (camera.position.y < PLAYER_HEIGHT) {
                    camera.position.y = PLAYER_HEIGHT;
                }
            }
        }

        function handleVRInputs() {
            // VRãƒ¢ãƒ¼ãƒ‰å°‚ç”¨ã®å…¥åŠ›å‡¦ç†ï¼ˆãƒ¡ãƒ¢ãƒ¢ãƒ¼ãƒ‰åˆ‡æ›¿ã€ãƒ¡ãƒ¢é…ç½®ãªã©ï¼‰
            const controller2 = controllers[1]; // å³
            
            if (controller2 && controller2.userData.gamepad) {
                const gamepad2 = controller2.userData.gamepad;
                
                // VRãƒ¡ãƒ¢ãƒ¢ãƒ¼ãƒ‰ã®åˆ‡ã‚Šæ›¿ãˆ (Xãƒœã‚¿ãƒ³é•·æŠ¼ã—) - Xãƒœã‚¿ãƒ³ã¯é€šå¸¸ gamepad.buttons[2]
                const xButtonPressed = gamepad2.buttons[2] && gamepad2.buttons[2].pressed;

                if (xButtonPressed) {
                    if (xButtonPressTime === 0) {
                        xButtonPressTime = performance.now();
                    } else if (performance.now() - xButtonPressTime > 1000) { // 1ç§’é•·æŠ¼ã—
                        if (!vrMemoMode) {
                            toggleMemoMode();
                            vrMemoMode = true;
                        }
                    }
                } else {
                    xButtonPressTime = 0;
                }
                
                // ãƒ¡ãƒ¢é…ç½® (ãƒ¡ãƒ¢ãƒ¢ãƒ¼ãƒ‰ä¸­ã€å³ãƒˆãƒªã‚¬ãƒ¼) - å³ãƒˆãƒªã‚¬ãƒ¼ã¯é€šå¸¸ gamepad.buttons[1]
                const rightTriggerPressed = gamepad2.buttons[1] && gamepad2.buttons[1].pressed;
                if (vrMemoMode && memoMode && rightTriggerPressed && !controller2.userData.memoPlaced) {
                    placeVRMemo(controller2);
                    controller2.userData.memoPlaced = true;
                } else if (!rightTriggerPressed) {
                    controller2.userData.memoPlaced = false;
                }
            }
        }

        function placeVRMemo(controller) {
            const raycaster = new THREE.Raycaster();
            const tempMatrix = new THREE.Matrix4();
            tempMatrix.identity().extractRotation(controller.matrixWorld);

            raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
            raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix); // ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã®å…ˆç«¯æ–¹å‘

            const intersects = raycaster.intersectObjects(scene.children, true);

            if (intersects.length > 0) {
                pendingMemoPosition = intersects[0].point;
                updateStatus(`ãƒ¡ãƒ¢é…ç½®ä½ç½®æ±ºå®š: (${pendingMemoPosition.x.toFixed(2)}, ${pendingMemoPosition.y.toFixed(2)}, ${pendingMemoPosition.z.toFixed(2)})`);
                
                // å…¥åŠ›æ–¹æ³•ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã‚’è¡¨ç¤º
                document.getElementById('inputMethodDialog').style.display = 'block';
            } else {
                updateStatus('ãƒ¢ãƒ‡ãƒ«/åºŠã«ãƒ’ãƒƒãƒˆã—ã¾ã›ã‚“ã§ã—ãŸ');
            }
        }

        function toggleMemoMode() {
            memoMode = !memoMode;
            document.getElementById('memoModeIndicator').style.display = memoMode ? 'block' : 'none';
            document.getElementById('memoPanel').style.display = memoMode ? 'block' : 'none';
            updateStatus(`ãƒ¡ãƒ¢ãƒ¢ãƒ¼ãƒ‰: ${memoMode ? 'ON' : 'OFF'}`);
            
            if (memoMode && isVRMode) {
                vrMemoMode = true; // VRãƒ¢ãƒ¼ãƒ‰ã§Mã‚­ãƒ¼ã‚’æŠ¼ã—ãŸã‚‰vrMemoModeã‚‚ON
            } else if (!memoMode) {
                vrMemoMode = false; // ãƒ¡ãƒ¢ãƒ¢ãƒ¼ãƒ‰OFFã§vrMemoModeã‚‚OFF
            }
        }

        function placeMemo(event) {
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            const intersects = raycaster.intersectObjects(scene.children, true);

            if (intersects.length > 0) {
                pendingMemoPosition = intersects[0].point;
                updateStatus(`ãƒ¡ãƒ¢é…ç½®ä½ç½®æ±ºå®š: (${pendingMemoPosition.x.toFixed(2)}, ${pendingMemoPosition.y.toFixed(2)}, ${pendingMemoPosition.z.toFixed(2)})`);
                
                // å…¥åŠ›æ–¹æ³•ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã‚’è¡¨ç¤º
                document.getElementById('inputMethodDialog').style.display = 'block';
            } else {
                updateStatus('ãƒ¢ãƒ‡ãƒ«/åºŠã«ãƒ’ãƒƒãƒˆã—ã¾ã›ã‚“ã§ã—ãŸ');
            }
        }

        function createMemoMesh(position, text, priority) {
            const geometry = new THREE.SphereGeometry(0.1, 16, 16);
            let color;
            switch(priority) {
                case 'high':
                    color = 0xf44336; // Red
                    break;
                case 'normal':
                    color = 0xffeb3b; // Yellow
                    break;
                case 'low':
                default:
                    color = 0x4CAF50; // Green
                    break;
            }
            const material = new THREE.MeshBasicMaterial({ color: color });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.copy(position);
            mesh.userData.memoId = memoCounter++;

            scene.add(mesh);

            memos.push({
                id: mesh.userData.memoId,
                text: text,
                position: position,
                mesh: mesh,
                priority: priority
            });

            updateMemoList();
        }

        function updateMemoList() {
            const listEl = document.getElementById('memoList');
            listEl.innerHTML = '';
            
            memos.forEach(memo => {
                const item = document.createElement('div');
                item.className = `memo-item priority-${memo.priority}`;
                item.innerHTML = `
                    <strong>ãƒ¡ãƒ¢ #${memo.id} (${memo.priority.toUpperCase()})</strong><br>
                    ä½ç½®: (${memo.position.x.toFixed(1)}, ${memo.position.y.toFixed(1)}, ${memo.position.z.toFixed(1)})<br>
                    å†…å®¹: ${memo.text}<br>
                    <button onclick="removeMemo(${memo.id})">å‰Šé™¤</button>
                `;
                listEl.appendChild(item);
            });
        }

        window.removeMemo = function(id) {
            const index = memos.findIndex(memo => memo.id === id);
            if (index !== -1) {
                scene.remove(memos[index].mesh);
                memos.splice(index, 1);
                updateMemoList();
                updateStatus(`ãƒ¡ãƒ¢ #${id} ã‚’å‰Šé™¤ã—ã¾ã—ãŸ`);
            }
        }

        function initSpeechRecognition() {
            window.SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            if (window.SpeechRecognition) {
                recognition = new SpeechRecognition();
                recognition.lang = 'ja-JP';
                recognition.interimResults = false;
                recognition.maxAlternatives = 1;

                recognition.onresult = (event) => {
                    const transcript = event.results[0][0].transcript;
                    document.getElementById('memoTextarea').value = transcript;
                    updateStatus('éŸ³å£°èªè­˜å®Œäº†');
                    document.getElementById('voiceButton').classList.remove('recording');
                    document.getElementById('memoInputDialog').style.display = 'block';
                    isRecording = false;
                };

                recognition.onerror = (event) => {
                    updateStatus('éŸ³å£°èªè­˜ã‚¨ãƒ©ãƒ¼: ' + event.error);
                    document.getElementById('voiceButton').classList.remove('recording');
                    document.getElementById('memoInputDialog').style.display = 'block'; // ã‚¨ãƒ©ãƒ¼æ™‚ã‚‚æ‰‹å‹•å…¥åŠ›ã«åˆ‡ã‚Šæ›¿ãˆ
                    isRecording = false;
                };

                recognition.onend = () => {
                    if (isRecording) {
                        document.getElementById('voiceButton').classList.remove('recording');
                        isRecording = false;
                    }
                };
            } else {
                document.getElementById('voiceButton').disabled = true;
                document.getElementById('voiceButton').textContent = 'éŸ³å£°å…¥åŠ›éå¯¾å¿œ';
                document.getElementById('voiceInputBtn').disabled = true;
            }
        }

        function toggleVoiceInput() {
            if (!pendingMemoPosition) {
                updateStatus('ãƒ¡ãƒ¢ã‚’é…ç½®ã™ã‚‹å ´æ‰€ã‚’å…ˆã«ã‚¯ãƒªãƒƒã‚¯ã—ã¦ãã ã•ã„');
                return;
            }
            document.getElementById('inputMethodDialog').style.display = 'block';
        }

        function chooseVoiceInput() {
            document.getElementById('inputMethodDialog').style.display = 'none';
            
            if (recognition && !isRecording) {
                document.getElementById('memoTextarea').value = 'éŒ²éŸ³ä¸­...';
                document.getElementById('memoInputDialog').style.display = 'block'; // éŒ²éŸ³çŠ¶æ…‹ã‚’è¡¨ç¤º
                document.getElementById('voiceButton').classList.add('recording');
                
                // éŒ²éŸ³é–‹å§‹
                try {
                    recognition.start();
                    isRecording = true;
                    updateStatus('éŸ³å£°éŒ²éŸ³é–‹å§‹...è©±ã—ã¦ãã ã•ã„');
                } catch (e) {
                    updateStatus('éŒ²éŸ³é–‹å§‹ã‚¨ãƒ©ãƒ¼: ' + e.message);
                    document.getElementById('memoInputDialog').style.display = 'none';
                    document.getElementById('voiceButton').classList.remove('recording');
                    isRecording = false;
                }
            } else {
                chooseKeyboardInput(); // éŸ³å£°å…¥åŠ›ãŒä½¿ãˆãªã„å ´åˆã¯ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã«åˆ‡ã‚Šæ›¿ãˆ
            }
        }

        function chooseKeyboardInput() {
            document.getElementById('inputMethodDialog').style.display = 'none';
            document.getElementById('memoTextarea').value = '';
            document.getElementById('memoInputDialog').style.display = 'block';
        }

        function submitMemo() {
            const text = document.getElementById('memoTextarea').value.trim();
            if (text && pendingMemoPosition) {
                // ç°¡æ˜“çš„ã«å„ªå…ˆåº¦ã‚’åˆ¤å®šï¼ˆä¾‹: ã€Œé‡è¦ã€ãŒå«ã¾ã‚Œã¦ã„ãŸã‚‰é«˜ï¼‰
                let priority = 'low';
                if (text.includes('é‡è¦') || text.includes('è¦ç¢ºèª')) {
                    priority = 'high';
                } else if (text.length > 50) { // é•·ã„ãƒ¡ãƒ¢ã¯normal
                    priority = 'normal';
                }
                
                createMemoMesh(pendingMemoPosition, text, priority);
                updateStatus(`ãƒ¡ãƒ¢ã‚’ä½œæˆã—ã¾ã—ãŸ: ${text.substring(0, 15)}...`);
                
                // ãƒªã‚»ãƒƒãƒˆ
                pendingMemoPosition = null;
                document.getElementById('memoInputDialog').style.display = 'none';
                document.getElementById('memoTextarea').value = '';
            } else {
                updateStatus('ãƒ¡ãƒ¢ã®å†…å®¹ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
            }
        }

        function cancelMemoInput() {
            document.getElementById('memoInputDialog').style.display = 'none';
            document.getElementById('memoTextarea').value = '';
            pendingMemoPosition = null;
            if (isRecording) {
                recognition.stop();
                isRecording = false;
            }
            updateStatus('ãƒ¡ãƒ¢ä½œæˆã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã—ã¾ã—ãŸ');
        }

        init();
        
    </script>
</body>
</html>
