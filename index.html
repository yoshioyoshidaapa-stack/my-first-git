let scene, camera, renderer;
let moveForward = false, moveBackward = false;
let moveLeft = false, moveRight = false;
let canJump = false;
let velocity = new THREE.Vector3();
let direction = new THREE.Vector3();
let prevTime = performance.now();
let euler = new THREE.Euler(0, 0, 0, 'YXZ');
let isMouseDown = false;
let lastMouseX = 0;
let lastMouseY = 0;
let zoomLevel = 75;
const MIN_FOV = 30;
const MAX_FOV = 100;
let modelScale = 1.0;

const PLAYER_HEIGHT = 1.6;
const MOVE_SPEED = 80.0;
const VR_MOVE_SPEED = 5.0;
const JUMP_VELOCITY = 8.0;
const GRAVITY = 20.0;

const statusEl = document.getElementById('status');
let controllers = [];
let isVRMode = false;
const INITIAL_CAMERA_POS = { x: 0, y: PLAYER_HEIGHT, z: 5 };
const INITIAL_ZOOM = 75;
let memoMode = false;
let memos = [];
let memoCounter = 0;
let recognition = null;
let isRecording = false;
let pendingMemoPosition = null;
let vrMemoMode = false;
let xButtonPressTime = 0;
let sphereMesh; // çƒä½“ã®ãƒ¡ãƒƒã‚·ãƒ¥ã‚’ä¿æŒã™ã‚‹ãŸã‚ã®å¤‰æ•°

// HTMLã®æ›´æ–°æ—¥æ™‚ï¼ˆæ‰‹å‹•ã§æ›´æ–°ã—ã¦ãã ã•ã„ï¼‰
const HTML_UPDATE_DATE = '2025/11/05 14:21'; // æ›´æ–°ã—ã¾ã—ãŸ

function updateStatus(msg) {
    statusEl.textContent = msg;
    console.log(msg);
}

function init() {
    updateStatus('åˆæœŸåŒ–ä¸­...');

    // HTMLã®æ›´æ–°æ—¥æ™‚ã‚’è¡¨ç¤º
    document.getElementById('updateDate').textContent = `æ›´æ–°: ${HTML_UPDATE_DATE}`;

    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87CEEB);
    scene.fog = new THREE.Fog(0x87CEEB, 0, 50);

    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, PLAYER_HEIGHT, 5);

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.xr.enabled = true;
    document.getElementById('container').appendChild(renderer.domElement);

    const vrButton = document.getElementById('vrButton');
    if ('xr' in navigator) {
        navigator.xr.isSessionSupported('immersive-vr').then((supported) => {
            if (supported) {
                vrButton.onclick = async () => {
                    if (!renderer.xr.isPresenting) {
                        try {
                            const session = await navigator.xr.requestSession('immersive-vr', {
                                optionalFeatures: ['local-floor', 'bounded-floor']
                            });
                            await renderer.xr.setSession(session);
                            isVRMode = true;
                            document.getElementById('info').style.display = 'none'; // VRé–‹å§‹æ™‚UIéè¡¨ç¤º
                            document.getElementById('memoPanel').style.display = 'block'; // ãƒ¡ãƒ¢ãƒ‘ãƒãƒ«è¡¨ç¤º
                            updateStatus('VRãƒ¢ãƒ¼ãƒ‰èµ·å‹•æˆåŠŸ');
                        } catch (error) {
                            console.error('VRã‚»ãƒƒã‚·ãƒ§ãƒ³é–‹å§‹ã‚¨ãƒ©ãƒ¼:', error);
                            updateStatus('VRãƒ¢ãƒ¼ãƒ‰èµ·å‹•ã‚¨ãƒ©ãƒ¼: ' + error.message);
                        }
                    }
                };
                updateStatus('VRå¯¾å¿œãƒ‡ãƒã‚¤ã‚¹ã‚’æ¤œå‡º');
            } else {
                vrButton.disabled = true;
                vrButton.textContent = 'VRéå¯¾å¿œ';
                updateStatus('VRéå¯¾å¿œãƒ–ãƒ©ã‚¦ã‚¶');
            }
        });
    } else {
        vrButton.disabled = true;
        vrButton.textContent = 'VRéå¯¾å¿œ';
    }

    const controller1 = renderer.xr.getController(0);
    controller1.addEventListener('connected', (event) => {
        updateStatus('å·¦ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼æ¥ç¶š: ' + event.data.handedness);
        console.log('Controller 0 connected:', event.data);
    });
    controller1.addEventListener('disconnected', () => {
        updateStatus('å·¦ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼åˆ‡æ–­');
    });
    scene.add(controller1);
    controllers.push(controller1);

    const controller2 = renderer.xr.getController(1);
    controller2.addEventListener('connected', (event) => {
        updateStatus('å³ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼æ¥ç¶š: ' + event.data.handedness);
        console.log('Controller 1 connected:', event.data);
    });
    controller2.addEventListener('disconnected', () => {
        updateStatus('å³ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼åˆ‡æ–­');
    });
    scene.add(controller2);
    controllers.push(controller2);

    // ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã®è¦–è¦šçš„è¡¨ç¾ã‚’è¿½åŠ 
    const controllerModelFactory = new THREE.Group();
    const geometry = new THREE.CylinderGeometry(0.01, 0.02, 0.1, 8);
    const material = new THREE.MeshStandardMaterial({ color: 0xff0000 });
    
    const controller1Grip = renderer.xr.getControllerGrip(0);
    const mesh1 = new THREE.Mesh(geometry, material);
    controller1Grip.add(mesh1);
    scene.add(controller1Grip);

    const controller2Grip = renderer.xr.getControllerGrip(1);
    const mesh2 = new THREE.Mesh(geometry, material.clone());
    mesh2.material.color.set(0x0000ff);
    controller2Grip.add(mesh2);
    scene.add(controller2Grip);
    
    // VRã‚»ãƒƒã‚·ãƒ§ãƒ³çµ‚äº†æ™‚ã®å‡¦ç†ã‚’è¿½åŠ 
    renderer.xr.addEventListener('sessionend', () => {
        isVRMode = false;
        document.getElementById('info').style.display = 'block';
        document.getElementById('memoPanel').style.display = 'none';
        updateStatus('VRãƒ¢ãƒ¼ãƒ‰çµ‚äº†');
    });

    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);

    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(5, 10, 5);
    directionalLight.castShadow = true;
    scene.add(directionalLight);

    const floorGeometry = new THREE.PlaneGeometry(50, 50);
    const floorMaterial = new THREE.MeshStandardMaterial({ color: 0x808080 });
    const floor = new THREE.Mesh(floorGeometry, floorMaterial);
    floor.rotation.x = -Math.PI / 2;
    floor.receiveShadow = true;
    scene.add(floor);

    // ç›´å¾„1mã®çƒ (ãƒ‡ãƒãƒƒã‚°å¯¾è±¡)
    const sphereGeometry = new THREE.SphereGeometry(0.5, 32, 32);
    const sphereMaterial = new THREE.MeshStandardMaterial({ color: 0x4ecdc4 });
    sphereMesh = new THREE.Mesh(sphereGeometry, sphereMaterial); // å¤‰æ•°ã«ä¿æŒ
    sphereMesh.position.set(0, 0.5, -3);
    sphereMesh.castShadow = true;
    sphereMesh.receiveShadow = true;
    scene.add(sphereMesh);

    document.addEventListener('keydown', onKeyDown);
    document.addEventListener('keyup', onKeyUp);
    
    const container = document.getElementById('container');
    container.addEventListener('mousedown', onMouseDown);
    container.addEventListener('mousemove', onMouseMove);
    container.addEventListener('mouseup', onMouseUp);
    container.addEventListener('mouseleave', onMouseUp);
    container.addEventListener('wheel', onMouseWheel);
    
    document.getElementById('fileInput').addEventListener('change', onFileSelect);
    document.getElementById('resetButton').addEventListener('click', resetCamera);
    document.getElementById('clearButton').addEventListener('click', clearModel);
    document.getElementById('scaleSlider').addEventListener('input', onScaleChange);
    document.getElementById('scale05').addEventListener('click', () => setScale(0.5));
    document.getElementById('scale1').addEventListener('click', () => setScale(1.0));
    document.getElementById('scale2').addEventListener('click', () => setScale(2.0));
    document.getElementById('scale5').addEventListener('click', () => setScale(5.0));
    document.getElementById('voiceButton').addEventListener('click', toggleVoiceInput);
    document.getElementById('voiceInputBtn').addEventListener('click', chooseVoiceInput);
    document.getElementById('keyboardInputBtn').addEventListener('click', chooseKeyboardInput);
    document.getElementById('submitMemoBtn').addEventListener('click', submitMemo);
    document.getElementById('cancelMemoBtn').addEventListener('click', cancelMemoInput);
    
    window.addEventListener('resize', onWindowResize);

    initSpeechRecognition();

    updateStatus('æº–å‚™å®Œäº† - GLBãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„');
    renderer.setAnimationLoop(animate);
}

function onFileSelect(event) {
    const file = event.target.files[0];
    if (!file) return;

    const fileName = file.name.toLowerCase();
    const fileExtension = fileName.split('.').pop();

    updateStatus(`ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿ä¸­: ${file.name}`);
    document.getElementById('loading').style.display = 'block';

    const reader = new FileReader();
    reader.onload = e => {
        const arrayBuffer = e.target.result;
        
        switch(fileExtension) {
            case 'glb':
            case 'gltf':
                loadGLTF(arrayBuffer);
                break;
            case 'obj':
                loadOBJ(arrayBuffer);
                break;
            case 'fbx':
                loadFBX(arrayBuffer);
                break;
            case 'stl':
                loadSTL(arrayBuffer);
                break;
            case 'dae':
                loadCollada(arrayBuffer);
                break;
            case 'ply':
                loadPLY(arrayBuffer);
                break;
            default:
                updateStatus('å¯¾å¿œã—ã¦ã„ãªã„ãƒ•ã‚¡ã‚¤ãƒ«å½¢å¼ã§ã™');
                document.getElementById('loading').style.display = 'none';
        }
    };
    reader.readAsArrayBuffer(file);
}

function loadGLTF(arrayBuffer) {
    const loader = new THREE.GLTFLoader();
    
    loader.parse(arrayBuffer, '', gltf => {
        addModelToScene(gltf.scene, 'GLTF');
    }, error => {
        console.error('GLTFèª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:', error);
        updateStatus('GLTFèª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼');
        document.getElementById('loading').style.display = 'none';
    });
}

function loadOBJ(arrayBuffer) {
    const loader = new THREE.OBJLoader();
    const text = new TextDecoder('utf-8').decode(arrayBuffer);
    
    try {
        const object = loader.parse(text);
        addModelToScene(object, 'OBJ');
    } catch (error) {
        updateStatus('OBJèª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼');
        document.getElementById('loading').style.display = 'none';
    }
}

function loadFBX(arrayBuffer) {
    const manager = new THREE.LoadingManager();
    const loader = new THREE.FBXLoader(manager);
    
    try {
        const object = loader.parse(arrayBuffer);
        addModelToScene(object, 'FBX');
    } catch (error) {
        updateStatus('FBXèª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼');
        document.getElementById('loading').style.display = 'none';
    }
}

function loadSTL(arrayBuffer) {
    const loader = new THREE.STLLoader();
    
    try {
        const geometry = loader.parse(arrayBuffer);
        const material = new THREE.MeshStandardMaterial({ color: 0xaaaaaa });
        const mesh = new THREE.Mesh(geometry, material);
        addModelToScene(mesh, 'STL');
    } catch (error) {
        updateStatus('STLèª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼');
        document.getElementById('loading').style.display = 'none';
    }
}

function loadCollada(arrayBuffer) {
    const loader = new THREE.ColladaLoader();
    const text = new TextDecoder('utf-8').decode(arrayBuffer);
    
    try {
        const collada = loader.parse(text);
        addModelToScene(collada.scene, 'DAE');
    } catch (error) {
        updateStatus('Colladaèª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼');
        document.getElementById('loading').style.display = 'none';
    }
}

function loadPLY(arrayBuffer) {
    const loader = new THREE.PLYLoader();
    
    try {
        const geometry = loader.parse(arrayBuffer);
        geometry.computeVertexNormals();
        const material = new THREE.MeshStandardMaterial({ color: 0xaaaaaa });
        const mesh = new THREE.Mesh(geometry, material);
        addModelToScene(mesh, 'PLY');
    } catch (error) {
        updateStatus('PLYèª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼');
        document.getElementById('loading').style.display = 'none';
    }
}

function addModelToScene(model, format) {
    const oldModel = scene.getObjectByName('loadedModel');
    if (oldModel) scene.remove(oldModel);

    model.name = 'loadedModel';
    
    model.traverse(node => {
        if (node.isMesh) {
            node.castShadow = true;
            node.receiveShadow = true;
            if (!node.material) {
                node.material = new THREE.MeshStandardMaterial({ color: 0xaaaaaa });
            }
        }
    });

    const box = new THREE.Box3().setFromObject(model);
    const center = box.getCenter(new THREE.Vector3());
    const size = box.getSize(new THREE.Vector3());

    model.position.x = -center.x;
    model.position.z = -center.z;
    model.position.y = -box.min.y;

    scene.add(model);
    
    updateStatus(`${format}ãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿å®Œäº†! ã‚µã‚¤ã‚º: ${size.x.toFixed(1)}x${size.y.toFixed(1)}x${size.z.toFixed(1)}`);
    document.getElementById('loading').style.display = 'none';

    camera.position.set(0, PLAYER_HEIGHT, size.z * 0.5 + 3);
}

function onKeyDown(event) {
    if (document.getElementById('memoInputDialog').style.display === 'block') return;
    
    switch (event.code) {
        case 'ArrowUp':
        case 'KeyW':
            moveForward = true;
            break;
        case 'ArrowDown':
        case 'KeyS':
            moveBackward = true;
            break;
        case 'ArrowLeft':
        case 'KeyA':
            moveLeft = true;
            break;
        case 'ArrowRight':
        case 'KeyD':
            moveRight = true;
            break;
        case 'Space':
            if (canJump) velocity.y += JUMP_VELOCITY;
            canJump = false;
            break;
        case 'KeyQ':
            zoomIn();
            break;
        case 'KeyE':
            zoomOut();
            break;
        case 'KeyM':
            toggleMemoMode();
            break;
    }
}

function onKeyUp(event) {
    if (document.getElementById('memoInputDialog').style.display === 'block') return;
    
    switch (event.code) {
        case 'ArrowUp':
        case 'KeyW':
            moveForward = false;
            break;
        case 'ArrowDown':
        case 'KeyS':
            moveBackward = false;
            break;
        case 'ArrowLeft':
        case 'KeyA':
            moveLeft = false;
            break;
        case 'ArrowRight':
        case 'KeyD':
            moveRight = false;
            break;
    }
}

function onMouseDown(event) {
    if (document.getElementById('inputMethodDialog').style.display === 'block' || 
        document.getElementById('memoInputDialog').style.display === 'block') {
        return;
    }

    if (memoMode && event.button === 0) {
        placeMemo(event);
        return;
    }
    isMouseDown = true;
    lastMouseX = event.clientX;
    lastMouseY = event.clientY;
}

function onMouseUp() {
    isMouseDown = false;
}

function onMouseMove(event) {
    if (!isMouseDown) return;

    const deltaX = event.clientX - lastMouseX;
    const deltaY = event.clientY - lastMouseY;

    lastMouseX = event.clientX;
    lastMouseY = event.clientY;

    euler.setFromQuaternion(camera.quaternion);
    euler.y -= deltaX * 0.002;
    euler.x -= deltaY * 0.002;
    // ä¸Šä¸‹æ–¹å‘ã®å›è»¢ã‚’åˆ¶é™
    euler.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, euler.x));

    camera.quaternion.setFromEuler(euler);
}

function onMouseWheel(event) {
    event.preventDefault();
    if (event.deltaY > 0) {
        zoomOut();
    } else {
        zoomIn();
    }
}

function zoomIn() {
    zoomLevel = Math.max(MIN_FOV, zoomLevel - 5);
    camera.fov = zoomLevel;
    camera.updateProjectionMatrix();
}

function zoomOut() {
    zoomLevel = Math.min(MAX_FOV, zoomLevel + 5);
    camera.fov = zoomLevel;
    camera.updateProjectionMatrix();
}

function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

function resetCamera() {
    camera.position.set(INITIAL_CAMERA_POS.x, INITIAL_CAMERA_POS.y, INITIAL_CAMERA_POS.z);
    camera.rotation.set(0, 0, 0);
    camera.fov = INITIAL_ZOOM;
    camera.updateProjectionMatrix();
    zoomLevel = INITIAL_ZOOM;
    updateStatus('ã‚«ãƒ¡ãƒ©ä½ç½®ã‚’ãƒªã‚»ãƒƒãƒˆã—ã¾ã—ãŸ');
}

function clearModel() {
    const model = scene.getObjectByName('loadedModel');
    if (model) {
        scene.remove(model);
        updateStatus('3Dãƒ¢ãƒ‡ãƒ«ã‚’å‰Šé™¤ã—ã¾ã—ãŸ');
    } else {
        updateStatus('å‰Šé™¤ã™ã‚‹ãƒ¢ãƒ‡ãƒ«ãŒã‚ã‚Šã¾ã›ã‚“');
    }
    memos.forEach(memo => scene.remove(memo.mesh));
    memos = [];
    document.getElementById('memoList').innerHTML = '';
}

function onScaleChange(event) {
    setScale(parseFloat(event.target.value));
}

function setScale(scale) {
    modelScale = scale;
    document.getElementById('scaleValue').textContent = `å€ç‡: ${modelScale.toFixed(1)}x`;
    document.getElementById('scaleSlider').value = modelScale;

    const model = scene.getObjectByName('loadedModel');
    if (model) {
        model.scale.set(modelScale, modelScale, modelScale);
    }
}

function animate(time) {
    const delta = (time - prevTime) / 1000;
    prevTime = time;

    if (isVRMode) {
        handleVRMovement(delta);
        handleVRInputs();
    } else {
        handlePCMovement(delta);
    }
    
    if (!isVRMode) {
        // PCãƒ¢ãƒ¼ãƒ‰æ™‚ã®é‡åŠ›ã¨åºŠåˆ¤å®š
        velocity.y -= GRAVITY * delta;
        
        // ç§»å‹•
        const speed = MOVE_SPEED;
        direction.z = Number(moveForward) - Number(moveBackward);
        direction.x = Number(moveRight) - Number(moveLeft);
        direction.normalize(); // ã“ã®è¡Œã¯ã€æ–œã‚ç§»å‹•ã®é€Ÿåº¦ã‚’æŠ‘ãˆã‚‹ãŸã‚

        if (moveForward || moveBackward) velocity.z -= direction.z * speed * delta;
        if (moveLeft || moveRight) velocity.x -= direction.x * speed * delta;

        // æ‘©æ“¦ã¨æ¸›é€Ÿ
        velocity.x *= (1 - 0.1 * delta * 5);
        velocity.z *= (1 - 0.1 * delta * 5);
        
        camera.position.x += velocity.x * delta;
        camera.position.y += velocity.y * delta;
        camera.position.z += velocity.z * delta;

        if (camera.position.y < PLAYER_HEIGHT) {
            velocity.y = 0;
            camera.position.y = PLAYER_HEIGHT;
            canJump = true;
        }

        // é€Ÿåº¦ã‚’æ¸›è¡°ã•ã›ã‚‹ (PCãƒ¢ãƒ¼ãƒ‰æ™‚)
        velocity.x -= velocity.x * 10.0 * delta;
        velocity.z -= velocity.z * 10.0 * delta;

    }

    renderer.render(scene, camera);
}

function handlePCMovement(delta) {
    // velocityã¨directionã®è¨ˆç®—ã¯animateé–¢æ•°å†…ã«ã‚ã‚‹ãŸã‚ã€ã“ã“ã§ã¯çœç•¥
}

function handleVRMovement(delta) {
    let controllerToUse;
    
    // å·¦ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ (controllers[0]) ã‚’å„ªå…ˆçš„ã«ä½¿ç”¨
    if (controllers[0] && controllers[0].userData.gamepad) {
        controllerToUse = controllers[0];
    } else if (controllers[1] && controllers[1].userData.gamepad) {
        controllerToUse = controllers[1]; // å·¦ãŒãªã‘ã‚Œã°å³ã‚’ä½¿ç”¨ (ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯)
    }

    if (controllerToUse) {
        const gamepad = controllerToUse.userData.gamepad;
        
        // ----------------------------------------------------
        // ğŸ› ï¸ ä¿®æ­£ç‚¹ 1: Meta Questç”¨ã«è»¸ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’ [0], [1] ã«å¤‰æ›´
        // ----------------------------------------------------
        // Questã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã®å·¦ã‚¹ãƒ†ã‚£ãƒƒã‚¯ã¯é€šå¸¸ axes[0] (X) ã¨ axes[1] (Y)
        const axisX = gamepad.axes[0]; // å·¦å³ç§»å‹•
        const axisY = gamepad.axes[1]; // å‰å¾Œç§»å‹•
        
        const speed = VR_MOVE_SPEED;
        const moveVector = new THREE.Vector3();

        // å‰å¾Œç§»å‹• (Yè»¸)
        if (Math.abs(axisY) > 0.1) {
            moveVector.z = -axisY * speed * delta;
        }
        
        // å·¦å³ç§»å‹• (Xè»¸)
        if (Math.abs(axisX) > 0.1) {
            moveVector.x = axisX * speed * delta;
        }

        if (moveVector.length() > 0) {
            // ã‚«ãƒ¡ãƒ©ã®å‘ãã«åˆã‚ã›ã¦ç§»å‹•ãƒ™ã‚¯ãƒˆãƒ«ã‚’å›è»¢ã•ã›ã‚‹
            const directionQuaternion = controllerToUse.quaternion.clone(); 
            
            // Xè»¸ï¼ˆä¸Šä¸‹ï¼‰ã®å›è»¢ã‚’é™¤å¤–ã—ã¦ã€æ°´å¹³æ–¹å‘ã®ç§»å‹•ã®ã¿ã‚’è¨ˆç®—
            const yAxis = new THREE.Vector3(0, 1, 0);
            const rotationMatrix = new THREE.Matrix4();
            rotationMatrix.extractRotation(controllerToUse.matrixWorld);
            const worldForward = new THREE.Vector3(0, 0, -1).applyMatrix4(rotationMatrix);
            worldForward.y = 0; // æ°´å¹³æ–¹å‘ã®ã¿ã«åˆ¶é™
            worldForward.normalize();
            
            const worldRight = new THREE.Vector3(1, 0, 0).applyMatrix4(rotationMatrix);
            worldRight.y = 0; // æ°´å¹³æ–¹å‘ã®ã¿ã«åˆ¶é™
            worldRight.normalize();

            // å‰å¾Œç§»å‹•
            camera.position.add(worldForward.multiplyScalar(moveVector.z * 10)); 
            // å·¦å³ç§»å‹•
            camera.position.add(worldRight.multiplyScalar(moveVector.x * 10));
        }

        // ä¸Šæ˜‡/ä¸‹é™ (é€šå¸¸ã€A/Bãƒœã‚¿ãƒ³ã‚„ã‚°ãƒªãƒƒãƒ—/ãƒˆãƒªã‚¬ãƒ¼ã®çµ„ã¿åˆã‚ã›)
        // Questã§ã¯ A:4, B:5, X:2, Y:3, ãƒ¡ã‚¤ãƒ³ãƒˆãƒªã‚¬ãƒ¼:1, ã‚°ãƒªãƒƒãƒ—:2 (ãã‚Œãã‚Œã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼å´)
        
        // ----------------------------------------------------
        // ğŸ› ï¸ ä¿®æ­£ç‚¹ 3: ãƒœã‚¿ãƒ³ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã®èª¿æ•´ (ä¸Šæ˜‡/ä¸‹é™)
        // ----------------------------------------------------
        // å·¦ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã®Xãƒœã‚¿ãƒ³ (axes[2]ã‹buttons[2]ã‹buttons[4]ã‚ãŸã‚Š)
        // ã“ã“ã§ã¯ä¾¿å®œä¸Šã€å…ƒã®ã‚³ãƒ¼ãƒ‰ã®æ„å›³ã‚’ç¶­æŒã—ã¤ã¤ã€Questã§ä¸€èˆ¬çš„ãªãƒœã‚¿ãƒ³ç•ªå·ã‚’è©¦ã—ã¾ã™ã€‚
        // ä¸€èˆ¬çš„ãªãƒœã‚¿ãƒ³ç•ªå·ï¼šIndex 4: X/Aãƒœã‚¿ãƒ³ã€Index 5: Y/Bãƒœã‚¿ãƒ³
        
        // ä¸Šæ˜‡ (Questå³ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã®Aãƒœã‚¿ãƒ³ã€ã¾ãŸã¯å·¦ã®Xãƒœã‚¿ãƒ³)
        if (controllers[1] && controllers[1].userData.gamepad && controllers[1].userData.gamepad.buttons[4].pressed) {
            camera.position.y += speed * delta;
        } 
        
        // ä¸‹é™ (Questå³ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã®Bãƒœã‚¿ãƒ³ã€ã¾ãŸã¯å·¦ã®Yãƒœã‚¿ãƒ³)
        if (controllers[1] && controllers[1].userData.gamepad && controllers[1].userData.gamepad.buttons[5].pressed) {
            camera.position.y -= speed * delta;
        } 
        
        // é‡åŠ›ã«ã‚ˆã‚‹è½ä¸‹ã‚’é˜²ãï¼ˆåºŠã¨ã®å½“ãŸã‚Šåˆ¤å®šã¯ã“ã“ã§ã¯ç°¡æ˜“çš„ã«çœç•¥ï¼‰
        if (camera.position.y < PLAYER_HEIGHT) {
            camera.position.y = PLAYER_HEIGHT;
        }

    }
}

function handleVRInputs() {
    // ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ãŒæ¥ç¶šã•ã‚Œã¦ã„ã‚‹ã‹ç¢ºèª
    const controller1 = controllers[0]; // å·¦
    const controller2 = controllers[1]; // å³
    
    if (controller2 && controller2.userData.gamepad) {
        const gamepad2 = controller2.userData.gamepad;
        
        // ----------------------------------------------------
        // ğŸ› ï¸ ä¿®æ­£ç‚¹ 2: Aãƒœã‚¿ãƒ³ã§çƒã®è‰²ã‚’å¤‰æ›´ã™ã‚‹ãƒ‡ãƒãƒƒã‚°æ©Ÿèƒ½
        // ----------------------------------------------------
        // Questã®å³ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã®Aãƒœã‚¿ãƒ³ã¯é€šå¸¸ gamepad.buttons[4]
        const aButtonPressed = gamepad2.buttons[4].pressed;
        
        if (aButtonPressed) {
            // Aãƒœã‚¿ãƒ³ãŒæŠ¼ã•ã‚ŒãŸã‚‰çƒã‚’èµ¤ã«
            if (sphereMesh.material.color.getHex() !== 0xff0000) {
                sphereMesh.material.color.set(0xff0000);
            }
        } else {
            // Aãƒœã‚¿ãƒ³ãŒé›¢ã•ã‚ŒãŸã‚‰å…ƒã®è‰²ã«æˆ»ã™ (æ°´è‰²)
            if (sphereMesh.material.color.getHex() !== 0x4ecdc4) {
                sphereMesh.material.color.set(0x4ecdc4);
            }
        }
        
        // VRãƒ¡ãƒ¢ãƒ¢ãƒ¼ãƒ‰ã®åˆ‡ã‚Šæ›¿ãˆ (Xãƒœã‚¿ãƒ³é•·æŠ¼ã—)
        // Xãƒœã‚¿ãƒ³ã¯é€šå¸¸ gamepad.buttons[2]
        const xButtonPressed = gamepad2.buttons[2].pressed;

        if (xButtonPressed) {
            if (xButtonPressTime === 0) {
                xButtonPressTime = performance.now();
            } else if (performance.now() - xButtonPressTime > 1000) { // 1ç§’é•·æŠ¼ã—
                if (!vrMemoMode) {
                    toggleMemoMode();
                    vrMemoMode = true;
                }
            }
        } else {
            xButtonPressTime = 0;
            if (vrMemoMode && memoMode) {
                // é•·æŠ¼ã—ã‹ã‚‰é›¢ã—ãŸæ™‚ã«å³åº§ã«è§£é™¤ã•ã‚Œã‚‹ã®ã‚’é˜²ããŸã‚ã€è§£é™¤å‡¦ç†ã¯åˆ¥é€”æ¤œè¨
                // ã“ã“ã§ã¯Xãƒœã‚¿ãƒ³ã‚’é›¢ã—ã¦ã‚‚VRãƒ¡ãƒ¢ãƒ¢ãƒ¼ãƒ‰ã‚’ç¶­æŒã—ã€Mã‚­ãƒ¼ã‚„å†é•·æŠ¼ã—ã§è§£é™¤ã™ã‚‹å½¢ã«ã™ã‚‹
                // toggleMemoMode() ã¯Mã‚­ãƒ¼ã§ã®ã¿ç™ºå‹•ã™ã‚‹ã‚ˆã†ã«èª¿æ•´
            }
        }
        
        // ãƒ¡ãƒ¢é…ç½® (ãƒ¡ãƒ¢ãƒ¢ãƒ¼ãƒ‰ä¸­ã€å³ãƒˆãƒªã‚¬ãƒ¼)
        // å³ãƒˆãƒªã‚¬ãƒ¼ã¯é€šå¸¸ gamepad.buttons[1]
        const rightTriggerPressed = gamepad2.buttons[1].pressed;
        if (vrMemoMode && memoMode && rightTriggerPressed && !controller2.userData.memoPlaced) {
            placeVRMemo(controller2);
            controller2.userData.memoPlaced = true;
        } else if (!rightTriggerPressed) {
            controller2.userData.memoPlaced = false;
        }
    }
}

function placeVRMemo(controller) {
    const raycaster = new THREE.Raycaster();
    const tempMatrix = new THREE.Matrix4();
    tempMatrix.identity().extractRotation(controller.matrixWorld);

    raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
    raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix); // ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã®å…ˆç«¯æ–¹å‘

    const intersects = raycaster.intersectObjects(scene.children, true);

    if (intersects.length > 0) {
        pendingMemoPosition = intersects[0].point;
        updateStatus(`ãƒ¡ãƒ¢é…ç½®ä½ç½®æ±ºå®š: (${pendingMemoPosition.x.toFixed(2)}, ${pendingMemoPosition.y.toFixed(2)}, ${pendingMemoPosition.z.toFixed(2)})`);
        
        // å…¥åŠ›æ–¹æ³•ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã‚’è¡¨ç¤º
        document.getElementById('inputMethodDialog').style.display = 'block';
    } else {
        updateStatus('ãƒ¢ãƒ‡ãƒ«/åºŠã«ãƒ’ãƒƒãƒˆã—ã¾ã›ã‚“ã§ã—ãŸ');
    }
}

function toggleMemoMode() {
    memoMode = !memoMode;
    document.getElementById('memoModeIndicator').style.display = memoMode ? 'block' : 'none';
    document.getElementById('memoPanel').style.display = memoMode ? 'block' : 'none';
    updateStatus(`ãƒ¡ãƒ¢ãƒ¢ãƒ¼ãƒ‰: ${memoMode ? 'ON' : 'OFF'}`);
    
    if (memoMode && isVRMode) {
        vrMemoMode = true; // VRãƒ¢ãƒ¼ãƒ‰ã§Mã‚­ãƒ¼ã‚’æŠ¼ã—ãŸã‚‰vrMemoModeã‚‚ON
    } else if (!memoMode) {
        vrMemoMode = false; // ãƒ¡ãƒ¢ãƒ¢ãƒ¼ãƒ‰OFFã§vrMemoModeã‚‚OFF
    }
}

// ... (placeMemo, createMemoMesh, updateMemoList, initSpeechRecognition, toggleVoiceInput, chooseVoiceInput, chooseKeyboardInput, submitMemo, cancelMemoInput, setMemoPriority ã®å„é–¢æ•°ã¯å…ƒã®ã‚³ãƒ¼ãƒ‰ã¨åŒã˜ã§ã™) ...

// **å…ƒã®ã‚³ãƒ¼ãƒ‰ã®ã¾ã¾**
function placeMemo(event) {
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

    raycaster.setFromCamera(mouse, camera);

    const intersects = raycaster.intersectObjects(scene.children, true);

    if (intersects.length > 0) {
        pendingMemoPosition = intersects[0].point;
        updateStatus(`ãƒ¡ãƒ¢é…ç½®ä½ç½®æ±ºå®š: (${pendingMemoPosition.x.toFixed(2)}, ${pendingMemoPosition.y.toFixed(2)}, ${pendingMemoPosition.z.toFixed(2)})`);
        
        // å…¥åŠ›æ–¹æ³•ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã‚’è¡¨ç¤º
        document.getElementById('inputMethodDialog').style.display = 'block';
    } else {
        updateStatus('ãƒ¢ãƒ‡ãƒ«/åºŠã«ãƒ’ãƒƒãƒˆã—ã¾ã›ã‚“ã§ã—ãŸ');
    }
}

function createMemoMesh(position, text, priority) {
    const geometry = new THREE.SphereGeometry(0.1, 16, 16);
    let color;
    switch(priority) {
        case 'high':
            color = 0xf44336; // Red
            break;
        case 'normal':
            color = 0xffeb3b; // Yellow
            break;
        case 'low':
        default:
            color = 0x4CAF50; // Green
            break;
    }
    const material = new THREE.MeshBasicMaterial({ color: color });
    const mesh = new THREE.Mesh(geometry, material);
    mesh.position.copy(position);
    mesh.userData.memoId = memoCounter++;

    scene.add(mesh);

    memos.push({
        id: mesh.userData.memoId,
        text: text,
        position: position,
        mesh: mesh,
        priority: priority
    });

    updateMemoList();
}

function updateMemoList() {
    const listEl = document.getElementById('memoList');
    listEl.innerHTML = '';
    
    memos.forEach(memo => {
        const item = document.createElement('div');
        item.className = `memo-item priority-${memo.priority}`;
        item.innerHTML = `
            <strong>ãƒ¡ãƒ¢ #${memo.id} (${memo.priority.toUpperCase()})</strong><br>
            ä½ç½®: (${memo.position.x.toFixed(1)}, ${memo.position.y.toFixed(1)}, ${memo.position.z.toFixed(1)})<br>
            å†…å®¹: ${memo.text}<br>
            <button onclick="removeMemo(${memo.id})">å‰Šé™¤</button>
        `;
        listEl.appendChild(item);
    });
}

window.removeMemo = function(id) {
    const index = memos.findIndex(memo => memo.id === id);
    if (index !== -1) {
        scene.remove(memos[index].mesh);
        memos.splice(index, 1);
        updateMemoList();
        updateStatus(`ãƒ¡ãƒ¢ #${id} ã‚’å‰Šé™¤ã—ã¾ã—ãŸ`);
    }
}

function initSpeechRecognition() {
    window.SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    if (window.SpeechRecognition) {
        recognition = new SpeechRecognition();
        recognition.lang = 'ja-JP';
        recognition.interimResults = false;
        recognition.maxAlternatives = 1;

        recognition.onresult = (event) => {
            const transcript = event.results[0][0].transcript;
            document.getElementById('memoTextarea').value = transcript;
            updateStatus('éŸ³å£°èªè­˜å®Œäº†');
            document.getElementById('voiceButton').classList.remove('recording');
            document.getElementById('memoInputDialog').style.display = 'block';
            isRecording = false;
        };

        recognition.onerror = (event) => {
            updateStatus('éŸ³å£°èªè­˜ã‚¨ãƒ©ãƒ¼: ' + event.error);
            document.getElementById('voiceButton').classList.remove('recording');
            document.getElementById('memoInputDialog').style.display = 'block'; // ã‚¨ãƒ©ãƒ¼æ™‚ã‚‚æ‰‹å‹•å…¥åŠ›ã«åˆ‡ã‚Šæ›¿ãˆ
            isRecording = false;
        };

        recognition.onend = () => {
            if (isRecording) {
                // è‡ªå‹•çµ‚äº†ã®å ´åˆã¯å†é–‹
                // recognition.start(); 
                // ä»Šå›ã¯è‡ªå‹•å†é–‹ã¯ã›ãšã«ä¸€åº¦çµ‚äº†
                document.getElementById('voiceButton').classList.remove('recording');
                isRecording = false;
            }
        };
    } else {
        document.getElementById('voiceButton').disabled = true;
        document.getElementById('voiceButton').textContent = 'éŸ³å£°å…¥åŠ›éå¯¾å¿œ';
        document.getElementById('voiceInputBtn').disabled = true;
    }
}

function toggleVoiceInput() {
    if (!pendingMemoPosition) {
        updateStatus('ãƒ¡ãƒ¢ã‚’é…ç½®ã™ã‚‹å ´æ‰€ã‚’å…ˆã«ã‚¯ãƒªãƒƒã‚¯ã—ã¦ãã ã•ã„');
        return;
    }
    document.getElementById('inputMethodDialog').style.display = 'block';
}

function chooseVoiceInput() {
    document.getElementById('inputMethodDialog').style.display = 'none';
    
    if (recognition && !isRecording) {
        document.getElementById('memoTextarea').value = 'éŒ²éŸ³ä¸­...';
        document.getElementById('memoInputDialog').style.display = 'block'; // éŒ²éŸ³çŠ¶æ…‹ã‚’è¡¨ç¤º
        document.getElementById('voiceButton').classList.add('recording');
        
        // éŒ²éŸ³é–‹å§‹
        try {
            recognition.start();
            isRecording = true;
            updateStatus('éŸ³å£°éŒ²éŸ³é–‹å§‹...è©±ã—ã¦ãã ã•ã„');
        } catch (e) {
            updateStatus('éŒ²éŸ³é–‹å§‹ã‚¨ãƒ©ãƒ¼: ' + e.message);
            document.getElementById('memoInputDialog').style.display = 'none';
            document.getElementById('voiceButton').classList.remove('recording');
            isRecording = false;
        }
    } else {
        chooseKeyboardInput(); // éŸ³å£°å…¥åŠ›ãŒä½¿ãˆãªã„å ´åˆã¯ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã«åˆ‡ã‚Šæ›¿ãˆ
    }
}

function chooseKeyboardInput() {
    document.getElementById('inputMethodDialog').style.display = 'none';
    document.getElementById('memoTextarea').value = '';
    document.getElementById('memoInputDialog').style.display = 'block';
}

function submitMemo() {
    const text = document.getElementById('memoTextarea').value.trim();
    if (text && pendingMemoPosition) {
        // ç°¡æ˜“çš„ã«å„ªå…ˆåº¦ã‚’åˆ¤å®šï¼ˆä¾‹: ã€Œé‡è¦ã€ãŒå«ã¾ã‚Œã¦ã„ãŸã‚‰é«˜ï¼‰
        let priority = 'low';
        if (text.includes('é‡è¦') || text.includes('è¦ç¢ºèª')) {
            priority = 'high';
        } else if (text.length > 50) { // é•·ã„ãƒ¡ãƒ¢ã¯normal
            priority = 'normal';
        }
        
        createMemoMesh(pendingMemoPosition, text, priority);
        updateStatus(`ãƒ¡ãƒ¢ã‚’ä½œæˆã—ã¾ã—ãŸ: ${text.substring(0, 15)}...`);
        
        // ãƒªã‚»ãƒƒãƒˆ
        pendingMemoPosition = null;
        document.getElementById('memoInputDialog').style.display = 'none';
        document.getElementById('memoTextarea').value = '';
    } else {
        updateStatus('ãƒ¡ãƒ¢ã®å†…å®¹ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
    }
}

function cancelMemoInput() {
    document.getElementById('memoInputDialog').style.display = 'none';
    document.getElementById('memoTextarea').value = '';
    pendingMemoPosition = null;
    if (isRecording) {
        recognition.stop();
        isRecording = false;
    }
    updateStatus('ãƒ¡ãƒ¢ä½œæˆã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã—ã¾ã—ãŸ');
}

init();
