
<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>VR GLB„Ç∑„Éß„ÉÉ„Éó„Ç¶„Ç©„Éº„ÇØ„Çπ„É´„ÉºÔºàAÁâà - ÊúÄÂ∞è‰øÆÊ≠£ÁâàÔºâ</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; }
        #container { width: 100vw; height: 100vh; cursor: grab; }
        #container:active { cursor: grabbing; }
        #info { position: absolute; top: 10px; left: 10px; color: white; background: rgba(0,0,0,0.7); padding: 15px; border-radius: 8px; font-size: 14px; max-width: 320px; z-index: 100; }
        #controls { margin-top: 10px; padding-top: 10px; border-top: 1px solid rgba(255,255,255,0.3); }
        #fileInput { margin-top: 10px; padding: 8px; background: rgba(255,255,255,0.9); border: none; border-radius: 4px; cursor: pointer; width: 100%; }
        #vrButton { margin-top: 10px; padding: 12px; background: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer; width: 100%; font-size: 16px; font-weight: bold; }
        #vrButton:hover { background: #45a049; }
        #vrButton:disabled { background: #cccccc; cursor: not-allowed; }
        button { cursor: pointer; }
        .btn { margin-top: 10px; padding: 10px; border: none; border-radius: 4px; width: 100%; font-size: 14px; font-weight: bold; }
        #resetButton { background: #ff9800; color: white; }
        #clearButton { background: #f44336; color: white; margin-top: 5px; }
        #scaleControls { margin-top: 10px; padding: 10px; background: rgba(255,255,255,0.1); border-radius: 4px; }
        #scaleSlider { width: 100%; margin: 10px 0; }
        #scaleValue { color: #aaffaa; font-weight: bold; }
        .scaleButtons { display: flex; gap: 5px; margin-top: 5px; }
        .scaleButtons button { flex: 1; padding: 8px; background: #2196F3; color: white; border: none; border-radius: 4px; font-size: 12px; }
        #memoPanel { position: absolute; top: 10px; right: 10px; width: 300px; max-height: 80vh; overflow-y: auto; background: rgba(0, 0, 0, 0.8); color: white; padding: 15px; border-radius: 8px; display: none; z-index: 100; }
        #memoPanel h3 { margin-top: 0; border-bottom: 2px solid #4CAF50; padding-bottom: 10px; }
        .memo-item { background: rgba(255,255,255,0.1); padding: 10px; margin: 5px 0; border-radius: 4px; border-left: 4px solid #ffeb3b; }
        .memo-item button { margin-top: 5px; padding: 4px 8px; font-size: 11px; background: #f44336; color: white; border: none; border-radius: 3px; }
        #memoModeIndicator { position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%); background: rgba(76,175,80,0.9); color: white; padding: 20px 40px; border-radius: 8px; font-size: 20px; font-weight: bold; display: none; z-index: 1000; pointer-events: none; }
        #voiceButton { margin-top: 10px; padding: 12px; background: #9C27B0; color: white; border: none; border-radius: 4px; width: 100%; font-size: 16px; font-weight: bold; }
        #voiceButton.recording { background: #f44336; animation: pulse 1s infinite; }
        @keyframes pulse { 0%,100% { opacity:1 } 50%{ opacity:0.7 } }
        #inputMethodDialog, #memoInputDialog { position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%); background: rgba(0,0,0,0.95); padding: 30px; border-radius: 12px; display: none; z-index: 2000; }
        #inputMethodDialog h3, #memoInputDialog h3 { color: white; margin: 0 0 20px 0; text-align: center; }
        .input-method-buttons { display:flex; gap:15px; }
        .input-method-buttons button { padding:20px 30px; font-size:18px; font-weight:bold; border:none; border-radius:8px; }
        #voiceInputBtn { background:#9C27B0; color:white; }
        #keyboardInputBtn { background:#2196F3; color:white; }
        #memoInputDialog { width:400px; }
        #memoTextarea { width:100%; padding:10px; border:1px solid #ccc; border-radius:4px; resize:vertical; font-size:14px; box-sizing:border-box; background:#222; color:white; min-height:100px; }
        .dialog-buttons { display:flex; gap:10px; margin-top:15px; }
        #submitMemoBtn { flex:1; background:#4CAF50; color:white; padding:12px 20px; font-weight:bold; border:none; border-radius:4px; }
        #cancelMemoBtn { flex:1; background:#666; color:white; padding:12px 20px; font-weight:bold; border:none; border-radius:4px; }
        #loading { position:absolute; top:50%; left:50%; transform: translate(-50%,-50%); color:white; background: rgba(0,0,0,0.8); padding:20px 40px; border-radius:8px; font-size:18px; display:none; z-index:1000; }
        #status { margin-top:10px; font-size:12px; color:#aaffaa; }
    </style>
</head>
<body>
    <div id="container"></div>

    <div id="info">
        <strong>VR „Ç∑„Éß„ÉÉ„Éó„Ç¶„Ç©„Éº„ÇØ„Çπ„É´„Éº</strong><br>
        <small id="updateDate" style="color:#aaa"></small>
        <div id="controls">
            <strong>PC:</strong> W/A/S/DÁßªÂãï, „Éû„Ç¶„ÇπË¶ñÁÇπ, Q/E„Ç∫„Éº„É†, M„É°„É¢„É¢„Éº„Éâ<br>
            <strong>VR:</strong> Â∑¶„Çπ„ÉÜ„Ç£„ÉÉ„ÇØÁßªÂãï, Âè≥„Çπ„ÉÜ„Ç£„ÉÉ„ÇØË¶ñÁÇπ, A/B‰∏ä‰∏ã, Âè≥„Éà„É™„Ç¨„Éº„Ç∫„Éº„É†/„É°„É¢, X„Éú„Çø„É≥Èï∑Êäº„Åó„É°„É¢„É¢„Éº„ÉâÂàáÊõø
        </div>
        <input type="file" id="fileInput" accept=".glb,.gltf,.obj,.stl" />
        <button id="vrButton">VR„É¢„Éº„ÉâÈñãÂßã</button>
        <button id="resetButton" class="btn">„Ç´„É°„É©„É™„Çª„ÉÉ„Éà</button>
        <button id="clearButton" class="btn">„É¢„Éá„É´ÂâäÈô§</button>

        <div id="scaleControls">
            <strong>„É¢„Éá„É´„Çµ„Ç§„Ç∫</strong><br>
            <span id="scaleValue">1.0x</span>
            <input id="scaleSlider" type="range" min="0.1" max="10" step="0.1" value="1.0" />
            <div class="scaleButtons">
                <button id="scale05">0.5x</button>
                <button id="scale1">1.0x</button>
                <button id="scale2">2.0x</button>
                <button id="scale5">5.0x</button>
            </div>
        </div>

        <div id="status"></div>
    </div>

    <div id="loading">Ë™≠„ÅøËæº„Åø‰∏≠...</div>
    <div id="memoModeIndicator">„É°„É¢„É¢„Éº„Éâ ON</div>

    <div id="memoPanel">
        <h3>„É°„É¢„É™„Çπ„Éà</h3>
        <button id="voiceButton">üé§ Èü≥Â£∞ÂÖ•Âäõ</button>
        <div id="memoList"></div>
    </div>

    <div id="inputMethodDialog">
        <h3>„É°„É¢ÂÖ•ÂäõÊñπÊ≥ï</h3>
        <div class="input-method-buttons">
            <button id="voiceInputBtn">üé§ Èü≥Â£∞</button>
            <button id="keyboardInputBtn">‚å® „Ç≠„Éº„Éú„Éº„Éâ</button>
        </div>
    </div>

    <div id="memoInputDialog">
        <h3>„É°„É¢ÂÖ•Âäõ</h3>
        <textarea id="memoTextarea" placeholder="„É°„É¢„ÇíÂÖ•Âäõ..."></textarea>
        <div class="dialog-buttons">
            <button id="submitMemoBtn">‰ΩúÊàê</button>
            <button id="cancelMemoBtn">„Ç≠„É£„É≥„Çª„É´</button>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/OBJLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/STLLoader.js"></script>

    <script>
    /*************************************************************************
     AÁâàÔºàÊúÄÂ∞è‰øÆÊ≠£ÁâàÔºâ
     - ÂÖÉ„ÅÆÊßãÈÄ†„ÉªUI„ÅØ„Åù„ÅÆ„Åæ„Åæ„Å´„ÄÅ„É°„É¢„ÅÆ„ÄåÈÅ∏ÊäûÔºàRaycastÔºâ„Äç„ÅåÁ¢∫ÂÆü„Å´Âãï‰Ωú„Åô„Çã„Çà„ÅÜ
       createMemo / createMemoSprite „ÇíÊúÄÂ∞èÂ§âÊõ¥ÔºàSprite -> Plane MeshÔºâ„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ
     *************************************************************************/

    let scene, camera, renderer, cameraRig;
    let moveForward=false, moveBackward=false, moveLeft=false, moveRight=false;
    let velocity=new THREE.Vector3(), direction=new THREE.Vector3();
    let prevTime=performance.now(), euler=new THREE.Euler(0,0,0,'YXZ');
    let isMouseDown=false, lastMouseX=0, lastMouseY=0, zoomLevel=75;
    const MIN_FOV=30, MAX_FOV=100, PLAYER_HEIGHT=1.6, MOVE_SPEED=80, VR_MOVE_SPEED=10, VR_ROTATION_SPEED=1.5;
    let controllers=[], isVRMode=false, memoMode=false, memos=[], memoCounter=0;
    let recognition=null, isRecording=false, pendingMemoPosition=null;
    let vrMemoMode=true; 
        let vrDebugText=null, vrDebugCanvas=null;  // ‚Üê „Åì„ÅÆË°å„ÇíËøΩÂä†
let xButtonCooldown=false, xButtonPressTime=0;  // ‚Üê „Åì„ÅÆË°å„ÇíËøΩÂä†
    let rightTriggerPressed=false, rightGripPressed=false;
let vrZoomLevel=0;
let rightTriggerPressTime=0;
let editingMemo = null;
let hoveredMemo = null;
let btn1WasPressed = false;  // ‚Üê „Åì„ÅÆË°å„ÅåËøΩÂä†„Åï„Çå„Å¶„ÅÑ„Åæ„Åô
let pendingDeleteMemo = null; // ‚Üê „Åì„ÅÆË°å„ÇÇËøΩÂä†„Åï„Çå„Å¶„ÅÑ„Åæ„Åô

    const VERSION='AÁâà v1.0.0', UPDATE_DATE='2025/12/24_6';

    function init() {
        document.getElementById('updateDate').textContent=`${VERSION} (${UPDATE_DATE})`;
        scene=new THREE.Scene();
        scene.background=new THREE.Color(0x87CEEB);
        scene.fog=new THREE.Fog(0x87CEEB,0,50);
        cameraRig=new THREE.Group();
        scene.add(cameraRig);
        camera=new THREE.PerspectiveCamera(75,window.innerWidth/window.innerHeight,0.1,1000);
        camera.position.set(0,PLAYER_HEIGHT,5);
        cameraRig.add(camera);
        renderer=new THREE.WebGLRenderer({antialias:true});
        renderer.setSize(window.innerWidth,window.innerHeight);
        renderer.shadowMap.enabled=true;
        renderer.xr.enabled=true;
        document.getElementById('container').appendChild(renderer.domElement);

        setupVR();
        createVRDebugPanel();

        scene.add(new THREE.AmbientLight(0xffffff,0.6));
        const light=new THREE.DirectionalLight(0xffffff,0.8);
        light.position.set(5,10,5);
        light.castShadow=true;
        scene.add(light);
        const floor=new THREE.Mesh(new THREE.PlaneGeometry(50,50),new THREE.MeshStandardMaterial({color:0x808080}));
        floor.rotation.x=-Math.PI/2;
        floor.receiveShadow=true;
        scene.add(floor);

        const sphere=new THREE.Mesh(new THREE.SphereGeometry(0.5,32,32),new THREE.MeshStandardMaterial({color:0xff0000}));
        sphere.position.set(0,0.5,-3);
        sphere.castShadow=true;
        scene.add(sphere);

        document.addEventListener('keydown',onKeyDown);
        document.addEventListener('keyup',onKeyUp);
        const c=document.getElementById('container');
        c.addEventListener('mousedown',onMouseDown);
        c.addEventListener('mousemove',onMouseMove);
        c.addEventListener('mouseup',()=>isMouseDown=false);
        c.addEventListener('mouseleave',()=>isMouseDown=false);
        c.addEventListener('wheel',onMouseWheel);

        document.getElementById('fileInput').addEventListener('change',onFileSelect);
        document.getElementById('resetButton').addEventListener('click',resetCamera);
        document.getElementById('clearButton').addEventListener('click',clearModel);
        document.getElementById('scaleSlider').addEventListener('input',e=>setScale(parseFloat(e.target.value)));
        document.getElementById('scale05').addEventListener('click',()=>setScale(0.5));
        document.getElementById('scale1').addEventListener('click',()=>setScale(1.0));
        document.getElementById('scale2').addEventListener('click',()=>setScale(2.0));
        document.getElementById('scale5').addEventListener('click',()=>setScale(5.0));
        document.getElementById('voiceButton').addEventListener('click',toggleVoiceInput);
        document.getElementById('voiceInputBtn').addEventListener('click',chooseVoiceInput);
        document.getElementById('keyboardInputBtn').addEventListener('click',chooseKeyboardInput);
        document.getElementById('submitMemoBtn').addEventListener('click',submitMemo);
        document.getElementById('cancelMemoBtn').addEventListener('click',cancelMemoInput);
        window.addEventListener('resize',onWindowResize);
        initSpeechRecognition();
        renderer.setAnimationLoop(animate);
    }

    function setupVR() {
        const vrButton=document.getElementById('vrButton');
        if('xr' in navigator) {
            navigator.xr.isSessionSupported('immersive-vr').then(sup=>{
                if(sup) {
                    vrButton.onclick=async()=>{
                        if(!renderer.xr.isPresenting) {
                            try {
                                const s=await navigator.xr.requestSession('immersive-vr',{optionalFeatures:['local-floor','bounded-floor']});
                                await renderer.xr.setSession(s);
                                isVRMode=true;
                            } catch(e) {
                                console.error('XR start failed', e);
                            }
                        }
                    };
                } else {
                    vrButton.disabled=true;
                    vrButton.textContent='VRÈùûÂØæÂøú';
                }
            }).catch(err=>{
                console.warn('isSessionSupported error', err);
                vrButton.disabled=true;
                vrButton.textContent='VRÈùûÂØæÂøú';
            });
        } else {
            vrButton.disabled=true;
            vrButton.textContent='VRÈùûÂØæÂøú';
        }

        const c1=renderer.xr.getController(0);
        cameraRig.add(c1);
        controllers.push(c1);
        const c2=renderer.xr.getController(1);
        cameraRig.add(c2);
        controllers.push(c2);

        const geom=new THREE.BoxGeometry(0.05,0.05,0.15);
        const mat1=new THREE.MeshStandardMaterial({color:0xff5555,emissive:0xff2222,emissiveIntensity:0.3});
        const mat2=new THREE.MeshStandardMaterial({color:0x5555ff,emissive:0x2222ff,emissiveIntensity:0.3});
        const g1=renderer.xr.getControllerGrip(0);
        const mesh1=new THREE.Mesh(geom,mat1);
        mesh1.position.z=-0.075;
        g1.add(mesh1);
        cameraRig.add(g1);
        const g2=renderer.xr.getControllerGrip(1);
        const mesh2=new THREE.Mesh(geom,mat2);
        mesh2.position.z=-0.075;
        g2.add(mesh2);
        cameraRig.add(g2);

        const lineGeom=new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,0),new THREE.Vector3(0,0,-2)]);
        const lineMat1=new THREE.LineBasicMaterial({color:0xff0000,linewidth:2});
        const lineMat2=new THREE.LineBasicMaterial({color:0x0000ff,linewidth:2});
        c1.add(new THREE.Line(lineGeom,lineMat1));
        c2.add(new THREE.Line(lineGeom,lineMat2));
    }

    function createVRDebugPanel() {
        vrDebugCanvas=document.createElement('canvas');
        vrDebugCanvas.width=512;
        vrDebugCanvas.height=512;
        const tex=new THREE.CanvasTexture(vrDebugCanvas);
        tex.minFilter = THREE.LinearFilter;
        const mat=new THREE.MeshBasicMaterial({map:tex,transparent:true,side:THREE.DoubleSide,depthTest:false});
        vrDebugText=new THREE.Mesh(new THREE.PlaneGeometry(1,1),mat);
        vrDebugText.position.set(-1,2,-2);
        vrDebugText.renderOrder = 9999;
        scene.add(vrDebugText);
        updateVRDebugPanel('VR Debug\nReady');
    }

    function updateVRDebugPanel(txt) {
        if(!vrDebugCanvas)return;
        const ctx=vrDebugCanvas.getContext('2d');
        ctx.clearRect(0,0,vrDebugCanvas.width,vrDebugCanvas.height);
        ctx.fillStyle='rgba(0,0,0,0.9)';
        ctx.fillRect(0,0,512,512);
        ctx.strokeStyle='#0f0';
        ctx.lineWidth=4;
        ctx.strokeRect(0,0,512,512);
        ctx.fillStyle='#0f0';
        ctx.font='bold 20px monospace';
        ctx.textAlign='left';
        ctx.textBaseline='top';
        txt.split('\n').forEach((l,i)=>ctx.fillText(l,15,15+i*28));
        if(vrDebugText?.material?.map) vrDebugText.material.map.needsUpdate=true;
    }

    function onFileSelect(e) {
        const f=e.target.files[0];
        if(!f)return;
        const ext=f.name.toLowerCase().split('.').pop();
        document.getElementById('loading').style.display='block';
        const r=new FileReader();
        r.onload=ev=>{
            const buf=ev.target.result;
            if(ext==='glb'||ext==='gltf')loadGLTF(buf);
            else if(ext==='obj')loadOBJ(buf);
            else if(ext==='stl')loadSTL(buf);
            else document.getElementById('loading').style.display='none';
        };
        r.readAsArrayBuffer(f);
    }

    function loadGLTF(buf) {
        new THREE.GLTFLoader().parse(buf,'',gltf=>addModelToScene(gltf.scene,'GLTF'),()=>document.getElementById('loading').style.display='none');
    }

    function loadOBJ(buf) {
        try {
            const obj=new THREE.OBJLoader().parse(new TextDecoder().decode(buf));
            addModelToScene(obj,'OBJ');
        } catch (err) {
            console.error('OBJ load error', err);
            document.getElementById('loading').style.display='none';
        }
    }

    function loadSTL(buf) {
        try {
            const geom=new THREE.STLLoader().parse(buf);
            const mesh=new THREE.Mesh(geom,new THREE.MeshStandardMaterial({color:0xaaa}));
            addModelToScene(mesh,'STL');
        } catch (err) {
            console.error('STL load error', err);
            document.getElementById('loading').style.display='none';
        }
    }

    function addModelToScene(model,fmt) {
        const old=scene.getObjectByName('loadedModel');
        if(old) scene.remove(old);
        model.name='loadedModel';
        model.traverse(n=>{
            if(n.isMesh) {
                n.castShadow=n.receiveShadow=true;
                if(!n.material)n.material=new THREE.MeshStandardMaterial({color:0xaaa});
            }
        });
        const box=new THREE.Box3().setFromObject(model);
        const center=box.getCenter(new THREE.Vector3());
        model.position.set(-center.x,-box.min.y,-center.z);
        scene.add(model);
        document.getElementById('loading').style.display='none';
        document.getElementById('status').textContent=`${fmt} Ë™≠„ÅøËæº„ÅøÂÆå‰∫Ü`;
    }

    function onKeyDown(e) {
        if(document.getElementById('memoInputDialog').style.display==='block')return;
        if(e.code==='KeyW'||e.code==='ArrowUp')moveForward=true;
        if(e.code==='KeyS'||e.code==='ArrowDown')moveBackward=true;
        if(e.code==='KeyA'||e.code==='ArrowLeft')moveLeft=true;
        if(e.code==='KeyD'||e.code==='ArrowRight')moveRight=true;
        if(e.code==='KeyQ')zoomIn();
        if(e.code==='KeyE')zoomOut();
        if(e.code==='KeyM')toggleMemoMode();
    }

    function onKeyUp(e) {
        if(e.code==='KeyW'||e.code==='ArrowUp')moveForward=false;
        if(e.code==='KeyS'||e.code==='ArrowDown')moveBackward=false;
        if(e.code==='KeyA'||e.code==='ArrowLeft')moveLeft=false;
        if(e.code==='KeyD'||e.code==='ArrowRight')moveRight=false;
    }

    function onMouseDown(e) {
        if(document.getElementById('inputMethodDialog').style.display==='block'||document.getElementById('memoInputDialog').style.display==='block')return;
        if(memoMode&&e.button===0){placeMemo(e);return;}
        isMouseDown=true;
        lastMouseX=e.clientX;
        lastMouseY=e.clientY;
    }

    function onMouseMove(e) {
        if(!isMouseDown)return;
        const dx=e.clientX-lastMouseX,dy=e.clientY-lastMouseY;
        lastMouseX=e.clientX;
        lastMouseY=e.clientY;
        euler.setFromQuaternion(camera.quaternion);
        euler.y-=dx*0.002;
        euler.x-=dy*0.002;
        euler.x=Math.max(-Math.PI/2,Math.min(Math.PI/2,euler.x));
        camera.quaternion.setFromEuler(euler);
    }

    function onMouseWheel(e) {
        e.preventDefault();
        if(e.deltaY<0)zoomIn();else zoomOut();
    }

    function zoomIn() {
        const oldZoom=zoomLevel;
        zoomLevel=Math.max(MIN_FOV,zoomLevel-5);
        camera.fov=zoomLevel;
        camera.updateProjectionMatrix();
    }

    function zoomOut() {
        const oldZoom=zoomLevel;
        zoomLevel=Math.min(MAX_FOV,zoomLevel+5);
        camera.fov=zoomLevel;
        camera.updateProjectionMatrix();
    }

    function resetCamera() {
        camera.position.set(0,PLAYER_HEIGHT,5);
        camera.rotation.set(0,0,0);
        zoomLevel=75;
        camera.fov=zoomLevel;
        camera.updateProjectionMatrix();
        velocity.set(0,0,0);
    }

    function clearModel() {
        const m=scene.getObjectByName('loadedModel');
        if(m)scene.remove(m);
    }

    function setScale(s) {
        const m=scene.getObjectByName('loadedModel');
        if(!m)return;
        m.scale.set(s,s,s);
        document.getElementById('scaleSlider').value=s;
        document.getElementById('scaleValue').textContent=`${s.toFixed(1)}x`;
    }

    function toggleMemoMode() {
        memoMode=!memoMode;
        const ind=document.getElementById('memoModeIndicator');
        const panel=document.getElementById('memoPanel');
        if(memoMode) {
            ind.style.display='block';
            panel.style.display='block';
            setTimeout(()=>ind.style.display='none',2000);
        } else {
            ind.style.display='none';
            panel.style.display='none';
        }
    }

    function placeMemo(e) {
        const ray=new THREE.Raycaster();
        const mouse=new THREE.Vector2((e.clientX/window.innerWidth)*2-1,-(e.clientY/window.innerHeight)*2+1);
        ray.setFromCamera(mouse,camera);
        const hits=ray.intersectObjects(scene.children,true);
        let pos;
        if(hits.length>0) {
            const hit=hits[0];
            const offset=new THREE.Vector3();
            if(hit.face) {
                offset.copy(hit.face.normal);
                offset.transformDirection(hit.object.matrixWorld);
            } else {
                offset.subVectors(camera.position,hit.point).normalize();
            }
            pos=hit.point.clone().add(offset.multiplyScalar(0.1));
        } else {
            const dir=new THREE.Vector3();
            camera.getWorldDirection(dir);
            pos=camera.position.clone().add(dir.multiplyScalar(3));
        }
        pendingMemoPosition=pos;
        document.getElementById('inputMethodDialog').style.display='block';
    }

    function chooseVoiceInput() {
        document.getElementById('inputMethodDialog').style.display='none';
        if(pendingMemoPosition&&recognition)startVoiceInputForMemo(pendingMemoPosition);
    }

    function chooseKeyboardInput() {
        document.getElementById('inputMethodDialog').style.display='none';
        if(pendingMemoPosition) {
            document.getElementById('memoTextarea').value='';
            document.getElementById('memoInputDialog').style.display='block';
        }
    }

    function submitMemo() {
        const txt=document.getElementById('memoTextarea').value.trim();
        document.getElementById('memoInputDialog').style.display='none';
        if(txt&&pendingMemoPosition) {
            createMemo(pendingMemoPosition,txt);
            toggleMemoMode();
        }
        pendingMemoPosition=null;
    }

    function cancelMemoInput() {
        document.getElementById('memoInputDialog').style.display='none';
        pendingMemoPosition=null;
    }

    // ---------- „Åì„Åì„Åã„ÇâÊúÄÂ∞è‰øÆÊ≠£Áâà„ÅÆÊú¨‰ΩìÔºàÈáçË¶ÅÔºâ ----------
    // createMemo: Sprite -> Plane MeshÔºàRaycast ÂÆâÂÆö„ÅÆ„Åü„ÇÅÔºâ
  function createMemo(pos, txt, lookAtPos) {
    const id = memoCounter++;
        // canvas „Çí‰Ωú„ÇãÔºàË¶ã„ÅüÁõÆ„ÅØÂêå„ÅòÔºâ
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 512;
        ctx.font = 'bold 32px Arial';
        const lines = [];
        txt.split('\n').forEach(para=>{
            const words = para.split(' ');
            let line = '';
            words.forEach(word=>{
                const test = line + word + ' ';
                if(ctx.measureText(test).width > 472 && line !== '') {
                    lines.push(line.trim());
                    line = word + ' ';
                } else {
                    line = test;
                }
            });
            lines.push(line.trim());
        });
        canvas.height = (lines.length * 40) + 40;
        ctx.fillStyle = '#ffd93d';
        ctx.fillRect(0,0,canvas.width,canvas.height);
        ctx.fillStyle = '#000';
        ctx.font = 'bold 32px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';
        let y = 20;
        lines.forEach(line=>{
            ctx.fillText(line,256,y);
            y += 40;
        });

        const tex = new THREE.CanvasTexture(canvas);
        tex.minFilter = THREE.LinearFilter;

        // „É°„ÉÉ„Ç∑„É•„Çí‰Ωø„ÅÜÔºàPlaneGeometryÔºâ ‚Äî Raycast „ÅåÂÆâÂÆö„Åô„Çã
        const aspect = canvas.height / canvas.width;
        // base size; Ë¶ã„ÅüÁõÆ„Åå„Åª„Åº Sprite „Å®ÂêåÁ≠â„Å´„Å™„Çã„Çà„ÅÜ„Å´Ë™øÊï¥
        const baseWidth = 0.6; // Ë™øÊï¥„Åï„Çå„ÅÜ„ÇãÂÄ§„ÄÇÂ∞è„Åï„Åô„Åé„Çã„Å®ÂΩì„Åü„Çâ„Å™„ÅÑ„ÅÆ„Åß„ÇÑ„ÇÑÂ§ß„Åç„ÇÅ„Å´
        const baseHeight = baseWidth * aspect;
        const geom = new THREE.PlaneGeometry(baseWidth, baseHeight);
        const mat = new THREE.MeshBasicMaterial({
            map: tex,
            transparent: true,
            side: THREE.DoubleSide,
            depthTest: false,    // ÊèèÁîª„ÅÆÂâçÂæåÈñ¢‰øÇ„ÇíÂÆâÂÆöÂåñÔºàUI„Å£„ÅΩ„ÅèÂâçÈù¢Ë°®Á§∫Ôºâ
            depthWrite: false
        });
        const mesh = new THREE.Mesh(geom, mat);
    mesh.position.copy(pos);
    
    // lookAtPos„ÅåÊåáÂÆö„Åï„Çå„Å¶„ÅÑ„Çå„Å∞„Åù„ÅÆÊñπÂêë„ÇíÂêë„Åè
    if(lookAtPos) {
        mesh.lookAt(lookAtPos);
    }
    
    mesh.renderOrder = 9999;
    mesh.name = `memo_${id}`;

        // store meta
        mesh.userData = mesh.userData || {};
        mesh.userData.text = txt;
        mesh.userData.aspect = aspect;
        mesh.userData.isMemo = true;

        scene.add(mesh);

        memos.push({id, text: txt, position: pos.clone(), sprite: mesh});
        updateMemoList();
    }

    function deleteMemo(id) {
        const idx=memos.findIndex(m=>m.id===id);
        if(idx!==-1) {
            const s = memos[idx].sprite;
            if(s) scene.remove(s);
            memos.splice(idx,1);
            updateMemoList();
        }
    }

    function updateMemoList() {
        const list=document.getElementById('memoList');
        list.innerHTML='';
        memos.forEach(m=>{
            const item=document.createElement('div');
            item.className='memo-item';
            item.innerHTML=`<div><strong>#${m.id+1}</strong>: ${m.text.replace(/\n/g,'<br>')}</div><button type="button">ÂâäÈô§</button>`;
            const btn = item.querySelector('button');
            btn.addEventListener('click',()=>deleteMemo(m.id));
            list.appendChild(item);
        });
    }

    // createMemoSprite: Á∑®ÈõÜ„ÅßÊñ∞„Åó„ÅÑ„É°„É¢„Çí‰Ωú„Çã„Å®„Åç„Å´‰Ωø„ÅÜÔºàÂêåÊßò„Å´ PlaneMesh „ÇíÁîüÊàêÔºâ
    function createMemoSprite(pos, txt) {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 512;
        ctx.font = 'bold 32px Arial';
        const lines = [];
        txt.split('\n').forEach(para => {
            const words = para.split(' ');
            let line = '';
            words.forEach(word => {
                const test = line + word + ' ';
                if(ctx.measureText(test).width > 472 && line !== '') {
                    lines.push(line.trim());
                    line = word + ' ';
                } else {
                    line = test;
                }
            });
            lines.push(line.trim());
        });
        canvas.height = (lines.length * 40) + 40;
        ctx.fillStyle = '#ffd93d';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#000';
        ctx.font = 'bold 32px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';
        let y = 20;
        lines.forEach(line => {
            ctx.fillText(line, 256, y);
            y += 40;
        });
        const tex = new THREE.CanvasTexture(canvas);
        tex.minFilter = THREE.LinearFilter;

        const aspect = canvas.height / canvas.width;
        const baseWidth = 0.6;
        const baseHeight = baseWidth * aspect;
        const geom = new THREE.PlaneGeometry(baseWidth, baseHeight);
        const mat = new THREE.MeshBasicMaterial({
            map: tex,
            transparent: true,
            side: THREE.DoubleSide,
            depthTest: false,
            depthWrite: false
        });
        const mesh = new THREE.Mesh(geom, mat);
        mesh.position.copy(pos);

        // „Ç´„É°„É©„ÅÆÊñπÂêë„ÇíÂêë„Åè„Çà„ÅÜ„Å´ÂõûËª¢
mesh.lookAt(camera.position);
        
        mesh.renderOrder = 9999;
        mesh.userData = mesh.userData || {};
        mesh.userData.aspect = aspect;
        scene.add(mesh);
        return mesh;
    }
    // ---------- „Åì„Åì„Åæ„ÅßÊúÄÂ∞è‰øÆÊ≠£Áâà„ÅÆÊú¨‰Ωì ----------

    function initSpeechRecognition() {
        if('webkitSpeechRecognition' in window||'SpeechRecognition' in window) {
            const SR=window.SpeechRecognition||window.webkitSpeechRecognition;
            recognition=new SR();
            recognition.lang='ja-JP';
            recognition.continuous=false;
            recognition.interimResults=false;
        } else {
            document.getElementById('voiceButton').disabled=true;
            document.getElementById('voiceButton').textContent='üé§ ÈùûÂØæÂøú';
        }
    }

    let currentMemoPosition=null;

    function startVoiceInputForMemo(pos) {
        if(!recognition||isRecording)return;
        currentMemoPosition=pos;
        isRecording=true;
        document.getElementById('voiceButton').classList.add('recording');
        document.getElementById('voiceButton').textContent='üé§ Èå≤Èü≥‰∏≠...';
        recognition.onresult=ev=>{
            const transcript=ev.results[0][0].transcript;
            createMemo(currentMemoPosition,transcript);
            isRecording=false;
            document.getElementById('voiceButton').classList.remove('recording');
            document.getElementById('voiceButton').textContent='üé§ Èü≥Â£∞ÂÖ•Âäõ';
        };
        recognition.onerror=(err)=>{
            console.error('recognition error', err);
            isRecording=false;
            document.getElementById('voiceButton').classList.remove('recording');
            document.getElementById('voiceButton').textContent='üé§ Èü≥Â£∞ÂÖ•Âäõ';
        };
        try {
            recognition.start();
        } catch (e) {
            console.warn('recognition start error', e);
            isRecording = false;
            document.getElementById('voiceButton').classList.remove('recording');
            document.getElementById('voiceButton').textContent='üé§ Èü≥Â£∞ÂÖ•Âäõ';
        }
    }

    function toggleVoiceInput() {
        if(!recognition)return;
        if(isRecording) {
            try{ recognition.stop(); }catch(e){}
            isRecording=false;
            document.getElementById('voiceButton').classList.remove('recording');
            document.getElementById('voiceButton').textContent='üé§ Èü≥Â£∞ÂÖ•Âäõ';
            return;
        }
        const dir=new THREE.Vector3();
        camera.getWorldDirection(dir);
        const pos=camera.position.clone().add(dir.multiplyScalar(3));
        startVoiceInputForMemo(pos);
    }

    window.deleteMemo=deleteMemo;

    function onWindowResize() {
        camera.aspect=window.innerWidth/window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth,window.innerHeight);
    }

    function handleVRControllers(delta) {
        const session=renderer.xr.getSession();
        if(!session) {
            updateVRDebugPanel('No VR session\nFOV: '+zoomLevel.toFixed(1));
            return;
        }
        if(!session.inputSources||session.inputSources.length===0) {
            updateVRDebugPanel('No input sources\nFOV: '+zoomLevel.toFixed(1));
            return;
        }
        let debugInfo=['VR Debug',''];
        debugInfo.push('=== MEMO MODE: ALWAYS ON ===');
        debugInfo.push(`FOV: ${zoomLevel.toFixed(1)} (${MIN_FOV}-${MAX_FOV})`);
        debugInfo.push('');

        for(let i=0;i<session.inputSources.length;i++) {
            const inputSource=session.inputSources[i];
            const gamepad=inputSource.gamepad;
            if(!gamepad) {
                debugInfo.push(`${inputSource.handedness}: No gamepad`);
                continue;
            }

            const axesStr=gamepad.axes.map((v,idx)=>`${idx}:${v.toFixed(2)}`).join(' ');
            debugInfo.push(`${inputSource.handedness}:`);
            debugInfo.push(`  axes: ${axesStr}`);
            const pressedButtons=[];
            for(let btnIdx=0;btnIdx<gamepad.buttons.length;btnIdx++) {
                if(gamepad.buttons[btnIdx].pressed) pressedButtons.push(btnIdx);
            }
            debugInfo.push(`  btns: ${pressedButtons.length>0?pressedButtons.join(','):'none'}`);

            if(inputSource.handedness==='left') {
                let moveX=0,moveZ=0;
                if(Math.abs(gamepad.axes[0])>0.05)moveX=gamepad.axes[0];
                if(Math.abs(gamepad.axes[1])>0.05)moveZ=-gamepad.axes[1];
                if(Math.abs(gamepad.axes[2])>0.05)moveX=gamepad.axes[2];
                if(Math.abs(gamepad.axes[3])>0.05)moveZ=-gamepad.axes[3];
                debugInfo.push(`  moveX:${moveX.toFixed(3)} moveZ:${moveZ.toFixed(3)}`);
                if(Math.abs(moveX)>0.05||Math.abs(moveZ)>0.05) {
                    const cameraWorldQuaternion=new THREE.Quaternion();
                    camera.getWorldQuaternion(cameraWorldQuaternion);
                    const forward=new THREE.Vector3(0,0,-1);
                    forward.applyQuaternion(cameraWorldQuaternion);
                    forward.y=0;
                    forward.normalize();
                    const right=new THREE.Vector3(1,0,0);
                    right.applyQuaternion(cameraWorldQuaternion);
                    right.y=0;
                    right.normalize();
                    const moveVector=new THREE.Vector3();
                    moveVector.add(forward.multiplyScalar(moveZ*VR_MOVE_SPEED*delta));
                    moveVector.add(right.multiplyScalar(moveX*VR_MOVE_SPEED*delta));
                    cameraRig.position.x+=moveVector.x;
                    cameraRig.position.z+=moveVector.z;
                    debugInfo.push(`  *** MOVING! ***`);
                }

                const btn4Pressed=gamepad.buttons[4]&&gamepad.buttons[4].pressed;
                if(btn4Pressed) {
                    if(!xButtonCooldown) {
                        if(xButtonPressTime===0) {
                            xButtonPressTime=performance.now();
                            debugInfo.push(`  Btn4 START press`);
                        } else {
                            const pressDuration=performance.now()-xButtonPressTime;
                            debugInfo.push(`  Btn4 holding... ${(pressDuration/1000).toFixed(1)}s`);
                            if(pressDuration>500) {
                                vrMemoMode=!vrMemoMode;
                                debugInfo.push(`  *** MEMO MODE: ${vrMemoMode?'ON':'OFF'} ***`);
                                xButtonCooldown=true;
                                xButtonPressTime=0;
                            }
                        }
                    } else {
                        debugInfo.push(`  Btn4 (cooldown)`);
                    }
                } else {
                    xButtonPressTime=0;
                    xButtonCooldown=false;
                }

                for(let btnIdx=0;btnIdx<gamepad.buttons.length;btnIdx++) {
                    if(gamepad.buttons[btnIdx].pressed&&btnIdx!==4) {
                        if(btnIdx===0) {
                            cameraRig.position.y+=VR_MOVE_SPEED*delta;
                            debugInfo.push(`  UP!`);
                        } else if(btnIdx===1) {
                            cameraRig.position.y-=VR_MOVE_SPEED*delta;
                            if(cameraRig.position.y<0)cameraRig.position.y=0;
                            debugInfo.push(`  DOWN!`);
                        }
                    }
                }
            }

           if(inputSource.handedness==='right') {
    const axes=gamepad.axes;
    if(axes.length>=4) {
        const rotX=axes[2]||0;
        const rotY=axes[3]||0;
        if(Math.abs(rotX)>0.1) {
            cameraRig.rotation.y-=rotX*VR_ROTATION_SPEED*delta;
            debugInfo.push(`  Rotating Y: ${rotX.toFixed(2)}`);
        }
        if(Math.abs(rotY)>0.1) {
            camera.rotation.x-=rotY*VR_ROTATION_SPEED*delta;
            camera.rotation.x=Math.max(-Math.PI/3,Math.min(Math.PI/3,camera.rotation.x));
            debugInfo.push(`  Rotating X: ${rotY.toFixed(2)}`);
        }
    }

    // „Éõ„Éê„ÉºÊ§úÂá∫Ôºà„Åì„Åì„Å´ËøΩÂä†Ôºâ
    try {
        const raycaster = new THREE.Raycaster();
        const controllerWorldPos = new THREE.Vector3();
        const controllerWorldQuat = new THREE.Quaternion();
        controllers[1].getWorldPosition(controllerWorldPos);
        controllers[1].getWorldQuaternion(controllerWorldQuat);
        const direction = new THREE.Vector3(0, 0, -1).applyQuaternion(controllerWorldQuat);
        raycaster.set(controllerWorldPos, direction);
        raycaster.near = 0.01;
        raycaster.far = 20;
        const memoObjs = memos.map(m => m.sprite).filter(Boolean);
        const hits = raycaster.intersectObjects(memoObjs, false);
        
        // ÂâçÂõû„Éõ„Éê„Éº„Åó„Å¶„ÅÑ„Åü„É°„É¢„ÇíÂÖÉ„Å´Êàª„Åô
        if(hoveredMemo && hoveredMemo.hoverFrame) {
            scene.remove(hoveredMemo.hoverFrame);
            delete hoveredMemo.hoverFrame;
            hoveredMemo = null;
        }
        
        // Êñ∞„Åó„Åè„Éõ„Éê„Éº„Åó„Å¶„ÅÑ„Çã„É°„É¢„Å´„Éè„Ç§„É©„Ç§„Éà„ÇíËøΩÂä†
if(hits.length > 0) {
    const hitObj = hits[0].object;
    const memo = memos.find(m => m.sprite === hitObj);
    if(memo && memo !== editingMemo) { // Á∑®ÈõÜ‰∏≠„Åß„Å™„ÅÑ„É°„É¢„ÅÆ„Åø
        hoveredMemo = memo;
        const hoverFrame = new THREE.Mesh(
            new THREE.PlaneGeometry(memo.sprite.geometry.parameters.width * 1.1, memo.sprite.geometry.parameters.height * 1.1),
            new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.3, side: THREE.DoubleSide }) // „Ç∑„Ç¢„É≥Ëâ≤
        );
        hoverFrame.position.copy(memo.sprite.position);
        
        // „É°„É¢„Å®Âêå„ÅòÂêë„Åç„Å´„Åô„Çã
        hoverFrame.rotation.copy(memo.sprite.rotation);
        
        hoverFrame.position.z -= 0.005;
        hoverFrame.name = 'hoverFrame';
        scene.add(hoverFrame);
        memo.hoverFrame = hoverFrame;
        debugInfo.push(`  >>> HOVERING MEMO #${memo.id} <<<`);
    }
}
    } catch(e) {
        console.error('Hover detection error', e);
    }

    // „Åì„Åì„Åã„ÇâÂè≥„Éà„É™„Ç¨„ÉºÂá¶ÁêÜÔºàÊó¢Â≠ò„ÅÆ„Ç≥„Éº„ÉâÔºâ
 // „Éú„Çø„É≥1ÔºàB„Éú„Çø„É≥Ôºâ„ÅßÂâäÈô§
const btn1=gamepad.buttons[1];
const isBtn1Pressed=btn1&&btn1.pressed;
if(isBtn1Pressed&&!btn1WasPressed) {
    // ÂâäÈô§Á¢∫Ë™ç„Éë„Éç„É´„ÅåË°®Á§∫„Åï„Çå„Å¶„ÅÑ„Å™„ÅÑÂ†¥Âêà„ÅÆ„ÅøÂÆüË°å
    const confirmPanel = scene.getObjectByName('deleteConfirmPanel');
    if(hoveredMemo && !confirmPanel) {
        debugInfo.push(`  >>> BTN1: DELETING MEMO #${hoveredMemo.id} <<<`);
        showVRDeleteConfirm(hoveredMemo);
    }
}
btn1WasPressed=isBtn1Pressed;

               const triggerBtn=gamepad.buttons[0];
const isTriggerPressed=triggerBtn&&triggerBtn.pressed;

if(isTriggerPressed&&!rightTriggerPressed) {
    rightTriggerPressTime=performance.now();
    debugInfo.push(`  Trigger DOWN! vrMemoMode=${vrMemoMode}`);
    rightTriggerPressed=true;
} else if(isTriggerPressed&&rightTriggerPressed) {
    const pressDuration=performance.now()-rightTriggerPressTime;
    debugInfo.push(`  Trigger HELD ${(pressDuration/1000).toFixed(1)}s`);
    if(pressDuration>500 && rightTriggerPressTime > 0) {
        debugInfo.push(`  >>> CHECKING FOR MEMO TO EDIT <<<`);
        checkAndEditMemo(controllers[1]);
        rightTriggerPressTime = -1;
    }
} else if(!isTriggerPressed&&rightTriggerPressed) {
    const pressDuration = rightTriggerPressTime > 0 ? performance.now()-rightTriggerPressTime : 1000;
    debugInfo.push(`  Trigger UP after ${(pressDuration/1000).toFixed(1)}s`);
    
    if(pressDuration<500) {
    // Áü≠Êäº„Åó„Åß„É°„É¢ÈÖçÁΩÆ
    debugInfo.push(`  >>> PLACING MEMO <<<`);
    placeVRMemo();
}
    rightTriggerPressed=false;
    rightTriggerPressTime=0;
}

                
            }
            debugInfo.push('');
        }

        debugInfo.push(`CamRig: ${cameraRig.position.x.toFixed(1)}, ${cameraRig.position.y.toFixed(1)}, ${cameraRig.position.z.toFixed(1)}`);
        updateVRDebugPanel(debugInfo.join('\n'));
    }

   function placeVRMemo() {
    try {
        const rightController = controllers[1];
        if (!rightController) {
            console.warn('Right controller not available');
            return;
        }
        const controllerWorldPos = new THREE.Vector3();
        rightController.getWorldPosition(controllerWorldPos);
        const direction = new THREE.Vector3(0, 0, -1);
        const controllerWorldQuat = new THREE.Quaternion();
        rightController.getWorldQuaternion(controllerWorldQuat);
        direction.applyQuaternion(controllerWorldQuat);
        const position = controllerWorldPos.clone().add(direction.multiplyScalar(2));
        const timestamp = new Date().toLocaleTimeString('ja-JP');
        const memoText = `VR„É°„É¢ ${timestamp}`;
        
        // „É°„É¢„Çí‰ΩúÊàê„Åó„Å¶„Ç≥„É≥„Éà„É≠„Éº„É©„Éº„ÅÆÊñπ„ÇíÂêë„Åë„Çã
        createMemo(position, memoText, controllerWorldPos);
    } catch(error) {
        console.error('Error in placeVRMemo:', error);
    }
}

    // Raycast check for memos (works with mesh planes)
    function checkAndEditMemo(controller) {
        try {
            const raycaster = new THREE.Raycaster();
            const controllerWorldPos = new THREE.Vector3();
            const controllerWorldQuat = new THREE.Quaternion();
            controller.getWorldPosition(controllerWorldPos);
            controller.getWorldQuaternion(controllerWorldQuat);
            const direction = new THREE.Vector3(0, 0, -1).applyQuaternion(controllerWorldQuat);
            raycaster.set(controllerWorldPos, direction);
            // ensure reasonable near/far
            raycaster.near = 0.01;
            raycaster.far = 20;
            const memoObjs = memos.map(m => m.sprite).filter(Boolean);
            const hits = raycaster.intersectObjects(memoObjs, false);
            if(hits.length > 0) {
                const hitObj = hits[0].object;
                const memo = memos.find(m => m.sprite === hitObj);
                if(memo) startEditMemo(memo);
                else console.warn('Hit object but no memo found');
            } else {
                // nothing hit
            }
        } catch(error) {
            console.error('Error in checkAndEditMemo:', error);
        }
    }

    

function startEditMemo(memo) {
    if(!recognition) {
        document.getElementById('status').textContent = 'Èü≥Â£∞Ë™çË≠ò„ÅåÂà©Áî®„Åß„Åç„Åæ„Åõ„Çì';
        return;
    }
    
    // Ââç„ÅÆÁ∑®ÈõÜ‰∏≠„ÅÆ„É°„É¢„ÅÆÊû†„ÇíÂâäÈô§
    if(editingMemo && editingMemo.editFrame) {
        scene.remove(editingMemo.editFrame);
        delete editingMemo.editFrame;
    }
    
    editingMemo = memo;
    const frame = new THREE.Mesh(
        new THREE.PlaneGeometry(memo.sprite.geometry.parameters.width * 1.15, memo.sprite.geometry.parameters.height * 1.15),
        new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.4, side: THREE.DoubleSide })
    );
    frame.position.copy(memo.sprite.position);
    
    // „É°„É¢„Å®Âêå„ÅòÂêë„Åç„Å´„Åô„Çã
    frame.rotation.copy(memo.sprite.rotation);
    
    frame.position.z -= 0.01;
    frame.name = 'editFrame';
    scene.add(frame);
    memo.editFrame = frame;


    recognition.onresult = ev => {
        const transcript = ev.results[0][0].transcript;
        if(editingMemo.editFrame) {
            scene.remove(editingMemo.editFrame);
            delete editingMemo.editFrame;
        }
        if (editingMemo.sprite) scene.remove(editingMemo.sprite);
        const newMesh = createMemoSprite(editingMemo.position, transcript);
        editingMemo.sprite = newMesh;
        editingMemo.text = transcript;
        updateMemoList();
        editingMemo = null;
        document.getElementById('status').textContent = '„É°„É¢„ÇíÊõ¥Êñ∞„Åó„Åæ„Åó„Åü';
    };

    recognition.onerror = (e) => {
        console.error('Voice recognition error during edit', e);
        if(editingMemo && editingMemo.editFrame) {
            scene.remove(editingMemo.editFrame);
            delete editingMemo.editFrame;
        }
        editingMemo = null;
        document.getElementById('status').textContent = 'Èü≥Â£∞Ë™çË≠ò„Ç®„É©„Éº';
    };

    try {
        recognition.start();
    } catch (e) {
        console.error('recognition.start error', e);
    }
}
    function createMemoSprite(pos, txt) {
        // returns a Mesh plane (same as in createMemo)
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 512;
        ctx.font = 'bold 32px Arial';
        const lines = [];
        txt.split('\n').forEach(para => {
            const words = para.split(' ');
            let line = '';
            words.forEach(word => {
                const test = line + word + ' ';
                if(ctx.measureText(test).width > 472 && line !== '') {
                    lines.push(line.trim());
                    line = word + ' ';
                } else {
                    line = test;
                }
            });
            lines.push(line.trim());
        });
        canvas.height = (lines.length * 40) + 40;
        ctx.fillStyle = '#ffd93d';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#000';
        ctx.font = 'bold 32px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';
        let y = 20;
        lines.forEach(line => {
            ctx.fillText(line, 256, y);
            y += 40;
        });
        const tex = new THREE.CanvasTexture(canvas);
        tex.minFilter = THREE.LinearFilter;

        const aspect = canvas.height / canvas.width;
        const baseWidth = 0.6;
        const baseHeight = baseWidth * aspect;
        const geom = new THREE.PlaneGeometry(baseWidth, baseHeight);
        const mat = new THREE.MeshBasicMaterial({
            map: tex,
            transparent: true,
            side: THREE.DoubleSide,
            depthTest: false,
            depthWrite: false
        });
        const mesh = new THREE.Mesh(geom, mat);
        mesh.position.copy(pos);
        mesh.renderOrder = 9999;
        mesh.userData = mesh.userData || {};
        mesh.userData.aspect = aspect;
        scene.add(mesh);
        return mesh;
    }

        function showVRDeleteConfirm(memo) {
    pendingDeleteMemo = memo;
    const confirmPanel = new THREE.Group();
    confirmPanel.name = 'deleteConfirmPanel';
    
    const bgCanvas = document.createElement('canvas');
    bgCanvas.width = 512;
    bgCanvas.height = 256;
    const ctx = bgCanvas.getContext('2d');
    ctx.fillStyle = 'rgba(0,0,0,0.95)';
    ctx.fillRect(0, 0, 512, 256);
    ctx.strokeStyle = '#ff0000';
    ctx.lineWidth = 4;
    ctx.strokeRect(0, 0, 512, 256);
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 32px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('„Åì„ÅÆ„É°„É¢„ÇíÂâäÈô§„Åó„Åæ„Åô„Åã?', 256, 60);
    ctx.font = 'bold 24px Arial';
    ctx.fillStyle = '#ff0000';
    ctx.fillText('A„Éú„Çø„É≥: ÂâäÈô§', 256, 130);
    ctx.fillStyle = '#00ff00';
    ctx.fillText('B„Éú„Çø„É≥: „Ç≠„É£„É≥„Çª„É´', 256, 170);
    
    const bgTex = new THREE.CanvasTexture(bgCanvas);
    const bgMesh = new THREE.Mesh(
        new THREE.PlaneGeometry(1.5, 0.75),
        new THREE.MeshBasicMaterial({ map: bgTex, transparent: true, side: THREE.DoubleSide })
    );
    confirmPanel.add(bgMesh);
    
    const cameraWorldPos = new THREE.Vector3();
    camera.getWorldPosition(cameraWorldPos);
    const cameraWorldDir = new THREE.Vector3();
    camera.getWorldDirection(cameraWorldDir);
    confirmPanel.position.copy(cameraWorldPos).add(cameraWorldDir.multiplyScalar(2));
    confirmPanel.lookAt(cameraWorldPos);
    confirmPanel.renderOrder = 10000;
    
    scene.add(confirmPanel);
}

function handleDeleteConfirmInput(session) {
    const panel = scene.getObjectByName('deleteConfirmPanel');
    if(!panel || !pendingDeleteMemo) return;
    
    for(let i = 0; i < session.inputSources.length; i++) {
        const inputSource = session.inputSources[i];
        const gamepad = inputSource.gamepad;
        if(!gamepad) continue;
        
        // Âè≥„Ç≥„É≥„Éà„É≠„Éº„É©„Éº„ÅÆA„Éú„Çø„É≥Ôºà„Éú„Çø„É≥4Ôºâ„ÅßÂâäÈô§
        if(inputSource.handedness === 'right') {
            const aButton = gamepad.buttons[4];
            if(aButton && aButton.pressed) {
                // „Éõ„Éê„ÉºÊû†„ÇíÂâäÈô§
                if(pendingDeleteMemo.hoverFrame) {
                    scene.remove(pendingDeleteMemo.hoverFrame);
                    delete pendingDeleteMemo.hoverFrame;
                }
                
                // „É°„É¢„ÇíÂâäÈô§
                deleteMemo(pendingDeleteMemo.id);
                scene.remove(panel);
                pendingDeleteMemo = null;
                hoveredMemo = null;
                document.getElementById('status').textContent = '„É°„É¢„ÇíÂâäÈô§„Åó„Åæ„Åó„Åü';
                return;
            }
        }
        
        // Âè≥„Ç≥„É≥„Éà„É≠„Éº„É©„Éº„ÅÆB„Éú„Çø„É≥Ôºà„Éú„Çø„É≥5Ôºâ„Åß„Ç≠„É£„É≥„Çª„É´
        if(inputSource.handedness === 'right') {
            const bButton = gamepad.buttons[5];
            if(bButton && bButton.pressed) {
                scene.remove(panel);
                pendingDeleteMemo = null;
                document.getElementById('status').textContent = 'ÂâäÈô§„Çí„Ç≠„É£„É≥„Çª„É´„Åó„Åæ„Åó„Åü';
                return;
            }
        }
    }
}
    function animate() {
    const time=performance.now();
    const delta=(time-prevTime)/1000;
    if(renderer.xr.isPresenting) {
        const session = renderer.xr.getSession();
        if(session) {
            handleDeleteConfirmInput(session);  // ‚Üê ËøΩÂä†
        }
        handleVRControllers(delta);
    } else {
            velocity.x-=velocity.x*10*delta;
            velocity.z-=velocity.z*10*delta;
            direction.z=Number(moveBackward)-Number(moveForward);
            direction.x=Number(moveLeft)-Number(moveRight);
            direction.normalize();
            if(moveForward||moveBackward)velocity.z-=direction.z*MOVE_SPEED*delta;
            if(moveLeft||moveRight)velocity.x-=direction.x*MOVE_SPEED*delta;
            const forward=new THREE.Vector3(0,0,-1);
            forward.applyQuaternion(camera.quaternion);
            forward.y=0;
            forward.normalize();
            const right=new THREE.Vector3(1,0,0);
            right.applyQuaternion(camera.quaternion);
            right.y=0;
            right.normalize();
            camera.position.add(forward.multiplyScalar(velocity.z*delta));
            camera.position.add(right.multiplyScalar(velocity.x*delta));
            if(camera.position.y<PLAYER_HEIGHT) camera.position.y=PLAYER_HEIGHT;
        }
        prevTime=time;
        renderer.render(scene,camera);
    }

    init();
    </script>
</body>
</html>
