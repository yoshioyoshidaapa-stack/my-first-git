<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VR GLB„Ç∑„Éß„ÉÉ„Éó„Ç¶„Ç©„Éº„ÇØ„Çπ„É´„Éº</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        #container {
            width: 100vw;
            height: 100vh;
            cursor: grab;
        }
        #container:active {
            cursor: grabbing;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            font-size: 14px;
            max-width: 320px;
            z-index: 100;
        }
        #controls {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid rgba(255, 255, 255, 0.3);
        }
        #fileInput {
            margin-top: 10px;
            padding: 8px;
            background: rgba(255, 255, 255, 0.9);
            border: none;
            border-radius: 4px;
            cursor: pointer;
            width: 100%;
        }
        #vrButton {
            margin-top: 10px;
            padding: 12px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            width: 100%;
            font-size: 16px;
            font-weight: bold;
        }
        #vrButton:hover {
            background: #45a049;
        }
        #vrButton:disabled {
            background: #cccccc;
            cursor: not-allowed;
        }
        #resetButton {
            margin-top: 10px;
            padding: 10px;
            background: #ff9800;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            width: 100%;
            font-size: 14px;
            font-weight: bold;
        }
        #resetButton:hover {
            background: #e68900;
        }
        #clearButton {
            margin-top: 5px;
            padding: 10px;
            background: #f44336;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            width: 100%;
            font-size: 14px;
            font-weight: bold;
        }
        #clearButton:hover {
            background: #da190b;
        }
        #scaleControls {
            margin-top: 10px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
        }
        #scaleSlider {
            width: 100%;
            margin: 10px 0;
        }
        #scaleValue {
            color: #aaffaa;
            font-weight: bold;
        }
        .scaleButtons {
            display: flex;
            gap: 5px;
            margin-top: 5px;
        }
        .scaleButtons button {
            flex: 1;
            padding: 8px;
            background: #2196F3;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }
        .scaleButtons button:hover {
            background: #0b7dda;
        }
        #memoPanel {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 300px;
            max-height: 80vh;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px;
            border-radius: 8px;
            display: none;
            z-index: 100;
        }
        #memoPanel h3 {
            margin-top: 0;
            border-bottom: 2px solid #4CAF50;
            padding-bottom: 10px;
        }
        #memoList {
            margin-top: 10px;
        }
        .memo-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 10px;
            margin: 5px 0;
            border-radius: 4px;
            border-left: 4px solid #4CAF50;
        }
        .memo-item.priority-high {
            border-left-color: #f44336;
        }
        .memo-item.priority-normal {
            border-left-color: #ffeb3b;
        }
        .memo-item.priority-low {
            border-left-color: #4CAF50;
        }
        .memo-item button {
            margin-top: 5px;
            padding: 4px 8px;
            font-size: 11px;
            cursor: pointer;
            background: #f44336;
            color: white;
            border: none;
            border-radius: 3px;
        }
        #memoModeIndicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(76, 175, 80, 0.9);
            color: white;
            padding: 20px 40px;
            border-radius: 8px;
            font-size: 20px;
            font-weight: bold;
            display: none;
            z-index: 1000;
            pointer-events: none;
        }
        #voiceButton {
            margin-top: 10px;
            padding: 12px;
            background: #9C27B0;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            width: 100%;
            font-size: 16px;
            font-weight: bold;
        }
        #voiceButton:hover {
            background: #7B1FA2;
        }
        #voiceButton.recording {
            background: #f44336;
            animation: pulse 1s infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        #inputMethodDialog {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 30px;
            border-radius: 12px;
            display: none;
            z-index: 2000;
            box-shadow: 0 8px 32px rgba(0,0,0,0.5);
        }
        #inputMethodDialog h3 {
            color: white;
            margin: 0 0 20px 0;
            text-align: center;
        }
        .input-method-buttons {
            display: flex;
            gap: 15px;
        }
        .input-method-buttons button {
            padding: 20px 30px;
            font-size: 18px;
            font-weight: bold;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: transform 0.2s;
        }
        .input-method-buttons button:hover {
            transform: scale(1.05);
        }
        #voiceInputBtn {
            background: #9C27B0;
            color: white;
        }
        #keyboardInputBtn {
            background: #2196F3;
            color: white;
        }
        #memoInputDialog {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 30px;
            border-radius: 12px;
            display: none;
            z-index: 2001;
            box-shadow: 0 8px 32px rgba(0,0,0,0.5);
            width: 400px;
        }
        #memoInputDialog h3 {
            color: white;
            margin: 0 0 15px 0;
            text-align: center;
        }
        #memoTextarea {
            width: 100%;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            resize: vertical;
            font-size: 14px;
            box-sizing: border-box;
            background: #222;
            color: white;
            min-height: 100px;
        }
        .dialog-buttons {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }
        #submitMemoBtn {
            flex: 1;
            background: #4CAF50;
            color: white;
            padding: 12px 20px;
            font-weight: bold;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        #submitMemoBtn:hover {
            background: #45a049;
        }
        #cancelMemoBtn {
            flex: 1;
            background: #666;
            color: white;
            padding: 12px 20px;
            font-weight: bold;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        #cancelMemoBtn:hover {
            background: #555;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px 40px;
            border-radius: 8px;
            font-size: 18px;
            display: none;
            z-index: 1000;
        }
        #status {
            margin-top: 10px;
            font-size: 12px;
            color: #aaffaa;
        }
    </style>
</head>
<body>
    <div id="container"></div>
    <div id="info">
        <strong>VR „Ç∑„Éß„ÉÉ„Éó„Ç¶„Ç©„Éº„ÇØ„Çπ„É´„Éº</strong><br>
        <small id="updateDate" style="color: #aaa;"></small>
        <div id="controls">
            <strong>PCÊìç‰ΩúÔºö</strong><br>
            W/‚Üë : ÂâçÈÄ≤<br>
            S/‚Üì : ÂæåÈÄÄ<br>
            A/‚Üê : Â∑¶ÁßªÂãï<br>
            D/‚Üí : Âè≥ÁßªÂãï<br>
            „Éû„Ç¶„Çπ„Éâ„É©„ÉÉ„Ç∞ : Ë¶ñÁÇπÂõûËª¢<br>
            „Éû„Ç¶„Çπ„Éõ„Ç§„Éº„É´ : „Ç∫„Éº„É†<br>
            Q/E : „Ç∫„Éº„É†„Ç§„É≥/„Ç¢„Ç¶„Éà<br>
            <br>
            <strong>VRÊìç‰ΩúÔºö</strong><br>
            È†≠„ÅÆÂêë„Åç : Ë¶ñÁÇπÂõûËª¢<br>
            Â∑¶„Çπ„ÉÜ„Ç£„ÉÉ„ÇØ : ÁßªÂãï<br>
            A„Éú„Çø„É≥ : ‰∏äÊòá<br>
            B„Éú„Çø„É≥ : ‰∏ãÈôç<br>
            Âè≥„Ç∞„É™„ÉÉ„Éó : „Ç∫„Éº„É†„Ç§„É≥<br>
            Âè≥„Éà„É™„Ç¨„Éº : „Ç∫„Éº„É†„Ç¢„Ç¶„Éà<br>
            X„Éú„Çø„É≥Èï∑Êäº„Åó : „É°„É¢„É¢„Éº„ÉâÂàáÊõø<br>
            Âè≥„Éà„É™„Ç¨„Éº(„É°„É¢ÊôÇ) : „É°„É¢ÈÖçÁΩÆ<br>
            <br>
            <strong>„É°„É¢Ê©üËÉΩÔºö</strong><br>
            M„Ç≠„Éº : „É°„É¢„É¢„Éº„ÉâÂàáÊõø<br>
            „ÇØ„É™„ÉÉ„ÇØ : „É°„É¢ÈÖçÁΩÆ<br>
            Èü≥Â£∞ÂÖ•Âäõ : ÂØæÂøú
        </div>
        <input type="file" id="fileInput" accept=".glb,.gltf,.obj,.fbx,.stl,.dae,.ply" />
        <button id="vrButton">VR„É¢„Éº„ÉâÈñãÂßã</button>
        <button id="resetButton">„Ç´„É°„É©‰ΩçÁΩÆ„É™„Çª„ÉÉ„Éà</button>
        <button id="clearButton">„É¢„Éá„É´ÂâäÈô§</button>
        <div id="scaleControls">
            <strong>„É¢„Éá„É´„Çµ„Ç§„Ç∫Ë™øÊï¥</strong><br>
            <span id="scaleValue">ÂÄçÁéá: 1.0x</span>
            <input type="range" id="scaleSlider" min="0.1" max="10" step="0.1" value="1.0">
            <div class="scaleButtons">
                <button id="scale05">0.5x</button>
                <button id="scale1">1.0x</button>
                <button id="scale2">2.0x</button>
                <button id="scale5">5.0x</button>
            </div>
        </div>
        <div id="status"></div>
    </div>
    <div id="loading">Ë™≠„ÅøËæº„Åø‰∏≠...</div>
    <div id="memoModeIndicator">„É°„É¢„É¢„Éº„Éâ ON</div>
    <div id="memoPanel">
        <h3>„É°„É¢„É™„Çπ„Éà</h3>
        <button id="voiceButton">üé§ Èü≥Â£∞ÂÖ•Âäõ„Åß„É°„É¢ËøΩÂä†</button>
        <div id="memoList"></div>
    </div>
    <div id="inputMethodDialog">
        <h3>„É°„É¢„ÅÆÂÖ•ÂäõÊñπÊ≥ï„ÇíÈÅ∏Êäû</h3>
        <div class="input-method-buttons">
            <button id="voiceInputBtn">üé§ Èü≥Â£∞ÂÖ•Âäõ</button>
            <button id="keyboardInputBtn">‚å® „Ç≠„Éº„Éú„Éº„ÉâÂÖ•Âäõ</button>
        </div>
    </div>
    <div id="memoInputDialog">
        <h3>„É°„É¢„ÇíÂÖ•Âäõ</h3>
        <textarea id="memoTextarea" placeholder="Ë§áÊï∞Ë°å„ÅÆ„É°„É¢„ÇíÂÖ•Âäõ„Åß„Åç„Åæ„Åô...&#10;ÊîπË°å„ÇÇÂèØËÉΩ„Åß„Åô"></textarea>
        <div class="dialog-buttons">
            <button id="submitMemoBtn">„É°„É¢„Çí‰ΩúÊàê</button>
            <button id="cancelMemoBtn">„Ç≠„É£„É≥„Çª„É´</button>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/OBJLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/FBXLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/STLLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/ColladaLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/PLYLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/webxr/VRButton.js"></script>

    <script>
        let scene, camera, renderer;
        let moveForward = false, moveBackward = false;
        let moveLeft = false, moveRight = false;
        let canJump = false;
        let velocity = new THREE.Vector3();
        let direction = new THREE.Vector3();
        let prevTime = performance.now();
        let euler = new THREE.Euler(0, 0, 0, 'YXZ');
        let isMouseDown = false;
        let lastMouseX = 0;
        let lastMouseY = 0;
        let zoomLevel = 75;
        const MIN_FOV = 30;
        const MAX_FOV = 100;
        let modelScale = 1.0;
        
        const PLAYER_HEIGHT = 1.6;
        const MOVE_SPEED = 80.0;
        const VR_MOVE_SPEED = 15.0; // 5.0„ÅÆ3ÂÄç
        const JUMP_VELOCITY = 8.0;
        const GRAVITY = 20.0;

        const statusEl = document.getElementById('status');
        let controllers = [];
        let isVRMode = false;
        const INITIAL_CAMERA_POS = { x: 0, y: PLAYER_HEIGHT, z: 5 };
        const INITIAL_ZOOM = 75;
        let memoMode = false;
        let memos = [];
        let memoCounter = 0;
        let recognition = null;
        let isRecording = false;
        let pendingMemoPosition = null;
        let vrMemoMode = false;
        let xButtonPressTime = 0;
        let vrDebugText = null;
        let vrDebugCanvas = null;
        let cameraRig = null; // VRÁî®„ÅÆ„Ç´„É°„É©„É™„Ç∞
        
        // „Éê„Éº„Ç∏„Éß„É≥Áï™Âè∑„ÅßÁÆ°ÁêÜÔºàÊâãÂãïÊõ¥Êñ∞Ôºâ
        const VERSION = 'v1.0.7';
        const UPDATE_DATE = '2025/01/27 17:30';

        function updateStatus(msg) {
            statusEl.textContent = msg;
            console.log(msg);
        }

        function init() {
            updateStatus('ÂàùÊúüÂåñ‰∏≠...');

            // „Éê„Éº„Ç∏„Éß„É≥„Å®Êõ¥Êñ∞Êó•ÊôÇ„ÇíË°®Á§∫
            document.getElementById('updateDate').textContent = `${VERSION} (${UPDATE_DATE})`;

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 0, 50);

            // VRÁî®„Ç´„É°„É©„É™„Ç∞„Çí‰ΩúÊàê
            cameraRig = new THREE.Group();
            scene.add(cameraRig);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, PLAYER_HEIGHT, 5);
            cameraRig.add(camera); // „Ç´„É°„É©„Çí„É™„Ç∞„ÅÆÂ≠ê„Å´„Åô„Çã

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.xr.enabled = true;
            document.getElementById('container').appendChild(renderer.domElement);

            const vrButton = document.getElementById('vrButton');
            if ('xr' in navigator) {
                navigator.xr.isSessionSupported('immersive-vr').then((supported) => {
                    if (supported) {
                        vrButton.onclick = async () => {
                            if (!renderer.xr.isPresenting) {
                                try {
                                    const session = await navigator.xr.requestSession('immersive-vr', {
                                        optionalFeatures: ['local-floor', 'bounded-floor']
                                    });
                                    await renderer.xr.setSession(session);
                                    isVRMode = true;
                                    updateStatus('VR„É¢„Éº„ÉâËµ∑ÂãïÊàêÂäü');
                                } catch (error) {
                                    console.error('VR„Çª„ÉÉ„Ç∑„Éß„É≥ÈñãÂßã„Ç®„É©„Éº:', error);
                                    updateStatus('VR„É¢„Éº„ÉâËµ∑Âãï„Ç®„É©„Éº: ' + error.message);
                                }
                            }
                        };
                        updateStatus('VRÂØæÂøú„Éá„Éê„Ç§„Çπ„ÇíÊ§úÂá∫');
                    } else {
                        vrButton.disabled = true;
                        vrButton.textContent = 'VRÈùûÂØæÂøú';
                        updateStatus('VRÈùûÂØæÂøú„Éñ„É©„Ç¶„Ç∂');
                    }
                });
            } else {
                vrButton.disabled = true;
                vrButton.textContent = 'VRÈùûÂØæÂøú';
            }

            const controller1 = renderer.xr.getController(0);
            controller1.addEventListener('connected', (event) => {
                updateStatus('Â∑¶„Ç≥„É≥„Éà„É≠„Éº„É©„ÉºÊé•Á∂ö: ' + event.data.handedness);
                console.log('Controller 0 connected:', event.data);
            });
            controller1.addEventListener('disconnected', () => {
                updateStatus('Â∑¶„Ç≥„É≥„Éà„É≠„Éº„É©„ÉºÂàáÊñ≠');
            });
            scene.add(controller1);
            controllers.push(controller1);

            const controller2 = renderer.xr.getController(1);
            controller2.addEventListener('connected', (event) => {
                updateStatus('Âè≥„Ç≥„É≥„Éà„É≠„Éº„É©„ÉºÊé•Á∂ö: ' + event.data.handedness);
                console.log('Controller 1 connected:', event.data);
            });
            controller2.addEventListener('disconnected', () => {
                updateStatus('Âè≥„Ç≥„É≥„Éà„É≠„Éº„É©„ÉºÂàáÊñ≠');
            });
            scene.add(controller2);
            controllers.push(controller2);

            // „Ç≥„É≥„Éà„É≠„Éº„É©„Éº„ÅÆË¶ñË¶öÁöÑË°®Áèæ„ÇíËøΩÂä†
            const controllerModelFactory = new THREE.Group();
            const geometry = new THREE.CylinderGeometry(0.01, 0.02, 0.1, 8);
            const material = new THREE.MeshStandardMaterial({ color: 0xff0000 });
            
            const controller1Grip = renderer.xr.getControllerGrip(0);
            const mesh1 = new THREE.Mesh(geometry, material);
            controller1Grip.add(mesh1);
            scene.add(controller1Grip);

            const controller2Grip = renderer.xr.getControllerGrip(1);
            const mesh2 = new THREE.Mesh(geometry, material.clone());
            mesh2.material.color.set(0x0000ff);
            controller2Grip.add(mesh2);
            scene.add(controller2Grip);

            // VR„Éá„Éê„ÉÉ„Ç∞Áî®„ÉÜ„Ç≠„Çπ„Éà„Éë„Éç„É´
            createVRDebugPanel();

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            const floorGeometry = new THREE.PlaneGeometry(50, 50);
            const floorMaterial = new THREE.MeshStandardMaterial({ color: 0x808080 });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);

            // Áõ¥ÂæÑ1m„ÅÆÁêÉ
            const sphereGeometry = new THREE.SphereGeometry(0.5, 32, 32);
            const sphereMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 });
            const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
            sphere.position.set(0, 0.5, -3);
            sphere.castShadow = true;
            sphere.receiveShadow = true;
            scene.add(sphere);

            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            
            const container = document.getElementById('container');
            container.addEventListener('mousedown', onMouseDown);
            container.addEventListener('mousemove', onMouseMove);
            container.addEventListener('mouseup', onMouseUp);
            container.addEventListener('mouseleave', onMouseUp);
            container.addEventListener('wheel', onMouseWheel);
            
            document.getElementById('fileInput').addEventListener('change', onFileSelect);
            document.getElementById('resetButton').addEventListener('click', resetCamera);
            document.getElementById('clearButton').addEventListener('click', clearModel);
            document.getElementById('scaleSlider').addEventListener('input', onScaleChange);
            document.getElementById('scale05').addEventListener('click', () => setScale(0.5));
            document.getElementById('scale1').addEventListener('click', () => setScale(1.0));
            document.getElementById('scale2').addEventListener('click', () => setScale(2.0));
            document.getElementById('scale5').addEventListener('click', () => setScale(5.0));
            document.getElementById('voiceButton').addEventListener('click', toggleVoiceInput);
            document.getElementById('voiceInputBtn').addEventListener('click', chooseVoiceInput);
            document.getElementById('keyboardInputBtn').addEventListener('click', chooseKeyboardInput);
            document.getElementById('submitMemoBtn').addEventListener('click', submitMemo);
            document.getElementById('cancelMemoBtn').addEventListener('click', cancelMemoInput);
            
            window.addEventListener('resize', onWindowResize);

            initSpeechRecognition();

            updateStatus('Ê∫ñÂÇôÂÆå‰∫Ü - GLB„Éï„Ç°„Ç§„É´„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ');
            renderer.setAnimationLoop(animate);
        }

        function createVRDebugPanel() {
            // „Ç´„É°„É©„ÅÆÂâçÊñπ„Å´Âõ∫ÂÆöË°®Á§∫„Åï„Çå„Çã„Éá„Éê„ÉÉ„Ç∞„Éë„Éç„É´
            vrDebugCanvas = document.createElement('canvas');
            vrDebugCanvas.width = 512;
            vrDebugCanvas.height = 512;
            
            const texture = new THREE.CanvasTexture(vrDebugCanvas);
            const material = new THREE.MeshBasicMaterial({ 
                map: texture, 
                transparent: true,
                side: THREE.DoubleSide
            });
            const geometry = new THREE.PlaneGeometry(1, 1);
            vrDebugText = new THREE.Mesh(geometry, material);
            
            // „Ç∑„Éº„É≥„Å´Áõ¥Êé•ËøΩÂä†Ôºà„Ç´„É°„É©„ÅÆÂâçÊñπÂõ∫ÂÆö‰ΩçÁΩÆÔºâ
            vrDebugText.position.set(-1, 2, -2);
            scene.add(vrDebugText);
            
            // ÂàùÊúü„ÉÜ„Ç≠„Çπ„Éà„ÇíË°®Á§∫
            updateVRDebugPanel('VR Debug Panel\nInitialized...');
        }

        function updateVRDebugPanel(text) {
            if (!vrDebugCanvas) return;
            
            const ctx = vrDebugCanvas.getContext('2d');
            
            // ËÉåÊôØ
            ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
            ctx.fillRect(0, 0, vrDebugCanvas.width, vrDebugCanvas.height);
            
            // Êû†Á∑ö
            ctx.strokeStyle = '#00ff00';
            ctx.lineWidth = 4;
            ctx.strokeRect(0, 0, vrDebugCanvas.width, vrDebugCanvas.height);
            
            // „ÉÜ„Ç≠„Çπ„Éà
            ctx.fillStyle = '#00ff00';
            ctx.font = 'bold 24px monospace';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'top';
            
            const lines = text.split('\n');
            lines.forEach((line, i) => {
                ctx.fillText(line, 15, 15 + i * 30);
            });
            
            if (vrDebugText && vrDebugText.material && vrDebugText.material.map) {
                vrDebugText.material.map.needsUpdate = true;
            }
        }

        function onFileSelect(event) {
            const file = event.target.files[0];
            if (!file) return;

            const fileName = file.name.toLowerCase();
            const fileExtension = fileName.split('.').pop();

            updateStatus(`„Éï„Ç°„Ç§„É´Ë™≠„ÅøËæº„Åø‰∏≠: ${file.name}`);
            document.getElementById('loading').style.display = 'block';

            const reader = new FileReader();
            reader.onload = e => {
                const arrayBuffer = e.target.result;
                
                switch(fileExtension) {
                    case 'glb':
                    case 'gltf':
                        loadGLTF(arrayBuffer);
                        break;
                    case 'obj':
                        loadOBJ(arrayBuffer);
                        break;
                    case 'fbx':
                        loadFBX(arrayBuffer);
                        break;
                    case 'stl':
                        loadSTL(arrayBuffer);
                        break;
                    case 'dae':
                        loadCollada(arrayBuffer);
                        break;
                    case 'ply':
                        loadPLY(arrayBuffer);
                        break;
                    default:
                        updateStatus('ÂØæÂøú„Åó„Å¶„ÅÑ„Å™„ÅÑ„Éï„Ç°„Ç§„É´ÂΩ¢Âºè„Åß„Åô');
                        document.getElementById('loading').style.display = 'none';
                }
            };
            reader.readAsArrayBuffer(file);
        }

        function loadGLTF(arrayBuffer) {
            const loader = new THREE.GLTFLoader();
            
            loader.parse(arrayBuffer, '', gltf => {
                addModelToScene(gltf.scene, 'GLTF');
            }, error => {
                console.error('GLTFË™≠„ÅøËæº„Åø„Ç®„É©„Éº:', error);
                updateStatus('GLTFË™≠„ÅøËæº„Åø„Ç®„É©„Éº');
                document.getElementById('loading').style.display = 'none';
            });
        }

        function loadOBJ(arrayBuffer) {
            const loader = new THREE.OBJLoader();
            const text = new TextDecoder('utf-8').decode(arrayBuffer);
            
            try {
                const object = loader.parse(text);
                addModelToScene(object, 'OBJ');
            } catch (error) {
                updateStatus('OBJË™≠„ÅøËæº„Åø„Ç®„É©„Éº');
                document.getElementById('loading').style.display = 'none';
            }
        }

        function loadFBX(arrayBuffer) {
            const manager = new THREE.LoadingManager();
            const loader = new THREE.FBXLoader(manager);
            
            try {
                const object = loader.parse(arrayBuffer);
                addModelToScene(object, 'FBX');
            } catch (error) {
                updateStatus('FBXË™≠„ÅøËæº„Åø„Ç®„É©„Éº');
                document.getElementById('loading').style.display = 'none';
            }
        }

        function loadSTL(arrayBuffer) {
            const loader = new THREE.STLLoader();
            
            try {
                const geometry = loader.parse(arrayBuffer);
                const material = new THREE.MeshStandardMaterial({ color: 0xaaaaaa });
                const mesh = new THREE.Mesh(geometry, material);
                addModelToScene(mesh, 'STL');
            } catch (error) {
                updateStatus('STLË™≠„ÅøËæº„Åø„Ç®„É©„Éº');
                document.getElementById('loading').style.display = 'none';
            }
        }

        function loadCollada(arrayBuffer) {
            const loader = new THREE.ColladaLoader();
            const text = new TextDecoder('utf-8').decode(arrayBuffer);
            
            try {
                const collada = loader.parse(text);
                addModelToScene(collada.scene, 'DAE');
            } catch (error) {
                updateStatus('ColladaË™≠„ÅøËæº„Åø„Ç®„É©„Éº');
                document.getElementById('loading').style.display = 'none';
            }
        }

        function loadPLY(arrayBuffer) {
            const loader = new THREE.PLYLoader();
            
            try {
                const geometry = loader.parse(arrayBuffer);
                geometry.computeVertexNormals();
                const material = new THREE.MeshStandardMaterial({ color: 0xaaaaaa });
                const mesh = new THREE.Mesh(geometry, material);
                addModelToScene(mesh, 'PLY');
            } catch (error) {
                updateStatus('PLYË™≠„ÅøËæº„Åø„Ç®„É©„Éº');
                document.getElementById('loading').style.display = 'none';
            }
        }

        function addModelToScene(model, format) {
            const oldModel = scene.getObjectByName('loadedModel');
            if (oldModel) scene.remove(oldModel);

            model.name = 'loadedModel';
            
            model.traverse(node => {
                if (node.isMesh) {
                    node.castShadow = true;
                    node.receiveShadow = true;
                    if (!node.material) {
                        node.material = new THREE.MeshStandardMaterial({ color: 0xaaaaaa });
                    }
                }
            });

            const box = new THREE.Box3().setFromObject(model);
            const center = box.getCenter(new THREE.Vector3());
            const size = box.getSize(new THREE.Vector3());

            model.position.x = -center.x;
            model.position.z = -center.z;
            model.position.y = -box.min.y;

            scene.add(model);
            
            updateStatus(`${format}„É¢„Éá„É´Ë™≠„ÅøËæº„ÅøÂÆå‰∫Ü! „Çµ„Ç§„Ç∫: ${size.x.toFixed(1)}x${size.y.toFixed(1)}x${size.z.toFixed(1)}`);
            document.getElementById('loading').style.display = 'none';

            camera.position.set(0, PLAYER_HEIGHT, size.z * 0.5 + 3);
        }

        function onKeyDown(event) {
            if (document.getElementById('memoInputDialog').style.display === 'block') return;
            
            switch (event.code) {
                case 'ArrowUp':
                case 'KeyW':
                    moveForward = true;
                    break;
                case 'ArrowDown':
                case 'KeyS':
                    moveBackward = true;
                    break;
                case 'ArrowLeft':
                case 'KeyA':
                    moveLeft = true;
                    break;
                case 'ArrowRight':
                case 'KeyD':
                    moveRight = true;
                    break;
                case 'Space':
                    if (canJump) velocity.y += JUMP_VELOCITY;
                    canJump = false;
                    break;
                case 'KeyQ':
                    zoomIn();
                    break;
                case 'KeyE':
                    zoomOut();
                    break;
                case 'KeyM':
                    toggleMemoMode();
                    break;
            }
        }

        function onKeyUp(event) {
            if (document.getElementById('memoInputDialog').style.display === 'block') return;
            
            switch (event.code) {
                case 'ArrowUp':
                case 'KeyW':
                    moveForward = false;
                    break;
                case 'ArrowDown':
                case 'KeyS':
                    moveBackward = false;
                    break;
                case 'ArrowLeft':
                case 'KeyA':
                    moveLeft = false;
                    break;
                case 'ArrowRight':
                case 'KeyD':
                    moveRight = false;
                    break;
            }
        }

        function onMouseDown(event) {
            if (document.getElementById('inputMethodDialog').style.display === 'block' || 
                document.getElementById('memoInputDialog').style.display === 'block') {
                return;
            }

            if (memoMode && event.button === 0) {
                placeMemo(event);
                return;
            }
            isMouseDown = true;
            lastMouseX = event.clientX;
            lastMouseY = event.clientY;
        }

        function onMouseUp() {
            isMouseDown = false;
        }

        function onMouseMove(event) {
            if (!isMouseDown) return;

            const deltaX = event.clientX - lastMouseX;
            const deltaY = event.clientY - lastMouseY;

            lastMouseX = event.clientX;
            lastMouseY = event.clientY;

            euler.setFromQuaternion(camera.quaternion);
            euler.y -= deltaX * 0.002;
            euler.x -= deltaY * 0.002;
            euler.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, euler.x));
            camera.quaternion.setFromEuler(euler);
        }

        function onMouseWheel(event) {
            event.preventDefault();
            if (event.deltaY < 0) {
                zoomIn();
            } else {
                zoomOut();
            }
        }

        function zoomIn() {
            zoomLevel = Math.max(MIN_FOV, zoomLevel - 5);
            camera.fov = zoomLevel;
            camera.updateProjectionMatrix();
        }

        function zoomOut() {
            zoomLevel = Math.min(MAX_FOV, zoomLevel + 5);
            camera.fov = zoomLevel;
            camera.updateProjectionMatrix();
        }

        function resetCamera() {
            camera.position.set(INITIAL_CAMERA_POS.x, INITIAL_CAMERA_POS.y, INITIAL_CAMERA_POS.z);
            camera.rotation.set(0, 0, 0);
            camera.quaternion.set(0, 0, 0, 1);
            
            zoomLevel = INITIAL_ZOOM;
            camera.fov = zoomLevel;
            camera.updateProjectionMatrix();
            
            velocity.set(0, 0, 0);
            moveForward = false;
            moveBackward = false;
            moveLeft = false;
            moveRight = false;
            
            euler.set(0, 0, 0);
            
            updateStatus('„Ç´„É°„É©‰ΩçÁΩÆ„Çí„É™„Çª„ÉÉ„Éà„Åó„Åæ„Åó„Åü');
        }

        function clearModel() {
            const oldModel = scene.getObjectByName('loadedModel');
            if (oldModel) {
                scene.remove(oldModel);
                updateStatus('„É¢„Éá„É´„ÇíÂâäÈô§„Åó„Åæ„Åó„Åü');
                
                document.getElementById('fileInput').value = '';
                
                modelScale = 1.0;
                document.getElementById('scaleSlider').value = 1.0;
                document.getElementById('scaleValue').textContent = 'ÂÄçÁéá: 1.0x';
            } else {
                updateStatus('ÂâäÈô§„Åô„Çã„É¢„Éá„É´„Åå„ÅÇ„Çä„Åæ„Åõ„Çì');
            }
        }

        function onScaleChange(event) {
            const scale = parseFloat(event.target.value);
            setScale(scale);
        }

        function setScale(scale) {
            const model = scene.getObjectByName('loadedModel');
            if (!model) {
                updateStatus('„Çπ„Ç±„Éº„É´Â§âÊõ¥: „É¢„Éá„É´„ÅåË™≠„ÅøËæº„Åæ„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì');
                return;
            }

            modelScale = scale;
            model.scale.set(scale, scale, scale);
            
            document.getElementById('scaleSlider').value = scale;
            document.getElementById('scaleValue').textContent = `ÂÄçÁéá: ${scale.toFixed(1)}x`;
            updateStatus(`„É¢„Éá„É´„Çµ„Ç§„Ç∫„Çí ${scale.toFixed(1)}ÂÄç„Å´Â§âÊõ¥„Åó„Åæ„Åó„Åü`);
        }

        function toggleMemoMode() {
            memoMode = !memoMode;
            const indicator = document.getElementById('memoModeIndicator');
            const panel = document.getElementById('memoPanel');

            if (memoMode) {
                indicator.style.display = 'block';
                panel.style.display = 'block';
                document.getElementById('inputMethodDialog').style.display = 'none';
                document.getElementById('memoInputDialog').style.display = 'none';
                updateStatus('„É°„É¢„É¢„Éº„Éâ ON - „ÇØ„É™„ÉÉ„ÇØ„Åß„É°„É¢„ÇíÈÖçÁΩÆ');
                setTimeout(() => {
                    indicator.style.display = 'none';
                }, 2000);
            } else {
                indicator.style.display = 'none';
                panel.style.display = 'none';
                document.getElementById('inputMethodDialog').style.display = 'none';
                document.getElementById('memoInputDialog').style.display = 'none';
                updateStatus('„É°„É¢„É¢„Éº„Éâ OFF');
            }
        }

        function placeMemo(event) {
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();
            
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            
            const intersects = raycaster.intersectObjects(scene.children, true);
            let position;
            
            const OFFSET_DISTANCE = 0.1;
            
            if (intersects.length > 0) {
                const intersect = intersects[0];
                const hitPoint = intersect.point;

                let offsetDirection = new THREE.Vector3();
                
                if (intersect.face) {
                    offsetDirection.copy(intersect.face.normal);
                    offsetDirection.transformDirection(intersect.object.matrixWorld);
                } else {
                    offsetDirection.subVectors(camera.position, hitPoint).normalize();
                }
                
                position = hitPoint.clone().add(offsetDirection.normalize().multiplyScalar(OFFSET_DISTANCE));
                
            } else {
                const direction = new THREE.Vector3();
                camera.getWorldDirection(direction);
                position = camera.position.clone().add(direction.multiplyScalar(3));
            }
            
            pendingMemoPosition = position;
            document.getElementById('inputMethodDialog').style.display = 'block';
        }

        function chooseVoiceInput() {
            document.getElementById('inputMethodDialog').style.display = 'none';
            if (pendingMemoPosition && recognition) {
                startVoiceInputForMemo(pendingMemoPosition);
            } else {
                updateStatus('Èü≥Â£∞Ë™çË≠ò„ÅåÂà©Áî®„Åß„Åç„Åæ„Åõ„Çì');
            }
        }

        function chooseKeyboardInput() {
            document.getElementById('inputMethodDialog').style.display = 'none';
            if (pendingMemoPosition) {
                const textarea = document.getElementById('memoTextarea');
                textarea.value = '';
                document.getElementById('memoInputDialog').style.display = 'block';
                textarea.focus();
            }
        }

        function submitMemo() {
            const text = document.getElementById('memoTextarea').value.trim();
            document.getElementById('memoInputDialog').style.display = 'none';

            if (text && pendingMemoPosition) {
                createMemo(pendingMemoPosition, text, 'normal');
                toggleMemoMode();
            } else {
                updateStatus('„É°„É¢„ÅÆÂÜÖÂÆπ„ÅåÁ©∫ÁôΩ„ÅÆ„Åü„ÇÅ‰ΩúÊàê„Çí„Ç≠„É£„É≥„Çª„É´„Åó„Åæ„Åó„Åü');
            }
            pendingMemoPosition = null;
        }

        function cancelMemoInput() {
            document.getElementById('memoInputDialog').style.display = 'none';
            pendingMemoPosition = null;
        }

        function createMemo(position, text, priority = 'normal') {
            const memoId = memoCounter++;
            
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            
            const CANVAS_WIDTH = 512;
            const FONT_SIZE = 32;
            const LINE_HEIGHT = 40;
            const PADDING = 20;
            const MAX_WIDTH = CANVAS_WIDTH - (PADDING * 2);

            context.font = `bold ${FONT_SIZE}px Arial`;

            const paragraphs = text.split('\n');
            const linesToDraw = [];
            
            for (const paragraph of paragraphs) {
                const words = paragraph.split(' ');
                let currentLine = '';

                for (let word of words) {
                    const testLine = currentLine + word + ' ';
                    const metrics = context.measureText(testLine);

                    if (metrics.width > MAX_WIDTH && currentLine !== '') {
                        linesToDraw.push(currentLine.trim());
                        currentLine = word + ' ';
                    } else {
                        currentLine = testLine;
                    }
                }
                linesToDraw.push(currentLine.trim());
            }

            const requiredHeight = (linesToDraw.length * LINE_HEIGHT) + (PADDING * 2);

            canvas.width = CANVAS_WIDTH;
            canvas.height = requiredHeight;
            
            context.fillStyle = priority === 'high' ? '#ff6b6b' : 
                               priority === 'normal' ? '#ffd93d' : '#6bcf7f';
            context.fillRect(0, 0, canvas.width, canvas.height);
            
            context.fillStyle = '#000000';
            context.font = `bold ${FONT_SIZE}px Arial`;
            context.textAlign = 'center';
            context.textBaseline = 'top';
            
            let y = PADDING;
            for (const line of linesToDraw) {
                context.fillText(line, CANVAS_WIDTH / 2, y);
                y += LINE_HEIGHT;
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.position.copy(position);
            
            const BASE_SCALE_X = 1.0;
            const spriteHeightRatio = canvas.height / CANVAS_WIDTH;
            sprite.scale.set(BASE_SCALE_X, BASE_SCALE_X * spriteHeightRatio, 1);

            sprite.name = `memo_${memoId}`;
            
            scene.add(sprite);
            
            memos.push({
                id: memoId,
                text: text,
                priority: priority,
                position: position.clone(),
                sprite: sprite
            });
            
            updateMemoList();
            updateStatus(`„É°„É¢„ÇíËøΩÂä†„Åó„Åæ„Åó„Åü: "${text.substring(0, 20).replace(/\n/g, ' ')}..."`);
        }

        function deleteMemo(memoId) {
            const index = memos.findIndex(m => m.id === memoId);
            if (index !== -1) {
                scene.remove(memos[index].sprite);
                memos.splice(index, 1);
                updateMemoList();
                updateStatus('„É°„É¢„ÇíÂâäÈô§„Åó„Åæ„Åó„Åü');
            }
        }

        function updateMemoList() {
            const list = document.getElementById('memoList');
            list.innerHTML = '';
            
            memos.forEach(memo => {
                const item = document.createElement('div');
                item.className = `memo-item priority-${memo.priority}`;
                
                const displayText = memo.text.replace(/\n/g, '<br>');

                item.innerHTML = `
                    <div><strong>#${memo.id + 1}</strong>: ${displayText}</div>
                    <div style="font-size: 11px; color: #aaa; margin-top: 5px;">
                        ‰ΩçÁΩÆ: (${memo.position.x.toFixed(1)}, ${memo.position.y.toFixed(1)}, ${memo.position.z.toFixed(1)})
                    </div>
                    <button onclick="deleteMemo(${memo.id})">ÂâäÈô§</button>
                `;
                list.appendChild(item);
            });
        }

        function initSpeechRecognition() {
            if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                recognition = new SpeechRecognition();
                recognition.lang = 'ja-JP';
                recognition.continuous = false;
                recognition.interimResults = false;
                
                updateStatus('Èü≥Â£∞Ë™çË≠ò„ÅåÂà©Áî®ÂèØËÉΩ„Åß„Åô');
            } else {
                updateStatus('Èü≥Â£∞Ë™çË≠ò„ÅØÈùûÂØæÂøú„Éñ„É©„Ç¶„Ç∂„Åß„Åô');
                document.getElementById('voiceButton').disabled = true;
                document.getElementById('voiceButton').textContent = 'üé§ Èü≥Â£∞ÂÖ•ÂäõÈùûÂØæÂøú';
            }
        }

        let currentMemoPosition = null;

        function startVoiceInputForMemo(position) {
            if (!recognition || isRecording) return;
            
            currentMemoPosition = position;
            isRecording = true;
            document.getElementById('voiceButton').classList.add('recording');
            document.getElementById('voiceButton').textContent = 'üé§ Èå≤Èü≥‰∏≠...';
            
            recognition.onresult = (event) => {
                const transcript = event.results[0][0].transcript;
                createMemo(currentMemoPosition, transcript, 'normal');
                isRecording = false;
                document.getElementById('voiceButton').classList.remove('recording');
                document.getElementById('voiceButton').textContent = 'üé§ Èü≥Â£∞ÂÖ•Âäõ„Åß„É°„É¢ËøΩÂä†';
            };
            
            recognition.onerror = (event) => {
                updateStatus('Èü≥Â£∞Ë™çË≠ò„Ç®„É©„Éº: ' + event.error);
                isRecording = false;
                document.getElementById('voiceButton').classList.remove('recording');
                document.getElementById('voiceButton').textContent = 'üé§ Èü≥Â£∞ÂÖ•Âäõ„Åß„É°„É¢ËøΩÂä†';
            };
            
            recognition.start();
        }

        function toggleVoiceInput() {
            if (!recognition) return;
            
            if (isRecording) {
                recognition.stop();
                isRecording = false;
                document.getElementById('voiceButton').classList.remove('recording');
                document.getElementById('voiceButton').textContent = 'üé§ Èü≥Â£∞ÂÖ•Âäõ„Åß„É°„É¢ËøΩÂä†';
                return;
            }
            
            const direction = new THREE.Vector3();
            camera.getWorldDirection(direction);
            const position = camera.position.clone().add(direction.multiplyScalar(3));
            
            startVoiceInputForMemo(position);
        }

        window.deleteMemo = deleteMemo;

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function handleVRControllers(delta) {
            const session = renderer.xr.getSession();
            if (!session) {
                updateVRDebugPanel('VR„Çª„ÉÉ„Ç∑„Éß„É≥„Å™„Åó');
                return;
            }

            if (!session.inputSources || session.inputSources.length === 0) {
                updateVRDebugPanel('„Ç≥„É≥„Éà„É≠„Éº„É©„ÉºÊú™Ê§úÂá∫');
                return;
            }

            let debugInfo = ['VR Debug Info', ''];
            let moved = false;

            for (let i = 0; i < session.inputSources.length; i++) {
                const inputSource = session.inputSources[i];
                const gamepad = inputSource.gamepad;
                
                if (!gamepad) {
                    debugInfo.push(`${inputSource.handedness}: No gamepad`);
                    continue;
                }

                // axesÊÉÖÂ†±
                const axesStr = gamepad.axes.map((v, idx) => `${idx}:${v.toFixed(2)}`).join(' ');
                debugInfo.push(`${inputSource.handedness}:`);
                debugInfo.push(`  axes: ${axesStr}`);
                
                // „Éú„Çø„É≥ÊÉÖÂ†±
                const pressedButtons = [];
                for (let btnIdx = 0; btnIdx < gamepad.buttons.length; btnIdx++) {
                    if (gamepad.buttons[btnIdx].pressed) {
                        pressedButtons.push(btnIdx);
                    }
                }
                debugInfo.push(`  btns: ${pressedButtons.length > 0 ? pressedButtons.join(',') : 'none'}`);

                if (inputSource.handedness === 'left') {
                    // Â∑¶„Çπ„ÉÜ„Ç£„ÉÉ„ÇØÔºöÂÖ®„Éë„Çø„Éº„É≥„ÇíË©¶„ÅôÔºàÈñæÂÄ§„Çí0.05„Å´‰∏ã„Åí„ÇãÔºâ
                    let moveX = 0;
                    let moveZ = 0;
                    
                    // „Éë„Çø„Éº„É≥1: axes[0], axes[1]
                    if (Math.abs(gamepad.axes[0]) > 0.05) moveX = gamepad.axes[0];
                    if (Math.abs(gamepad.axes[1]) > 0.05) moveZ = gamepad.axes[1];
                    
                    // „Éë„Çø„Éº„É≥2: axes[2], axes[3]
                    if (Math.abs(gamepad.axes[2]) > 0.05) moveX = gamepad.axes[2];
                    if (Math.abs(gamepad.axes[3]) > 0.05) moveZ = gamepad.axes[3];
                    
                    // „Çà„ÇäË©≥Á¥∞„Å™„Éá„Éê„ÉÉ„Ç∞ÊÉÖÂ†±
                    debugInfo.push(`  moveX:${moveX.toFixed(3)} moveZ:${moveZ.toFixed(3)}`);
                    
                    if (Math.abs(moveX) > 0.05 || Math.abs(moveZ) > 0.05) {
                        const forward = new THREE.Vector3(0, 0, -1);
                        forward.applyQuaternion(camera.quaternion);
                        forward.y = 0;
                        forward.normalize();

                        const right = new THREE.Vector3(1, 0, 0);
                        right.applyQuaternion(camera.quaternion);
                        right.y = 0;
                        right.normalize();

                        // VR„É¢„Éº„Éâ„Åß„ÅØ„Ç´„É°„É©„É™„Ç∞„ÇíÁßªÂãï
                        const moveVector = new THREE.Vector3();
                        moveVector.add(forward.multiplyScalar(-moveZ * VR_MOVE_SPEED * delta));
                        moveVector.add(right.multiplyScalar(moveX * VR_MOVE_SPEED * delta));
                        
                        const oldPos = cameraRig.position.clone();
                        cameraRig.position.add(moveVector);
                        
                        moved = true;
                        const distance = oldPos.distanceTo(cameraRig.position);
                        debugInfo.push(`  *** MOVING! dist:${distance.toFixed(4)} ***`);
                        debugInfo.push(`  RigPos: ${cameraRig.position.x.toFixed(2)},${cameraRig.position.y.toFixed(2)},${cameraRig.position.z.toFixed(2)}`);
                    } else {
                        debugInfo.push(`  (threshold not met)`);
                    }

                    // „Éú„Çø„É≥„ÉÅ„Çß„ÉÉ„ÇØÔºà‰∏ä‰∏ãÁßªÂãï„ÇÇ„É™„Ç∞„ÅßÔºâ
                    for (let btnIdx = 0; btnIdx < gamepad.buttons.length; btnIdx++) {
                        if (gamepad.buttons[btnIdx].pressed) {
                            if (btnIdx === 0) {
                                cameraRig.position.y += VR_MOVE_SPEED * delta;
                                debugInfo.push(`  UP!`);
                            } else if (btnIdx === 1) {
                                cameraRig.position.y -= VR_MOVE_SPEED * delta;
                                if (cameraRig.position.y < 0) {
                                    cameraRig.position.y = 0;
                                }
                                debugInfo.push(`  DOWN!`);
                            }
                        }
                    }
                }

                if (inputSource.handedness === 'right') {
                    // Âè≥„Ç≥„É≥„Éà„É≠„Éº„É©„Éº„ÅÆÂÖ®„Éú„Çø„É≥„Çí„ÉÅ„Çß„ÉÉ„ÇØ
                    for (let btnIdx = 0; btnIdx < gamepad.buttons.length; btnIdx++) {
                        if (gamepad.buttons[btnIdx].pressed) {
                            if (btnIdx === 0) {
                                zoomOut();
                                debugInfo.push(`  ZOOM OUT!`);
                            } else if (btnIdx === 1) {
                                zoomIn();
                                debugInfo.push(`  ZOOM IN!`);
                            }
                        }
                    }
                }
                
                debugInfo.push('');
            }
            
            debugInfo.push(`CamRig: ${cameraRig.position.x.toFixed(1)}, ${cameraRig.position.y.toFixed(1)}, ${cameraRig.position.z.toFixed(1)}`);
            updateVRDebugPanel(debugInfo.join('\n'));
        }

        function placeVRMemo() {
            // „Ç´„É°„É©„ÅÆÂâçÊñπ3m„Å´„É°„É¢„ÇíÈÖçÁΩÆ
            const direction = new THREE.Vector3();
            camera.getWorldDirection(direction);
            const position = camera.position.clone().add(direction.multiplyScalar(3));
            
            pendingMemoPosition = position;
            
            // VR„Åß„ÅØÈü≥Â£∞ÂÖ•Âäõ„ÇíËá™ÂãïÈñãÂßã
            if (recognition) {
                startVoiceInputForMemo(position);
            } else {
                // Èü≥Â£∞Ë™çË≠ò„Åå„Å™„ÅÑÂ†¥Âêà„ÅØÁ∞°Êòì„ÉÜ„Ç≠„Çπ„Éà
                const timestamp = new Date().toLocaleTimeString('ja-JP');
                createMemo(position, `VR„É°„É¢ ${timestamp}`, 'normal');
                vrMemoMode = false;
                updateStatus('VR„É°„É¢„ÇíËøΩÂä†„Åó„Åæ„Åó„Åü');
            }
            
            pendingMemoPosition = null;
        }

        function animate() {
            const time = performance.now();
            const delta = (time - prevTime) / 1000;

            if (renderer.xr.isPresenting) {
                handleVRControllers(delta);
            } else {
                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;
                velocity.y -= GRAVITY * delta;

                direction.z = Number(moveBackward) - Number(moveForward);
                direction.x = Number(moveLeft) - Number(moveRight);
                direction.normalize();

                if (moveForward || moveBackward) velocity.z -= direction.z * MOVE_SPEED * delta;
                if (moveLeft || moveRight) velocity.x -= direction.x * MOVE_SPEED * delta;

                const forward = new THREE.Vector3(0, 0, -1);
                forward.applyQuaternion(camera.quaternion);
                forward.y = 0;
                forward.normalize();

                const right = new THREE.Vector3(1, 0, 0);
                right.applyQuaternion(camera.quaternion);
                right.y = 0;
                right.normalize();

                camera.position.add(forward.multiplyScalar(velocity.z * delta));
                camera.position.add(right.multiplyScalar(velocity.x * delta));
                camera.position.y += velocity.y * delta;

                if (camera.position.y < PLAYER_HEIGHT) {
                    velocity.y = 0;
                    camera.position.y = PLAYER_HEIGHT;
                    canJump = true;
                }
            }

            prevTime = time;
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>
