<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>VR GLBショップウォークスルー（編集対応・デバッグ版）</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; }
        #container { width: 100vw; height: 100vh; cursor: grab; }
        #container:active { cursor: grabbing; }
        #info { position: absolute; top: 10px; left: 10px; color: white; background: rgba(0, 0, 0, 0.7); padding: 15px; border-radius: 8px; font-size: 14px; max-width: 360px; z-index: 100; }
        /* ...（既存の CSS は省略せずにそのまま使ってください）... */
        #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; background: rgba(0, 0, 0, 0.8); padding: 20px 40px; border-radius: 8px; font-size: 18px; display: none; z-index: 1000; }
        #status { margin-top: 10px; font-size: 12px; color: #aaffaa; }
        /* エラーオーバーレイ */
        #errorOverlay { position: absolute; left: 0; top: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.85); color: #ffcccc; display: none; z-index: 3000; padding: 20px; box-sizing: border-box; overflow:auto; }
        #errorOverlay h2 { margin-top: 0; color: #ff6666; }
    </style>
</head>
<body>
    <div id="container"></div>

    <div id="info">
        <strong>VR ショップウォークスルー（編集対応・デバッグ版）</strong><br>
        <small id="updateDate" style="color: #aaa;"></small>
        <div id="controls">…</div>
        <input type="file" id="fileInput" accept=".glb,.gltf,.obj,.stl" />
        <button id="vrButton">VRモード開始</button>
        <button id="editModeButton" class="btn">編集モード: OFF</button>
        <button id="resetButton" class="btn">カメラリセット</button>
        <button id="clearButton" class="btn">モデル削除</button>
        <div id="scaleControls">…</div>
        <div id="status"></div>
    </div>

    <div id="loading">読み込み中...</div>
    <div id="memoPanel" style="display:none">…</div>

    <div id="errorOverlay"><h2>エラーが発生しました</h2><pre id="errorText"></pre></div>

    <!-- three.js / loaders（非モジュール版） -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/OBJLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/STLLoader.js"></script>

    <script>
    // --- 簡易化のため一部 UI 文言や CSS を省略してあります（実装時は元と差し替えてください） ---
    const BG_COLOR = 0x87CEEB;

    let scene, camera, renderer, cameraRig;
    let prevTime = performance.now();
    let loadedModel = null;
    let floorMesh = null;
    const VERSION='v1.3.0-debug', UPDATE_DATE='2025/12/01';

    function setStatus(msg, isError=false) {
        const st=document.getElementById('status');
        st.textContent = msg;
        st.style.color = isError ? '#ffaaaa' : '#aaffaa';
        console.log('STATUS:', msg);
    }

    function showErrorOverlay(msg) {
        const ov = document.getElementById('errorOverlay');
        const txt = document.getElementById('errorText');
        txt.textContent = msg;
        ov.style.display = 'block';
        console.error('ErrorOverlay:', msg);
    }

    function init() {
        try {
            document.getElementById('updateDate').textContent = `${VERSION} (${UPDATE_DATE})`;
            scene = new THREE.Scene();
            scene.background = new THREE.Color(BG_COLOR);
            scene.fog = new THREE.Fog(BG_COLOR, 0, 50);

            cameraRig = new THREE.Group();
            scene.add(cameraRig);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
            camera.position.set(0, 1.6, 5);
            cameraRig.add(camera);

            renderer = new THREE.WebGLRenderer({antialias:true});
            // 明示的にクリアカラーをセット（scene.background が効かないケース用）
            renderer.setClearColor(BG_COLOR);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.xr.enabled = true;
            // append
            document.getElementById('container').appendChild(renderer.domElement);

            // WebGL context イベントを監視
            renderer.domElement.addEventListener('webglcontextlost', (e) => {
                e.preventDefault();
                showErrorOverlay('WebGL context lost');
            }, false);
            renderer.domElement.addEventListener('webglcontextrestored', () => {
                setStatus('WebGL context restored');
            }, false);

            // シンプルなライトと地面（レンダリング確認用）
            scene.add(new THREE.AmbientLight(0xffffff,0.6));
            const light = new THREE.DirectionalLight(0xffffff,0.8);
            light.position.set(5,10,5);
            scene.add(light);

            floorMesh = new THREE.Mesh(new THREE.PlaneGeometry(50,50), new THREE.MeshStandardMaterial({color:0x808080}));
            floorMesh.rotation.x = -Math.PI/2;
            floorMesh.receiveShadow = true;
            scene.add(floorMesh);

            // 初回レンダリングを強制（アニメーションループが動かない場合でも背景が見える）
            renderer.render(scene, camera);

            // 後続の init 処理（イベント登録など）は try/catch 外でも差し支えないので続ける
            window.addEventListener('resize', onWindowResize);
            // 既存のイベント/UI 初期化はここに移行してください（省略）
            renderer.setAnimationLoop(animate);

            setStatus('初期化完了');
        } catch (err) {
            const msg = (err && err.stack) ? err.stack : String(err);
            showErrorOverlay(msg);
            setStatus('初期化エラー', true);
        }
    }

    window.addEventListener('error', function(ev) {
        const message = ev && ev.error ? (ev.error.stack || ev.error.message) : (ev.message || String(ev));
        showErrorOverlay(message);
    });

    window.addEventListener('unhandledrejection', function(ev) {
        const reason = ev && ev.reason ? (ev.reason.stack || ev.reason) : String(ev);
        showErrorOverlay('UnhandledRejection: ' + reason);
    });

    function onWindowResize() {
        if(!camera || !renderer) return;
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
        const time = performance.now();
        const delta = (time - prevTime) / 1000;
        prevTime = time;
        // 簡易シーン更新（実装版に合わせてください）
        renderer.render(scene, camera);
    }

    // 初期化を呼ぶ
    init();
    </script>
</body>
</html>
