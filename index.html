<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    <title>VR GLB ショップウォークスルー（安定版）</title>
    <style>
        html,body { height:100%; margin:0; font-family: Arial, Helvetica, sans-serif; background:#000; color:#fff; }
        #container { width:100vw; height:100vh; overflow:hidden; position:relative; }
        #ui { position: absolute; left:10px; top:10px; width:320px; z-index:1000; background: rgba(0,0,0,0.6); padding:12px; border-radius:8px; font-size:13px; }
        #memoPanel { position:absolute; right:10px; top:10px; width:320px; max-height:80vh; overflow:auto; z-index:1000; background:rgba(0,0,0,0.7); padding:12px; border-radius:8px; display:none; }
        button, input[type=file], input[type=range] { width:100%; box-sizing:border-box; margin-top:8px; padding:8px; border-radius:6px; border:none; }
        .small { width:48%; display:inline-block; }
        #loading { position:absolute; left:50%; top:50%; transform:translate(-50%,-50%); background:rgba(0,0,0,0.8); padding:14px 22px; border-radius:8px; display:none; z-index:2000; }
        .memo-item { background:rgba(255,255,255,0.06); padding:8px; margin-bottom:8px; border-radius:6px; }
        .memo-item button { width:auto; margin-top:6px; padding:6px 8px; }
    </style>
</head>
<body>
    <div id="container"></div>

    <div id="ui">
        <strong>VR ショップウォークスルー（安定版）</strong><br>
        <small id="version">v1.0.0</small>
        <div style="margin-top:8px">
            <input id="fileInput" type="file" accept=".glb,.gltf,.obj,.stl" />
            <button id="vrButton">VR モード開始</button>
            <button id="resetButton">カメラリセット</button>
            <button id="clearButton">モデル削除</button>
            <label style="margin-top:8px">モデルサイズ <span id="scaleValue">1.0x</span></label>
            <input id="scaleSlider" type="range" min="0.1" max="10" step="0.1" value="1.0" />
            <button id="toggleMemoMode">メモモード ON/OFF</button>
            <button id="toggleMemoPanel">メモ一覧表示</button>
            <div id="status" style="margin-top:6px;color:#aaffaa;"></div>
        </div>
    </div>

    <div id="memoPanel">
        <h3>メモリスト</h3>
        <div id="memoList"></div>
    </div>

    <div id="loading">読み込み中...</div>

    <!-- Three.js とローダー（安定版） -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/OBJLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/STLLoader.js"></script>

    <script>
    /**
     * 安定版アプリケーション
     * - クラス構成で責務を分離
     * - メモの二重追加を防止
     * - VR 時のズーム改善（FOV 変更ではなく cameraRig 前後移動）
     * - メモの距離ベース自動スケール（読みやすさを維持）
     */

    const VERSION = 'v1.0.0';
    const UPDATE_DATE = '2025/12/09';

    document.getElementById('version').textContent = `${VERSION} (${UPDATE_DATE})`;

    /**********************************************************************
     * ModelManager
     * - モデルのロード・スケール・中心化を担当
     **********************************************************************/
    class ModelManager {
        constructor(scene, ui) {
            this.scene = scene;
            this.ui = ui;
            this.loaded = null;
        }

        removeModel() {
            if (!this.loaded) return;
            this.scene.remove(this.loaded);
            this.loaded.traverse && this.loaded.traverse(n => { if (n.geometry) n.geometry.dispose && n.geometry.dispose(); });
            this.loaded = null;
            this.ui.setStatus('モデルを削除しました');
        }

        setScale(s) {
            if (!this.loaded) return;
            this.loaded.scale.set(s, s, s);
            this.ui.setStatus(`モデルスケール: ${s.toFixed(2)}x`);
        }

        async loadFile(arrayBuffer, filename) {
            const ext = (filename.split('.').pop() || '').toLowerCase();
            this.removeModel();
            this.ui.showLoading(true);
            try {
                if (ext === 'glb' || ext === 'gltf') {
                    await this._loadGLTF(arrayBuffer);
                } else if (ext === 'obj') {
                    await this._loadOBJ(arrayBuffer);
                } else if (ext === 'stl') {
                    await this._loadSTL(arrayBuffer);
                } else {
                    throw new Error('未対応のファイル形式');
                }
                this._centerModel();
                this.ui.setStatus(`読み込み完了: ${filename}`);
            } catch (err) {
                console.error(err);
                this.ui.setStatus('読み込みに失敗しました');
            } finally {
                this.ui.showLoading(false);
            }
        }

        _loadGLTF(buf) {
            return new Promise((resolve, reject) => {
                const loader = new THREE.GLTFLoader();
                loader.parse(buf, '', gltf => {
                    this.loaded = gltf.scene;
                    this._ensureMeshes(this.loaded);
                    this.scene.add(this.loaded);
                    resolve();
                }, e => {
                    reject(e);
                });
            });
        }

        _loadOBJ(buf) {
            return new Promise((resolve, reject) => {
                try {
                    const text = new TextDecoder().decode(buf);
                    const loader = new THREE.OBJLoader();
                    const obj = loader.parse(text);
                    this.loaded = obj;
                    this._ensureMeshes(this.loaded);
                    this.scene.add(this.loaded);
                    resolve();
                } catch (e) { reject(e); }
            });
        }

        _loadSTL(buf) {
            return new Promise((resolve, reject) => {
                try {
                    const loader = new THREE.STLLoader();
                    const geom = loader.parse(buf);
                    const mat = new THREE.MeshStandardMaterial({ color: 0x999999 });
                    const mesh = new THREE.Mesh(geom, mat);
                    this.loaded = new THREE.Group();
                    this.loaded.add(mesh);
                    this.scene.add(this.loaded);
                    resolve();
                } catch (e) { reject(e); }
            });
        }

        _ensureMeshes(root) {
            root.traverse(n => {
                if (n.isMesh) {
                    n.castShadow = true;
                    n.receiveShadow = true;
                    if (!n.material) n.material = new THREE.MeshStandardMaterial({ color: 0xaaaaaa });
                }
            });
        }

        _centerModel() {
            if (!this.loaded) return;
            // ボックスにより中心を原点に持ってくる (y は floor に合わせる)
            const box = new THREE.Box3().setFromObject(this.loaded);
            const size = box.getSize(new THREE.Vector3());
            const center = box.getCenter(new THREE.Vector3());
            // translate so base sits on y=0
            this.loaded.position.x -= center.x;
            this.loaded.position.z -= center.z;
            this.loaded.position.y -= box.min.y;
            // scale down if extremely large
            const maxDim = Math.max(size.x, size.y, size.z);
            if (maxDim > 10) {
                const factor = 5 / maxDim;
                this.loaded.scale.setScalar(factor);
                this.ui.setStatus(`自動縮小: ${factor.toFixed(2)}x`);
            }
        }
    }

    /**********************************************************************
     * MemoManager
     * - メモ生成、編集、削除、描画更新（距離スケール）を管理
     **********************************************************************/
    class MemoManager {
        constructor(scene, camera, ui) {
            this.scene = scene;
            this.camera = camera;
            this.ui = ui;
            this.memos = []; // { id, text, position: Vector3, sprite }
            this.counter = 0;
            this.tempEditFrame = null;
        }

        createMemoAt(position, text) {
            const id = this.counter++;
            const sprite = this._makeSprite(text);
            sprite.position.copy(position);
            // スプライトはここで scene に追加（責務を明確に）
            this.scene.add(sprite);
            const memo = { id, text, position: position.clone(), sprite };
            this.memos.push(memo);
            this.ui.setStatus(`メモ作成 #${id}`);
            this.ui.updateMemoList(this.memos, this.deleteMemo.bind(this));
            return memo;
        }

        updateMemoText(memoId, newText) {
            const memo = this.memos.find(m => m.id === memoId);
            if (!memo) return false;
            // remove old sprite
            if (memo.sprite) {
                this.scene.remove(memo.sprite);
            }
            const newSprite = this._makeSprite(newText);
            newSprite.position.copy(memo.position);
            this.scene.add(newSprite);
            memo.sprite = newSprite;
            memo.text = newText;
            this.ui.setStatus(`メモ更新 #${memoId}`);
            this.ui.updateMemoList(this.memos, this.deleteMemo.bind(this));
            return true;
        }

        deleteMemo(id) {
            const idx = this.memos.findIndex(m => m.id === id);
            if (idx === -1) return;
            const m = this.memos[idx];
            if (m.sprite) this.scene.remove(m.sprite);
            this.memos.splice(idx, 1);
            this.ui.updateMemoList(this.memos, this.deleteMemo.bind(this));
            this.ui.setStatus(`メモ削除 #${id}`);
        }

        placeMemoFromController(controller, distance = 2.0) {
            const pos = new THREE.Vector3();
            const dir = new THREE.Vector3(0, 0, -1);
            controller.getWorldPosition(pos);
            controller.getWorldQuaternion(dir.quaternion || new THREE.Quaternion()); // safety
            const quat = new THREE.Quaternion();
            controller.getWorldQuaternion(quat);
            dir.applyQuaternion(quat);
            const target = pos.clone().add(dir.multiplyScalar(distance));
            const ts = new Date().toLocaleTimeString('ja-JP');
            return this.createMemoAt(target, `VRメモ ${ts}`);
        }

        findMemoByRay(raycaster) {
            const sprites = this.memos.map(m => m.sprite).filter(Boolean);
            if (sprites.length === 0) return null;
            const hits = raycaster.intersectObjects(sprites, false);
            if (hits.length === 0) return null;
            const hitObj = hits[0].object;
            return this.memos.find(m => m.sprite === hitObj) || null;
        }

        // Called each frame to adjust sprite scale so that text remains readable
        updateSpriteScales() {
            const camPos = this.camera.getWorldPosition(new THREE.Vector3());
            for (const m of this.memos) {
                if (!m.sprite) continue;
                const d = m.sprite.position.distanceTo(camPos);
                // base scale: 0.3 at distance 3.0, scale linearly with distance but clamp
                const base = Math.min(1.0, Math.max(0.12, (d / 3.0) * 0.3));
                // optionally change based on sprite's intrinsic aspect ratio: use sprite.scale.x as width
                m.sprite.scale.set(base, base * (m.sprite.userData.aspect || 1), 1);
            }
        }

        _makeSprite(text) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const maxWidth = 512;
            canvas.width = maxWidth;
            // simple word-wrap
            ctx.font = 'bold 28px sans-serif';
            const lines = this._wrapText(ctx, text, maxWidth - 40);
            const lineHeight = 36;
            canvas.height = Math.max(64, lines.length * lineHeight + 24);
            // background
            ctx.fillStyle = '#ffd93d';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#000';
            ctx.font = 'bold 28px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            let y = 12;
            for (const ln of lines) {
                ctx.fillText(ln, canvas.width / 2, y);
                y += lineHeight;
            }
            const tex = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({ map: tex, depthTest: true, depthWrite: false });
            const sprite = new THREE.Sprite(material);
            const aspect = canvas.height / canvas.width;
            sprite.scale.set(0.3, 0.3 * aspect, 1);
            sprite.userData = { aspect };
            return sprite;
        }

        _wrapText(ctx, text, maxWidth) {
            const paragraphs = text.split('\n');
            const lines = [];
            for (const p of paragraphs) {
                const words = p.split(' ');
                let line = '';
                for (const w of words) {
                    const test = line ? (line + ' ' + w) : w;
                    const metrics = ctx.measureText(test);
                    if (metrics.width > maxWidth && line) {
                        lines.push(line);
                        line = w;
                    } else {
                        line = test;
                    }
                }
                if (line) lines.push(line);
            }
            return lines;
        }
    }

    /**********************************************************************
     * VRControllerManager
     * - WebXR セッション中のコントローラーの扱い、入力処理を担当
     * - 長押しの判定・メモ配置や編集トリガーはここで扱う
     **********************************************************************/
    class VRControllerManager {
        constructor(renderer, cameraRig, memoManager, ui) {
            this.renderer = renderer;
            this.cameraRig = cameraRig;
            this.memoManager = memoManager;
            this.ui = ui;
            this.controllers = [];
            this.rightTriggerPressed = false;
            this.rightTriggerPressTime = 0;
            this.editingMemo = null;
            this.longPressThreshold = 500; // ms
            this.vrMemoMode = false;
            this._setupControllers();
        }

        _setupControllers() {
            // create controller objects (they are populated when XR session starts)
            for (let i = 0; i < 2; i++) {
                const c = this.renderer.xr.getController(i);
                c.userData.index = i;
                this.controllers.push(c);
                this.cameraRig.add(c);
                // add simple ray visual
                const g = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,0), new THREE.Vector3(0,0,-1)]);
                const mat = new THREE.LineBasicMaterial({ linewidth: 2 });
                const line = new THREE.Line(g, mat);
                line.scale.z = 2;
                c.add(line);
            }
        }

        // Called every frame when XR session active
        update(delta) {
            const session = this.renderer.xr.getSession();
            if (!session || !session.inputSources) return;
            // Iterate inputSources and handle gamepad buttons/axes
            for (const src of session.inputSources) {
                const gp = src.gamepad;
                const handedness = src.handedness || 'unknown';
                if (!gp) continue;
                if (handedness === 'left') {
                    this._handleLeftGamepad(gp);
                } else if (handedness === 'right') {
                    this._handleRightGamepad(gp);
                }
            }
        }

        _handleLeftGamepad(gamepad) {
            // left stick movement
            // axes could be [x,y] or [x,y, ...]
            const ax0 = gamepad.axes[0] || 0;
            const ax1 = gamepad.axes[1] || 0;
            // Move cameraRig based on left stick
            if (Math.abs(ax0) > 0.05 || Math.abs(ax1) > 0.05) {
                // compute forward & right vectors from camera
                const camQuat = new THREE.Quaternion();
                this.renderer.xr.getCamera().getWorldQuaternion(camQuat);
                const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camQuat);
                forward.y = 0; forward.normalize();
                const right = new THREE.Vector3(1, 0, 0).applyQuaternion(camQuat);
                right.y = 0; right.normalize();
                // apply movement (tweak speed factor as needed)
                const speed = 2.5; // m/s
                const dt = Math.min(0.05, 1/60); // assume frame delta
                this.cameraRig.position.add(forward.multiplyScalar(-ax1 * speed * dt));
                this.cameraRig.position.add(right.multiplyScalar(ax0 * speed * dt));
            }
            // X button long-press to toggle vrMemoMode - we detect via button index heuristics:
            // Common mapping: button 3 or 4 could correspond to X/A; we will check multiple
            for (let i = 0; i < gamepad.buttons.length; i++) {
                const btn = gamepad.buttons[i];
                if (!btn) continue;
                // detect long press on any candidate button (we assume index 3 or 4 often)
                if ((i === 3 || i === 4) && btn.pressed) {
                    // toggle on press start using simple debounce
                    if (!this._xButtonDown) {
                        this._xButtonDown = performance.now();
                    } else {
                        const dur = performance.now() - this._xButtonDown;
                        if (dur > 600) {
                            this.vrMemoMode = !this.vrMemoMode;
                            this.ui.setStatus(`VRメモモード: ${this.vrMemoMode ? 'ON' : 'OFF'}`);
                            this._xButtonDown = null;
                        }
                    }
                } else if ((i === 3 || i === 4) && !btn.pressed) {
                    this._xButtonDown = null;
                }
            }
        }

        _handleRightGamepad(gamepad) {
            // Right trigger (index 0 or 1 depending on mapping) - robust detection: check first buttons for analog
            const triggerIndex = this._findTriggerIndex(gamepad);
            const gripIndex = this._findGripIndex(gamepad);

            const triggerBtn = triggerIndex !== -1 ? gamepad.buttons[triggerIndex] : null;
            const gripBtn = gripIndex !== -1 ? gamepad.buttons[gripIndex] : null;

            const isTrigger = triggerBtn && (triggerBtn.pressed || triggerBtn.value > 0.1);
            const isGrip = gripBtn && (gripBtn.pressed || gripBtn.value > 0.1);

            if (isTrigger && !this.rightTriggerPressed) {
                // down
                this.rightTriggerPressed = true;
                this.rightTriggerPressTime = performance.now();
            } else if (isTrigger && this.rightTriggerPressed) {
                // held
                const dur = performance.now() - this.rightTriggerPressTime;
                if (dur > this.longPressThreshold && this.rightTriggerPressTime > 0) {
                    // long press -> check for memo under pointer and start edit
                    this.rightTriggerPressTime = -1; // mark handled
                    this._attemptEditAtController(1); // attempt with controller index 1
                }
            } else if (!isTrigger && this.rightTriggerPressed) {
                // up
                const dur = this.rightTriggerPressTime > 0 ? (performance.now() - this.rightTriggerPressTime) : 1000;
                if (dur < this.longPressThreshold) {
                    // short press -> place memo if in vrMemoMode, otherwise zoom out
                    if (this.vrMemoMode) {
                        // add memo at controller 1
                        const controller = this.renderer.xr.getController(1);
                        if (controller) this.memoManager.placeMemoFromController(controller, 2.0);
                        this.vrMemoMode = false; // auto off
                        this.ui.setStatus('VRメモを配置しました（モード解除）');
                    } else {
                        // zoom out (cameraRig backwards)
                        this.cameraRig.translateZ(0.5); // move rig backwards to "zoom out"
                        this.ui.setStatus('ズームアウト（VR）');
                    }
                }
                this.rightTriggerPressed = false;
                this.rightTriggerPressTime = 0;
            }

            // Grip short press zoom in
            if (isGrip) {
                // one-shot behavior if newly pressed
                if (!this._gripDown) {
                    this.cameraRig.translateZ(-0.4);
                    this.ui.setStatus('ズームイン（VR）');
                    this._gripDown = true;
                }
            } else {
                this._gripDown = false;
            }

            // right stick for rotation (if axes present)
            if (gamepad.axes.length >= 4) {
                const rotX = gamepad.axes[2] || 0;
                const rotY = gamepad.axes[3] || 0;
                if (Math.abs(rotX) > 0.12) {
                    this.cameraRig.rotation.y -= rotX * 0.03;
                }
                if (Math.abs(rotY) > 0.12) {
                    // pitch camera (clamped)
                    const cam = this.renderer.xr.getCamera();
                    cam.rotation.x = Math.max(-Math.PI/3, Math.min(Math.PI/3, cam.rotation.x - rotY * 0.02));
                }
            }
        }

        // helper heuristics to find which button index is trigger/grip
        _findTriggerIndex(gamepad) {
            // common: button 0 is trigger; if analog value then fine
            if (gamepad.buttons[0] && (gamepad.buttons[0].value !== undefined)) return 0;
            for (let i = 0; i < Math.min(4, gamepad.buttons.length); i++) {
                if (gamepad.buttons[i] && gamepad.buttons[i].value > 0) return i;
            }
            return -1;
        }
        _findGripIndex(gamepad) {
            // common: button 1 is grip
            if (gamepad.buttons[1]) return 1;
            return -1;
        }

        _attemptEditAtController(controllerIndex) {
            // Raycast from controller and edit memo if hit
            const controller = this.renderer.xr.getController(controllerIndex);
            if (!controller) return;
            const origin = new THREE.Vector3();
            const quat = new THREE.Quaternion();
            controller.getWorldPosition(origin);
            controller.getWorldQuaternion(quat);
            const dir = new THREE.Vector3(0, 0, -1).applyQuaternion(quat);
            const raycaster = new THREE.Raycaster(origin, dir, 0, 10);
            const memo = this.memoManager.findMemoByRay(raycaster);
            if (memo) {
                // Start voice edit flow via UI
                this.ui.startVoiceEdit(memo, (newText) => {
                    this.memoManager.updateMemoText(memo.id, newText);
                    this.ui.setStatus('メモを音声で更新しました');
                });
            } else {
                this.ui.setStatus('編集対象のメモが見つかりませんでした');
            }
        }
    }

    /**********************************************************************
     * UIManager
     * - DOM とアプリ間の接続、ボタンハンドラ、簡易表示管理
     **********************************************************************/
    class UIManager {
        constructor() {
            this.fileInput = document.getElementById('fileInput');
            this.vrButton = document.getElementById('vrButton');
            this.resetButton = document.getElementById('resetButton');
            this.clearButton = document.getElementById('clearButton');
            this.scaleSlider = document.getElementById('scaleSlider');
            this.scaleValue = document.getElementById('scaleValue');
            this.toggleMemoModeBtn = document.getElementById('toggleMemoMode');
            this.toggleMemoPanelBtn = document.getElementById('toggleMemoPanel');
            this.statusEl = document.getElementById('status');
            this.loadingEl = document.getElementById('loading');
            this.memoPanel = document.getElementById('memoPanel');
            this.memoList = document.getElementById('memoList');

            this.onFile = null;
            this.onVR = null;
            this.onReset = null;
            this.onClear = null;
            this.onScale = null;
            this.onToggleMemoMode = null;
            this.onToggleMemoPanel = null;

            this._bind();
            this._speech = null;
            this._speechActiveCallback = null;
        }

        _bind() {
            this.fileInput.addEventListener('change', (e) => {
                const f = e.target.files && e.target.files[0];
                if (f && this.onFile) this.onFile(f);
                this.fileInput.value = '';
            });
            this.vrButton.addEventListener('click', () => this.onVR && this.onVR());
            this.resetButton.addEventListener('click', () => this.onReset && this.onReset());
            this.clearButton.addEventListener('click', () => this.onClear && this.onClear());
            this.scaleSlider.addEventListener('input', (e) => {
                const v = parseFloat(e.target.value);
                this.scaleValue.textContent = `${v.toFixed(2)}x`;
                this.onScale && this.onScale(v);
            });
            this.toggleMemoModeBtn.addEventListener('click', () => this.onToggleMemoMode && this.onToggleMemoMode());
            this.toggleMemoPanelBtn.addEventListener('click', () => {
                this.memoPanel.style.display = (this.memoPanel.style.display === 'block') ? 'none' : 'block';
                this.onToggleMemoPanel && this.onToggleMemoPanel();
            });
        }

        setStatus(msg) {
            this.statusEl.textContent = msg;
        }

        showLoading(flag) {
            this.loadingEl.style.display = flag ? 'block' : 'none';
        }

        updateMemoList(memos, onDelete) {
            this.memoList.innerHTML = '';
            for (const m of memos) {
                const div = document.createElement('div');
                div.className = 'memo-item';
                div.innerHTML = `<div><strong>#${m.id}</strong><div style="white-space:pre-wrap">${this._escapeHtml(m.text)}</div></div>`;
                const del = document.createElement('button');
                del.textContent = '削除';
                del.addEventListener('click', () => onDelete(m.id));
                div.appendChild(del);
                this.memoList.appendChild(div);
            }
        }

        _escapeHtml(s) {
            return String(s).replace(/[&<>"']/g, function (m) { return ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'})[m]; });
        }

        // Voice editing utilities: open speech recognition, call callback on result
        startVoiceEdit(memo, onResult) {
            if (!window.SpeechRecognition && !window.webkitSpeechRecognition) {
                this.setStatus('音声認識未対応の環境です');
                return;
            }
            const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
            if (this._speech) {
                try { this._speech.abort(); } catch (e) {}
                this._speech = null;
            }
            this._speech = new SR();
            this._speech.lang = 'ja-JP';
            this._speech.continuous = false;
            this._speech.interimResults = false;
            this.setStatus('音声入力を開始します… (話してください)');
            this._speech.onresult = (ev) => {
                const txt = ev.results[0][0].transcript;
                onResult && onResult(txt);
                this._speech = null;
                this.setStatus('音声入力完了');
            };
            this._speech.onerror = (e) => {
                console.error('Speech error', e);
                this._speech = null;
                this.setStatus('音声認識エラー');
            };
            try {
                this._speech.start();
            } catch (e) {
                console.error(e);
                this.setStatus('音声認識を開始できませんでした');
            }
        }
    }

    /**********************************************************************
     * App
     * - 初期化、レンダーループ、非XR と XR の切替え等のトップレベル管理
     **********************************************************************/
    class App {
        constructor() {
            this.container = document.getElementById('container');
            this.ui = new UIManager();
            this.scene = new THREE.Scene();
            this.scene.background = new THREE.Color(0x87ceeb);
            this.cameraRig = new THREE.Group();
            this.scene.add(this.cameraRig);

            this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            this.camera.position.set(0, 1.6, 5);
            this.cameraRig.add(this.camera);

            this.renderer = new THREE.WebGLRenderer({ antialias: true });
            this.renderer.setSize(window.innerWidth, window.innerHeight);
            this.renderer.shadowMap.enabled = true;
            this.renderer.xr.enabled = true;
            this.container.appendChild(this.renderer.domElement);

            // Lighting and floor
            this.scene.add(new THREE.AmbientLight(0xffffff, 0.6));
            const dir = new THREE.DirectionalLight(0xffffff, 0.8);
            dir.position.set(5, 10, 5);
            dir.castShadow = true;
            this.scene.add(dir);
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(50, 50), new THREE.MeshStandardMaterial({ color: 0x808080 }));
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            this.scene.add(floor);

            // managers
            this.modelManager = new ModelManager(this.scene, this.ui);
            this.memoManager = new MemoManager(this.scene, this.camera, this.ui);
            this.vrControllerManager = new VRControllerManager(this.renderer, this.cameraRig, this.memoManager, this.ui);

            this._connectUI();
            this._bindEvents();

            this.prevTime = performance.now();
            this.animate = this.animate.bind(this);
            this.renderer.setAnimationLoop(this.animate);

            this.memoMode = false;

            this.ui.setStatus('準備完了');
        }

        _connectUI() {
            this.ui.onFile = (file) => {
                const reader = new FileReader();
                reader.onload = (ev) => {
                    this.modelManager.loadFile(ev.target.result, file.name);
                };
                reader.readAsArrayBuffer(file);
            };
            this.ui.onVR = async () => {
                if ('xr' in navigator) {
                    const supported = await navigator.xr.isSessionSupported('immersive-vr');
                    if (supported) {
                        try {
                            const session = await navigator.xr.requestSession('immersive-vr', { optionalFeatures: ['local-floor', 'bounded-floor', 'hand-tracking'] });
                            await this.renderer.xr.setSession(session);
                            this.ui.setStatus('VR セッション開始');
                        } catch (e) {
                            console.error(e);
                            this.ui.setStatus('VR セッションの開始に失敗しました');
                        }
                    } else {
                        this.ui.setStatus('この環境は WebXR 非対応です');
                    }
                } else {
                    this.ui.setStatus('WebXR をサポートしていません');
                }
            };
            this.ui.onReset = () => {
                this.cameraRig.position.set(0, 0, 0);
                this.camera.position.set(0, 1.6, 5);
                this.camera.quaternion.set(0, 0, 0, 1);
                this.ui.setStatus('カメラをリセットしました');
            };
            this.ui.onClear = () => {
                this.modelManager.removeModel();
            };
            this.ui.onScale = (v) => {
                this.modelManager.setScale(v);
            };
            this.ui.onToggleMemoMode = () => {
                this.memoMode = !this.memoMode;
                if (this.memoMode) {
                    this.ui.setStatus('メモモード ON（クリックで配置）');
                    this.ui.memoPanel.style.display = 'block';
                } else {
                    this.ui.setStatus('メモモード OFF');
                    // keep memo panel visibility state as-is
                }
            };
            this.ui.onToggleMemoPanel = () => { /* no-op for now */ };
        }

        _bindEvents() {
            window.addEventListener('resize', () => {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            });

            // Mouse click to place memo (desktop)
            this.renderer.domElement.addEventListener('pointerdown', (e) => {
                if (!this.memoMode) return;
                // compute ray
                const rect = this.renderer.domElement.getBoundingClientRect();
                const ndc = new THREE.Vector2(((e.clientX - rect.left) / rect.width) * 2 - 1, -((e.clientY - rect.top) / rect.height) * 2 + 1);
                const ray = new THREE.Raycaster();
                ray.setFromCamera(ndc, this.camera);
                // if hit model, place near surface; otherwise place a fixed distance ahead
                const hits = ray.intersectObjects(this.scene.children, true);
                let pos;
                if (hits.length > 0) {
                    const hit = hits[0];
                    pos = hit.point.clone().add(hit.face ? hit.face.normal.clone().transformDirection(hit.object.matrixWorld).multiplyScalar(0.08) : new THREE.Vector3(0,0,0));
                } else {
                    const dir = new THREE.Vector3();
                    this.camera.getWorldDirection(dir);
                    pos = this.camera.position.clone().add(dir.multiplyScalar(3));
                }
                this.memoManager.createMemoAt(pos, 'メモ（手動）');
                this.memoMode = false;
                this.ui.setStatus('メモ配置完了');
            });

            // keyboard controls
            window.addEventListener('keydown', (e) => {
                if (e.code === 'KeyM') {
                    this.ui.onToggleMemoMode && this.ui.onToggleMemoMode();
                }
            });
        }

        animate() {
            const now = performance.now();
            const delta = Math.min(0.05, (now - this.prevTime) / 1000);
            this.prevTime = now;

            // Update VR controllers if in XR
            if (this.renderer.xr.isPresenting) {
                this.vrControllerManager.update(delta);
            }

            // Update memo sprite scales
            this.memoManager.updateSpriteScales();

            this.renderer.render(this.scene, this.camera);
        }
    }

    // 初期化
    const app = new App();

    // expose for debugging in console
    window.app = app;

    </script>
</body>
</html>
