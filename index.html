<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VR GLBショップウォークスルー</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        #container {
            width: 100vw;
            height: 100vh;
            cursor: grab;
        }
        #container:active {
            cursor: grabbing;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            font-size: 14px;
            max-width: 320px;
            z-index: 100;
        }
        #controls {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid rgba(255, 255, 255, 0.3);
        }
        #fileInput {
            margin-top: 10px;
            padding: 8px;
            background: rgba(255, 255, 255, 0.9);
            border: none;
            border-radius: 4px;
            cursor: pointer;
            width: 100%;
        }
        #vrButton {
            margin-top: 10px;
            padding: 12px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            width: 100%;
            font-size: 16px;
            font-weight: bold;
        }
        #vrButton:hover {
            background: #45a049;
        }
        #vrButton:disabled {
            background: #cccccc;
            cursor: not-allowed;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px 40px;
            border-radius: 8px;
            font-size: 18px;
            display: none;
            z-index: 1000;
        }
        #status {
            margin-top: 10px;
            font-size: 12px;
            color: #aaffaa;
        }
    </style>
</head>
<body>
    <div id="container"></div>
    <div id="info">
        <strong>VR ショップウォークスルー</strong><br>
        <div id="controls">
            <strong>PC操作：</strong><br>
            W/↑ : 前進<br>
            S/↓ : 後退<br>
            A/← : 左移動<br>
            D/→ : 右移動<br>
            マウスドラッグ : 視点回転<br>
            <br>
            <strong>VR操作：</strong><br>
            左スティック : 移動<br>
            右スティック : 視点回転<br>
            Aボタン : 上昇<br>
            Bボタン : 下降
        </div>
        <input type="file" id="fileInput" accept=".glb,.gltf" />
        <button id="vrButton">VRモード開始</button>
        <div id="status"></div>
    </div>
    <div id="loading">読み込み中...</div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.module.js",
            "three/examples/jsm/loaders/GLTFLoader": "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/loaders/GLTFLoader.js",
            "three/examples/jsm/webxr/VRButton": "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/webxr/VRButton.js"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader';
        import { VRButton } from 'three/examples/jsm/webxr/VRButton';

        let scene, camera, renderer;
        let moveForward = false, moveBackward = false;
        let moveLeft = false, moveRight = false;
        let canJump = false;
        let velocity = new THREE.Vector3();
        let direction = new THREE.Vector3();
        let prevTime = performance.now();
        let euler = new THREE.Euler(0, 0, 0, 'YXZ');
        let isMouseDown = false;
        let lastMouseX = 0;
        let lastMouseY = 0;
        
        const PLAYER_HEIGHT = 1.6;
        const MOVE_SPEED = 80.0;
        const VR_MOVE_SPEED = 5.0;
        const JUMP_VELOCITY = 8.0;
        const GRAVITY = 20.0;

        const statusEl = document.getElementById('status');
        let controllers = [];
        let isVRMode = false;

        function updateStatus(msg) {
            statusEl.textContent = msg;
            console.log(msg);
        }

        function init() {
            updateStatus('初期化中...');

            // シーン
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 0, 50);

            // カメラ
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, PLAYER_HEIGHT, 5);

            // レンダラー
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.xr.enabled = true;
            document.getElementById('container').appendChild(renderer.domElement);

            // VRボタン
            const vrButton = document.getElementById('vrButton');
            if ('xr' in navigator) {
                navigator.xr.isSessionSupported('immersive-vr').then((supported) => {
                    if (supported) {
                        vrButton.onclick = () => {
                            if (!renderer.xr.isPresenting) {
                                renderer.xr.getSession().then(() => {
                                    isVRMode = true;
                                    updateStatus('VRモード起動');
                                });
                            }
                        };
                        updateStatus('VR対応デバイスを検出');
                    } else {
                        vrButton.disabled = true;
                        vrButton.textContent = 'VR非対応';
                        updateStatus('VR非対応ブラウザ');
                    }
                });
            } else {
                vrButton.disabled = true;
                vrButton.textContent = 'VR非対応';
            }

            // VRButton（three.js標準）を追加
            document.body.appendChild(VRButton.createButton(renderer));

            // コントローラー設定
            const controller1 = renderer.xr.getController(0);
            controller1.addEventListener('connected', (event) => {
                updateStatus('左コントローラー接続');
            });
            scene.add(controller1);
            controllers.push(controller1);

            const controller2 = renderer.xr.getController(1);
            controller2.addEventListener('connected', (event) => {
                updateStatus('右コントローラー接続');
            });
            scene.add(controller2);
            controllers.push(controller2);

            // ライト
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.camera.near = 0.1;
            directionalLight.shadow.camera.far = 50;
            directionalLight.shadow.camera.left = -10;
            directionalLight.shadow.camera.right = 10;
            directionalLight.shadow.camera.top = 10;
            directionalLight.shadow.camera.bottom = -10;
            scene.add(directionalLight);

            // デフォルトの床
            const floorGeometry = new THREE.PlaneGeometry(50, 50);
            const floorMaterial = new THREE.MeshStandardMaterial({ color: 0x808080 });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);

            // サンプルの壁（デモ用）
            createSampleRoom();

            // イベントリスナー
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            
            const container = document.getElementById('container');
            container.addEventListener('mousedown', onMouseDown);
            container.addEventListener('mousemove', onMouseMove);
            container.addEventListener('mouseup', onMouseUp);
            container.addEventListener('mouseleave', onMouseUp);
            
            document.getElementById('fileInput').addEventListener('change', onFileSelect);
            window.addEventListener('resize', onWindowResize);

            updateStatus('準備完了 - GLBファイルを選択してください');
            renderer.setAnimationLoop(animate);
        }

        function createSampleRoom() {
            const wallMaterial = new THREE.MeshStandardMaterial({ color: 0xcccccc });
            
            // 壁
            const wall1 = new THREE.Mesh(new THREE.BoxGeometry(20, 4, 0.2), wallMaterial);
            wall1.position.set(0, 2, -10);
            wall1.castShadow = true;
            scene.add(wall1);

            const wall2 = new THREE.Mesh(new THREE.BoxGeometry(20, 4, 0.2), wallMaterial);
            wall2.position.set(0, 2, 10);
            wall2.castShadow = true;
            scene.add(wall2);

            const wall3 = new THREE.Mesh(new THREE.BoxGeometry(0.2, 4, 20), wallMaterial);
            wall3.position.set(-10, 2, 0);
            wall3.castShadow = true;
            scene.add(wall3);

            const wall4 = new THREE.Mesh(new THREE.BoxGeometry(0.2, 4, 20), wallMaterial);
            wall4.position.set(10, 2, 0);
            wall4.castShadow = true;
            scene.add(wall4);

            // サンプルオブジェクト
            const box = new THREE.Mesh(
                new THREE.BoxGeometry(2, 2, 2),
                new THREE.MeshStandardMaterial({ color: 0xff6b6b })
            );
            box.position.set(-5, 1, -5);
            box.castShadow = true;
            scene.add(box);

            const sphere = new THREE.Mesh(
                new THREE.SphereGeometry(1, 32, 32),
                new THREE.MeshStandardMaterial({ color: 0x4ecdc4 })
            );
            sphere.position.set(5, 1, -5);
            sphere.castShadow = true;
            scene.add(sphere);
        }

        function onFileSelect(event) {
            const file = event.target.files[0];
            if (!file) {
                updateStatus('ファイルが選択されませんでした');
                return;
            }

            updateStatus(`ファイル読み込み中: ${file.name}`);
            const loading = document.getElementById('loading');
            loading.style.display = 'block';

            const reader = new FileReader();
            reader.onload = function(e) {
                updateStatus('GLB解析中...');
                const arrayBuffer = e.target.result;
                loadGLB(arrayBuffer);
            };
            reader.onerror = function() {
                updateStatus('ファイル読み込みエラー');
                loading.style.display = 'none';
            };
            reader.readAsArrayBuffer(file);
        }

        function loadGLB(arrayBuffer) {
            const loader = new GLTFLoader();
            
            loader.parse(arrayBuffer, '', function(gltf) {
                const oldModel = scene.getObjectByName('loadedModel');
                if (oldModel) {
                    scene.remove(oldModel);
                    updateStatus('前のモデルを削除しました');
                }

                const model = gltf.scene;
                model.name = 'loadedModel';
                
                model.traverse(function(node) {
                    if (node.isMesh) {
                        node.castShadow = true;
                        node.receiveShadow = true;
                    }
                });

                const box = new THREE.Box3().setFromObject(model);
                const center = box.getCenter(new THREE.Vector3());
                const size = box.getSize(new THREE.Vector3());

                model.position.x = -center.x;
                model.position.z = -center.z;
                model.position.y = -box.min.y;

                scene.add(model);
                
                updateStatus(`モデル読み込み完了! サイズ: ${size.x.toFixed(1)}x${size.y.toFixed(1)}x${size.z.toFixed(1)}`);
                document.getElementById('loading').style.display = 'none';

                camera.position.set(0, PLAYER_HEIGHT, size.z * 0.5 + 3);

            }, function(error) {
                console.error('GLB読み込みエラー:', error);
                updateStatus('GLB読み込みエラー: ' + error.message);
                document.getElementById('loading').style.display = 'none';
            });
        }

        function onKeyDown(event) {
            switch (event.code) {
                case 'ArrowUp':
                case 'KeyW':
                    moveForward = true;
                    break;
                case 'ArrowDown':
                case 'KeyS':
                    moveBackward = true;
                    break;
                case 'ArrowLeft':
                case 'KeyA':
                    moveLeft = true;
                    break;
                case 'ArrowRight':
                case 'KeyD':
                    moveRight = true;
                    break;
                case 'Space':
                    if (canJump) velocity.y += JUMP_VELOCITY;
                    canJump = false;
                    break;
            }
        }

        function onKeyUp(event) {
            switch (event.code) {
                case 'ArrowUp':
                case 'KeyW':
                    moveForward = false;
                    break;
                case 'ArrowDown':
                case 'KeyS':
                    moveBackward = false;
                    break;
                case 'ArrowLeft':
                case 'KeyA':
                    moveLeft = false;
                    break;
                case 'ArrowRight':
                case 'KeyD':
                    moveRight = false;
                    break;
            }
        }

        function onMouseDown(event) {
            isMouseDown = true;
            lastMouseX = event.clientX;
            lastMouseY = event.clientY;
        }

        function onMouseUp() {
            isMouseDown = false;
        }

        function onMouseMove(event) {
            if (!isMouseDown) return;

            const deltaX = event.clientX - lastMouseX;
            const deltaY = event.clientY - lastMouseY;

            lastMouseX = event.clientX;
            lastMouseY = event.clientY;

            euler.setFromQuaternion(camera.quaternion);
            euler.y -= deltaX * 0.002;
            euler.x -= deltaY * 0.002;
            euler.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, euler.x));
            camera.quaternion.setFromEuler(euler);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function handleVRControllers(delta) {
            const session = renderer.xr.getSession();
            if (!session) return;

            for (let i = 0; i < session.inputSources.length; i++) {
                const inputSource = session.inputSources[i];
                const gamepad = inputSource.gamepad;
                
                if (!gamepad) continue;

                // 左コントローラー（移動）
                if (inputSource.handedness === 'left') {
                    const axes = gamepad.axes;
                    if (axes.length >= 2) {
                        const x = axes[2] || 0; // 左右
                        const z = axes[3] || 0; // 前後
                        
                        const forward = new THREE.Vector3(0, 0, -1);
                        forward.applyQuaternion(camera.quaternion);
                        forward.y = 0;
                        forward.normalize();

                        const right = new THREE.Vector3(1, 0, 0);
                        right.applyQuaternion(camera.quaternion);
                        right.y = 0;
                        right.normalize();

                        camera.position.add(forward.multiplyScalar(-z * VR_MOVE_SPEED * delta));
                        camera.position.add(right.multiplyScalar(x * VR_MOVE_SPEED * delta));
                    }

                    // Aボタン（上昇）
                    if (gamepad.buttons[4] && gamepad.buttons[4].pressed) {
                        camera.position.y += VR_MOVE_SPEED * delta;
                    }
                    // Bボタン（下降）
                    if (gamepad.buttons[5] && gamepad.buttons[5].pressed) {
                        camera.position.y -= VR_MOVE_SPEED * delta;
                        if (camera.position.y < PLAYER_HEIGHT) {
                            camera.position.y = PLAYER_HEIGHT;
                        }
                    }
                }

                // 右コントローラー（視点回転）
                if (inputSource.handedness === 'right') {
                    const axes = gamepad.axes;
                    if (axes.length >= 2) {
                        const x = axes[2] || 0;
                        const y = axes[3] || 0;
                        
                        if (Math.abs(x) > 0.1 || Math.abs(y) > 0.1) {
                            euler.setFromQuaternion(camera.quaternion);
                            euler.y -= x * 0.05 * delta;
                            euler.x -= y * 0.05 * delta;
                            euler.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, euler.x));
                            camera.quaternion.setFromEuler(euler);
                        }
                    }
                }
            }
        }

        function animate() {
            const time = performance.now();
            const delta = (time - prevTime) / 1000;

            if (renderer.xr.isPresenting) {
                handleVRControllers(delta);
            } else {
                // PC操作
                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;
                velocity.y -= GRAVITY * delta;

                direction.z = Number(moveBackward) - Number(moveForward);
                direction.x = Number(moveLeft) - Number(moveRight);
                direction.normalize();

                if (moveForward || moveBackward) velocity.z -= direction.z * MOVE_SPEED * delta;
                if (moveLeft || moveRight) velocity.x -= direction.x * MOVE_SPEED * delta;

                const forward = new THREE.Vector3(0, 0, -1);
                forward.applyQuaternion(camera.quaternion);
                forward.y = 0;
                forward.normalize();

                const right = new THREE.Vector3(1, 0, 0);
                right.applyQuaternion(camera.quaternion);
                right.y = 0;
                right.normalize();

                camera.position.add(forward.multiplyScalar(velocity.z * delta));
                camera.position.add(right.multiplyScalar(velocity.x * delta));
                camera.position.y += velocity.y * delta;

                if (camera.position.y < PLAYER_HEIGHT) {
                    velocity.y = 0;
                    camera.position.y = PLAYER_HEIGHT;
                    canJump = true;
                }
            }

            prevTime = time;
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>