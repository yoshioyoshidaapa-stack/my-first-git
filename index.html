<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>VR GLB„Ç∑„Éß„ÉÉ„Éó„Ç¶„Ç©„Éº„ÇØ„Çπ„É´„ÉºÔºàÈü≥Â£∞Ë™çË≠ò‰øÆÊ≠£ÁâàÔºâ</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; }
        #container { width: 100vw; height: 100vh; cursor: grab; }
        #container:active { cursor: grabbing; }
        #info { position: absolute; top: 10px; left: 10px; color: white; background: rgba(0,0,0,0.7); padding: 15px; border-radius: 8px; font-size: 14px; max-width: 320px; z-index: 100; }
        #controls { margin-top: 10px; padding-top: 10px; border-top: 1px solid rgba(255,255,255,0.3); }
        #fileInput { margin-top: 10px; padding: 8px; background: rgba(255,255,255,0.9); border: none; border-radius: 4px; cursor: pointer; width: 100%; }
        #vrButton { margin-top: 10px; padding: 12px; background: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer; width: 100%; font-size: 16px; font-weight: bold; }
        #vrButton:hover { background: #45a049; }
        #vrButton:disabled { background: #cccccc; cursor: not-allowed; }
        button { cursor: pointer; }
        .btn { margin-top: 10px; padding: 10px; border: none; border-radius: 4px; width: 100%; font-size: 14px; font-weight: bold; }
        #resetButton { background: #ff9800; color: white; }
        #clearButton { background: #f44336; color: white; margin-top: 5px; }
        #scaleControls { margin-top: 10px; padding: 10px; background: rgba(255,255,255,0.1); border-radius: 4px; }
        #scaleSlider { width: 100%; margin: 10px 0; }
        #scaleValue { color: #aaffaa; font-weight: bold; }
        .scaleButtons { display: flex; gap: 5px; margin-top: 5px; }
        .scaleButtons button { flex: 1; padding: 8px; background: #2196F3; color: white; border: none; border-radius: 4px; font-size: 12px; }
        #memoPanel { position: absolute; top: 10px; right: 10px; width: 300px; max-height: 80vh; overflow-y: auto; background: rgba(0, 0, 0, 0.8); color: white; padding: 15px; border-radius: 8px; display: none; z-index: 100; }
        #memoPanel h3 { margin-top: 0; border-bottom: 2px solid #4CAF50; padding-bottom: 10px; }
        .memo-item { background: rgba(255,255,255,0.1); padding: 10px; margin: 5px 0; border-radius: 4px; border-left: 4px solid #ffeb3b; }
        .memo-item button { margin-top: 5px; padding: 4px 8px; font-size: 11px; background: #f44336; color: white; border: none; border-radius: 3px; }
        #status { margin-top:10px; font-size:12px; color:#aaffaa; }
    </style>
</head>
<body>
    <div id="container"></div>

    <div id="info">
        <strong>VR „Ç∑„Éß„ÉÉ„Éó„Ç¶„Ç©„Éº„ÇØ„Çπ„É´„Éº</strong><br>
        <small style="color:#aaa">Èü≥Â£∞Ë™çË≠ò‰øÆÊ≠£Áâà 2026/01/07</small>
        <div id="controls">
            <strong>VR:</strong> Â∑¶„Çπ„ÉÜ„Ç£„ÉÉ„ÇØÁßªÂãï, Âè≥„Çπ„ÉÜ„Ç£„ÉÉ„ÇØË¶ñÁÇπ<br>
            <strong>„Éà„É™„Ç¨„Éº:</strong> Êäº„Åô=Èå≤Èü≥ÈñãÂßã, Èõ¢„Åô=Èå≤Èü≥ÂÅúÊ≠¢<br>
            <strong>B„Éú„Çø„É≥:</strong> „É°„É¢ÂâäÈô§
        </div>
        <input type="file" id="fileInput" accept=".glb,.gltf" />
        <button id="vrButton">VR„É¢„Éº„ÉâÈñãÂßã</button>
        <button id="resetButton" class="btn">„Ç´„É°„É©„É™„Çª„ÉÉ„Éà</button>
        <div id="status"></div>
    </div>

    <div id="memoPanel">
        <h3>„É°„É¢„É™„Çπ„Éà</h3>
        <div id="memoList"></div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>

    <script>
    let scene, camera, renderer, cameraRig;
    let velocity=new THREE.Vector3(), prevTime=performance.now();
    const PLAYER_HEIGHT=1.6, VR_MOVE_SPEED=10, VR_ROTATION_SPEED=1.5;
    let controllers=[], memos=[], memoCounter=0;
    let recognition=null, isRecording=false;
    let editingMemo = null, hoveredMemo = null;
    let rightTriggerPressed=false, btn1WasPressed = false;
    let audioContext = null, audioAnalyser = null, audioDataArray = null;
    let vrDebugText=null, vrDebugCanvas=null;

    function init() {
        scene=new THREE.Scene();
        scene.background=new THREE.Color(0x87CEEB);
        cameraRig=new THREE.Group();
        scene.add(cameraRig);
        camera=new THREE.PerspectiveCamera(75,window.innerWidth/window.innerHeight,0.1,1000);
        camera.position.set(0,PLAYER_HEIGHT,5);
        cameraRig.add(camera);
        renderer=new THREE.WebGLRenderer({antialias:true});
        renderer.setSize(window.innerWidth,window.innerHeight);
        renderer.xr.enabled=true;
        document.getElementById('container').appendChild(renderer.domElement);

        setupVR();
        createVRDebugPanel();

        scene.add(new THREE.AmbientLight(0xffffff,0.6));
        const light=new THREE.DirectionalLight(0xffffff,0.8);
        light.position.set(5,10,5);
        scene.add(light);
        const floor=new THREE.Mesh(new THREE.PlaneGeometry(50,50),new THREE.MeshStandardMaterial({color:0x808080}));
        floor.rotation.x=-Math.PI/2;
        scene.add(floor);

        const sphere=new THREE.Mesh(new THREE.SphereGeometry(0.5,32,32),new THREE.MeshStandardMaterial({color:0xff0000}));
        sphere.position.set(0,0.5,-3);
        scene.add(sphere);

        document.getElementById('fileInput').addEventListener('change',onFileSelect);
        document.getElementById('resetButton').addEventListener('click',resetCamera);
        window.addEventListener('resize',onWindowResize);
        initSpeechRecognition();
        renderer.setAnimationLoop(animate);
    }

    function setupVR() {
        const vrButton=document.getElementById('vrButton');
        if('xr' in navigator) {
            navigator.xr.isSessionSupported('immersive-vr').then(sup=>{
                if(sup) {
                    vrButton.onclick=async()=>{
                        if(!renderer.xr.isPresenting) {
                            try {
                                const s=await navigator.xr.requestSession('immersive-vr',{optionalFeatures:['local-floor']});
                                await renderer.xr.setSession(s);
                            } catch(e) {
                                console.error('XR start failed', e);
                            }
                        }
                    };
                } else {
                    vrButton.disabled=true;
                    vrButton.textContent='VRÈùûÂØæÂøú';
                }
            });
        }

        const c1=renderer.xr.getController(0);
        cameraRig.add(c1);
        controllers.push(c1);
        const c2=renderer.xr.getController(1);
        cameraRig.add(c2);
        controllers.push(c2);

        const lineGeom=new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,0),new THREE.Vector3(0,0,-2)]);
        c1.add(new THREE.Line(lineGeom,new THREE.LineBasicMaterial({color:0xff0000})));
        c2.add(new THREE.Line(lineGeom,new THREE.LineBasicMaterial({color:0x0000ff})));
    }

    function createVRDebugPanel() {
        vrDebugCanvas=document.createElement('canvas');
        vrDebugCanvas.width=512;
        vrDebugCanvas.height=512;
        const tex=new THREE.CanvasTexture(vrDebugCanvas);
        tex.minFilter = THREE.LinearFilter;
        const mat=new THREE.MeshBasicMaterial({map:tex,transparent:true,side:THREE.DoubleSide});
        vrDebugText=new THREE.Mesh(new THREE.PlaneGeometry(1,1),mat);
        vrDebugText.position.set(-1,2,-2);
        vrDebugText.renderOrder = 9999;
        scene.add(vrDebugText);
        updateVRDebugPanel('VR Debug Ready');
    }

    function updateVRDebugPanel(txt) {
        if(!vrDebugCanvas)return;
        const ctx=vrDebugCanvas.getContext('2d');
        ctx.clearRect(0,0,512,512);
        ctx.fillStyle='rgba(0,0,0,0.9)';
        ctx.fillRect(0,0,512,512);
        ctx.strokeStyle='#0f0';
        ctx.lineWidth=4;
        ctx.strokeRect(0,0,512,512);
        ctx.fillStyle='#0f0';
        ctx.font='bold 20px monospace';
        ctx.textAlign='left';
        ctx.textBaseline='top';
        txt.split('\n').forEach((l,i)=>ctx.fillText(l,15,15+i*28));
        if(vrDebugText?.material?.map) vrDebugText.material.map.needsUpdate=true;
    }

    function onFileSelect(e) {
        const f=e.target.files[0];
        if(!f)return;
        const r=new FileReader();
        r.onload=ev=>{
            new THREE.GLTFLoader().parse(ev.target.result,'',gltf=>{
                const old=scene.getObjectByName('loadedModel');
                if(old) scene.remove(old);
                gltf.scene.name='loadedModel';
                scene.add(gltf.scene);
            });
        };
        r.readAsArrayBuffer(f);
    }

    function resetCamera() {
        cameraRig.position.set(0,0,0);
        camera.position.set(0,PLAYER_HEIGHT,5);
        camera.rotation.set(0,0,0);
    }

    function initSpeechRecognition() {
        if('webkitSpeechRecognition' in window||'SpeechRecognition' in window) {
            const SR=window.SpeechRecognition||window.webkitSpeechRecognition;
            recognition=new SR();
            recognition.lang='ja-JP';
            recognition.continuous=false;
            recognition.interimResults=false;
            console.log('Speech recognition initialized');
        } else {
            console.error('Speech recognition not supported');
        }
    }

    function createMemo(pos, txt, lookAtPos) {
        const id = memoCounter++;
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 512;
        canvas.height = 200;
        ctx.fillStyle = '#ffd93d';
        ctx.fillRect(0,0,512,200);
        ctx.fillStyle = '#000';
        ctx.font = 'bold 32px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(txt,256,100);

        const tex = new THREE.CanvasTexture(canvas);
        tex.minFilter = THREE.LinearFilter;
        const geom = new THREE.PlaneGeometry(0.6, 0.6 * (200/512));
        const mat = new THREE.MeshBasicMaterial({map: tex, transparent: true, side: THREE.DoubleSide});
        const mesh = new THREE.Mesh(geom, mat);
        mesh.position.copy(pos);
        if(lookAtPos) mesh.lookAt(lookAtPos);
        mesh.renderOrder = 9999;
        mesh.name = `memo_${id}`;
        mesh.userData.isMemo = true;
        scene.add(mesh);
        memos.push({id, text: txt, position: pos.clone(), sprite: mesh});
        updateMemoList();
    }

    function deleteMemo(id) {
        const idx=memos.findIndex(m=>m.id===id);
        if(idx!==-1) {
            if(memos[idx].sprite) scene.remove(memos[idx].sprite);
            memos.splice(idx,1);
            updateMemoList();
        }
    }

    function updateMemoList() {
        const list=document.getElementById('memoList');
        list.innerHTML='';
        memos.forEach(m=>{
            const item=document.createElement('div');
            item.className='memo-item';
            item.innerHTML=`<div><strong>#${m.id+1}</strong>: ${m.text}</div><button type="button">ÂâäÈô§</button>`;
            item.querySelector('button').addEventListener('click',()=>deleteMemo(m.id));
            list.appendChild(item);
        });
    }

    function startEditMemo(memo) {
        updateVRDebugPanel('START EDIT\nMemo: ' + memo.id + '\nRecognition: ' + (recognition ? 'OK' : 'NULL'));
        
        if(!recognition) {
            updateVRDebugPanel('ERROR: No recognition');
            return;
        }

        if(isRecording) {
            try { recognition.stop(); } catch(e) {}
            isRecording = false;
        }

        if(editingMemo && editingMemo.editFrame) {
            scene.remove(editingMemo.editFrame);
            delete editingMemo.editFrame;
        }
        
        editingMemo = memo;
        const frame = new THREE.Mesh(
            new THREE.PlaneGeometry(memo.sprite.geometry.parameters.width * 1.15, memo.sprite.geometry.parameters.height * 1.15),
            new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.4, side: THREE.DoubleSide })
        );
        frame.position.copy(memo.sprite.position);
        frame.rotation.copy(memo.sprite.rotation);
        frame.position.z -= 0.01;
        scene.add(frame);
        memo.editFrame = frame;

        // Èå≤Èü≥„Éû„Éº„ÇØ‰ΩúÊàê
        const recordingCanvas = document.createElement('canvas');
        recordingCanvas.width = 512;
        recordingCanvas.height = 256;
        const recordingTex = new THREE.CanvasTexture(recordingCanvas);
        const recordingMark = new THREE.Mesh(
            new THREE.PlaneGeometry(1.0, 0.5),
            new THREE.MeshBasicMaterial({ map: recordingTex, transparent: true, side: THREE.DoubleSide })
        );
        recordingMark.position.copy(memo.sprite.position);
        recordingMark.rotation.copy(memo.sprite.rotation);
        recordingMark.position.y += 0.5;
        recordingMark.renderOrder = 10000;
        scene.add(recordingMark);
        memo.recordingMark = recordingMark;

        // „Éû„Ç§„ÇØÂèñÂæó
        navigator.mediaDevices.getUserMedia({ audio: true })
            .then(stream => {
                if(!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                
                const source = audioContext.createMediaStreamSource(stream);
                audioAnalyser = audioContext.createAnalyser();
                audioAnalyser.fftSize = 256;
                source.connect(audioAnalyser);
                audioDataArray = new Uint8Array(audioAnalyser.frequencyBinCount);
                
                let animationId;
                function animateEqualizer() {
                    if(!audioAnalyser || !editingMemo) {
                        cancelAnimationFrame(animationId);
                        stream.getTracks().forEach(track => track.stop());
                        return;
                    }
                    
                    audioAnalyser.getByteTimeDomainData(audioDataArray);
                    let sum = 0;
                    for(let i = 0; i < audioDataArray.length; i++) {
                        const value = audioDataArray[i] - 128;
                        sum += value * value;
                    }
                    const rms = Math.sqrt(sum / audioDataArray.length);
                    const normalizedVolume = rms / 128;
                    
                    const ctx = recordingCanvas.getContext('2d');
                    ctx.fillStyle = 'rgba(0,0,0,0.8)';
                    ctx.fillRect(0, 0, 512, 256);
                    
                    ctx.fillStyle = 'rgba(255,0,0,0.9)';
                    ctx.beginPath();
                    ctx.arc(100, 128, 60, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 60px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('üé§', 100, 128);
                    
                    for(let i = 0; i < 8; i++) {
                        const height = normalizedVolume * 180 * (0.7 + Math.random() * 0.3) + 20;
                        const x = 220 + i * 40;
                        const y = 128 - height / 2;
                        const gradient = ctx.createLinearGradient(x, y, x, y + height);
                        gradient.addColorStop(0, '#00ff00');
                        gradient.addColorStop(0.5, '#ffff00');
                        gradient.addColorStop(1, '#ff0000');
                        ctx.fillStyle = gradient;
                        ctx.fillRect(x, y, 30, height);
                    }
                    
                    recordingTex.needsUpdate = true;
                    animationId = requestAnimationFrame(animateEqualizer);
                }
                animateEqualizer();
                
                memo.audioStream = stream;
                memo.animationId = animationId;
                
                // ‚òÖ‚òÖ‚òÖ „Ç§„Éô„É≥„Éà„Éè„É≥„Éâ„É©„Çí„Åì„Åì„ÅßÂÆöÁæ© ‚òÖ‚òÖ‚òÖ
                recognition.onresult = ev => {
                    console.log('===== ONRESULT =====');
                    const transcript = ev.results[0][0].transcript;
                    console.log('Transcript:', transcript);
                    isRecording = false;
                    
                    if(editingMemo.audioStream) {
                        editingMemo.audioStream.getTracks().forEach(track => track.stop());
                        delete editingMemo.audioStream;
                    }
                    if(editingMemo.animationId) {
                        cancelAnimationFrame(editingMemo.animationId);
                        delete editingMemo.animationId;
                    }
                    if(editingMemo.recordingMark) {
                        scene.remove(editingMemo.recordingMark);
                        delete editingMemo.recordingMark;
                    }
                    if(editingMemo.editFrame) {
                        scene.remove(editingMemo.editFrame);
                        delete editingMemo.editFrame;
                    }
                    if (editingMemo.sprite) scene.remove(editingMemo.sprite);
                    
                    createMemo(editingMemo.position, transcript, camera.position);
                    updateVRDebugPanel('Updated: ' + transcript);
                    editingMemo = null;
                };
                
                recognition.onerror = (e) => {
                    console.error('Recognition error', e);
                    isRecording = false;
                    if(editingMemo && editingMemo.audioStream) {
                        editingMemo.audioStream.getTracks().forEach(track => track.stop());
                        delete editingMemo.audioStream;
                    }
                    if(editingMemo && editingMemo.animationId) {
                        cancelAnimationFrame(editingMemo.animationId);
                        delete editingMemo.animationId;
                    }
                    if(editingMemo && editingMemo.recordingMark) {
                        scene.remove(editingMemo.recordingMark);
                        delete editingMemo.recordingMark;
                    }
                    if(editingMemo && editingMemo.editFrame) {
                        scene.remove(editingMemo.editFrame);
                        delete editingMemo.editFrame;
                    }
                    editingMemo = null;
                    updateVRDebugPanel('Error: ' + e.error);
                };
                
                recognition.onend = () => {
                    console.log('===== ONEND =====');
                    if(!editingMemo) return;
                    isRecording = false;
                };
                
                // Èü≥Â£∞Ë™çË≠òÈñãÂßã
                try {
                    isRecording = true;
                    recognition.start();
                    updateVRDebugPanel('Recording started');
                    console.log('Recognition started');
                } catch (e) {
                    console.error('Start error', e);
                    updateVRDebugPanel('Start error: ' + e.message);
                }
            })
            .catch(err => {
                console.error('Microphone error:', err);
                updateVRDebugPanel('Mic error: ' + err.message);
            });
    }

    function onWindowResize() {
        camera.aspect=window.innerWidth/window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth,window.innerHeight);
    }

    function handleVRControllers(delta) {
        const session=renderer.xr.getSession();
        if(!session || !session.inputSources) {
            updateVRDebugPanel('No VR session');
            return;
        }

        let debugInfo=['VR Debug',''];

        for(let i=0;i<session.inputSources.length;i++) {
            const inputSource=session.inputSources[i];
            const gamepad=inputSource.gamepad;
            if(!gamepad) continue;

            if(inputSource.handedness==='left') {
                let moveX=0,moveZ=0;
                if(Math.abs(gamepad.axes[0])>0.05)moveX=gamepad.axes[0];
                if(Math.abs(gamepad.axes[1])>0.05)moveZ=-gamepad.axes[1];
                if(Math.abs(moveX)>0.05||Math.abs(moveZ)>0.05) {
                    const forward=new THREE.Vector3(0,0,-1);
                    forward.applyQuaternion(camera.getWorldQuaternion(new THREE.Quaternion()));
                    forward.y=0;
                    forward.normalize();
                    const right=new THREE.Vector3(1,0,0);
                    right.applyQuaternion(camera.getWorldQuaternion(new THREE.Quaternion()));
                    right.y=0;
                    right.normalize();
                    cameraRig.position.add(forward.multiplyScalar(moveZ*VR_MOVE_SPEED*delta));
                    cameraRig.position.add(right.multiplyScalar(moveX*VR_MOVE_SPEED*delta));
                }
            }

            if(inputSource.handedness==='right') {
                const axes=gamepad.axes;
                if(axes.length>=4) {
                    const rotX=axes[2]||0;
                    if(Math.abs(rotX)>0.1) {
                        cameraRig.rotation.y-=rotX*VR_ROTATION_SPEED*delta;
                    }
                }

                // „Éõ„Éê„ÉºÊ§úÂá∫
                try {
                    const raycaster = new THREE.Raycaster();
                    const pos = new THREE.Vector3();
                    const quat = new THREE.Quaternion();
                    controllers[1].getWorldPosition(pos);
                    controllers[1].getWorldQuaternion(quat);
                    const dir = new THREE.Vector3(0, 0, -1).applyQuaternion(quat);
                    raycaster.set(pos, dir);
                    raycaster.near = 0.01;
                    raycaster.far = 20;
                    const memoObjs = memos.map(m => m.sprite).filter(Boolean);
                    const hits = raycaster.intersectObjects(memoObjs, false);
                    
                    if(hoveredMemo && hoveredMemo.hoverFrame) {
                        scene.remove(hoveredMemo.hoverFrame);
                        delete hoveredMemo.hoverFrame;
                        hoveredMemo = null;
                    }
                    
                    if(hits.length > 0) {
                        const hitObj = hits[0].object;
                        const memo = memos.find(m => m.sprite === hitObj);
                        if(memo && memo !== editingMemo) {
                            hoveredMemo = memo;
                            const hoverFrame = new THREE.Mesh(
                                new THREE.PlaneGeometry(memo.sprite.geometry.parameters.width * 1.1, memo.sprite.geometry.parameters.height * 1.1),
                                new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.3, side: THREE.DoubleSide })
                            );
                            hoverFrame.position.copy(memo.sprite.position);
                            hoverFrame.rotation.copy(memo.sprite.rotation);
                            hoverFrame.position.z -= 0.005;
                            scene.add(hoverFrame);
                            memo.hoverFrame = hoverFrame;
                            debugInfo.push('HOVERING #' + memo.id);
                        }
                    }
                } catch(e) {
                    console.error('Hover error', e);
                }

                // B„Éú„Çø„É≥„ÅßÂâäÈô§
                const btn1=gamepad.buttons[1];
                const isBtn1Pressed=btn1&&btn1.pressed;
                if(isBtn1Pressed&&!btn1WasPressed && hoveredMemo) {
                    if(hoveredMemo.hoverFrame) {
                        scene.remove(hoveredMemo.hoverFrame);
                        delete hoveredMemo.hoverFrame;
                    }
                    deleteMemo(hoveredMemo.id);
                    hoveredMemo = null;
                    debugInfo.push('DELETED');
                }
                btn1WasPressed=isBtn1Pressed;

                // „Éà„É™„Ç¨„ÉºÂá¶ÁêÜ
                const triggerBtn=gamepad.buttons[0];
                const isTriggerPressed=triggerBtn&&triggerBtn.pressed;

                if(isTriggerPressed&&!rightTriggerPressed) {
                    rightTriggerPressed=true;
                    debugInfo.push('Trigger DOWN');
                    
                    if(hoveredMemo) {
                        debugInfo.push('EDIT #' + hoveredMemo.id);
                        startEditMemo(hoveredMemo);
                    } else {
                        debugInfo.push('NEW MEMO');
                        const pos = new THREE.Vector3();
                        const quat = new THREE.Quaternion();
                        controllers[1].getWorldPosition(pos);
                        controllers[1].getWorldQuaternion(quat);
                        const dir = new THREE.Vector3(0, 0, -1).applyQuaternion(quat);
                        const position = pos.clone().add(dir.multiplyScalar(2));
                        createMemo(position, "...", pos);
                        const newMemo = memos[memos.length - 1];
                        startEditMemo(newMemo);
                    }
                } else if(!isTriggerPressed&&rightTriggerPressed) {
                    rightTriggerPressed=false;
                    debugInfo.push('Trigger UP');
                    
                    if(recognition && isRecording && editingMemo) {
                        try {
                            recognition.stop();
                            debugInfo.push('STOP RECORDING');
                        } catch(e) {
                            console.error('Stop error:', e);
                        }
                    }
                }
            }
        }

        updateVRDebugPanel(debugInfo.join('\n'));
    }

    function animate() {
        const time=performance.now();
        const delta=(time-prevTime)/1000;
        if(renderer.xr.isPresenting) {
            handleVRControllers(delta);
        }
        prevTime=time;
        renderer.render(scene,camera);
    }

    init();
    </script>
</body>
</html>
